<!DOCTYPE html><html lang="cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="robots" content="index, follow"><title>closure: 以 python 和 JavaScript 为例 • 商业与数据</title><meta name="description" content="closure: 以 python 和 JavaScript 为例 - Yu Qin"><link rel="icon" href="/blog/favicon.svg"><link rel="stylesheet" href="https://unpkg.com/nanoreset@3.0.1/nanoreset.min.css"><link rel="stylesheet" href="/blog/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/blog/atom.xml" title="商业与数据"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/blog/atom.xml" title="商业与数据" type="application/atom+xml">
</head><body><div class="wrap" id="barba-wrapper"><header><h1 class="branding"><a href="/blog/" title="商业与数据">商业与数据</a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link no-barba" href="/blog/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/blog/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="https://github.com/YuPototo" target="_blank">GITHUB</a></li></ul></header><div class="barba-container"><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">closure: 以 python 和 JavaScript 为例</h1><div class="post-info"><a></a>2017-03-05</div><div class="post-content"><p>计算机语言里有个常用的概念，叫 closure（闭包）。这里用 python 和 JavaScript 作为对照例子，解释一下 closure 的含义。</p>
<p>先看一个问题，下面一段 python 代码，会在 terminal 上打印什么呢？</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">func = outer()</span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<p>上面的代码出现了若干次 a，第1个 a 在“最外面”，第2个 a 在 outer 函数里，第3个 a 出现在 inner 函数里，而 inner 函数又在 outer 函数里。</p>
<p>上面这段话可以用 scope 的概念重新描述：</p>
<ul>
<li>第1个 a 在 global scope 中，整段代码都可以使用</li>
<li>第2个 a 在 outer 函数的 scope 中</li>
<li>第3个 a 不是个变量，是对变量的使用，那么它会使用第1个a、还是第2个a、还是报错呢？</li>
</ul>
<p>答案：terminal 回打印出 1，也就是说，inner 函数使用了 outer 函数里的 a。</p>
<p>这里有两个值得深究的地方。我们一个个看。</p>
<h2 id="1-向上查询"><a href="#1-向上查询" class="headerlink" title="1. 向上查询"></a>1. 向上查询</h2><p>先看下面这段代码。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">  print(a)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure>

<p>在运行 func 函数时，计算机会现在 func 的 scope 寻找 a 变量，但我们没有定义 a 变量，这时计算机会“向上一层”查询，上一层就是 global scope，我们在上一层定义了 a 并令它为 1，计算机就认为自己找到了 a，于是打印出 a 的内容：1。</p>
<p>同样一段代码，可以在 JavaScript 中轻松实现：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">myFunc()</span><br></pre></td></tr></tbody></table></figure>


<p>R 中也有类似的设计：</p>
<figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">my_function &lt;- <span class="keyword">function</span>() {</span><br><span class="line">  print(a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">my_function()</span><br></pre></td></tr></tbody></table></figure>

<p>我们运行上面3段代码时，都会得到 1。</p>
<p>在最开始的代码段里，上一层的 a 在 outer 函数里，是1，此时计算机不再往上寻找 a，所以就打印出了 1。如果我们把 outer 函数里的 <code>a = 1</code> 删掉呢？此时代码如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">func = outer()</span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure>

<p>因为找不到计算机在 outer 里找不到 a，它继续往上寻找，在 global scope 里找到了 a，于是打印出了 2。</p>
<p>这样的设计乍看之下不太友好：如果我们不小心在函数里使用了某个 global scope 的变量，计算机就不会报错，而是会继续运行程序。这岂不是不利于代码的稳定性。</p>
<p>虽然有这个潜在风险，很多语言还是选择了这个设计，自然是因为这个设计是有价值的。价值在哪儿呢？这就涉及到示例代码中第2个值得深究的地方了。</p>
<h2 id="2-函数可以返回函数"><a href="#2-函数可以返回函数" class="headerlink" title="2. 函数可以返回函数"></a>2. 函数可以返回函数</h2><p>在 python、R 和 JavaScript 里，函数都可以返回函数。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">func = outer()</span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure>

<p>我们的 outer 函数的 return 值是一个 inner 函数。<br>通过 <code>func = outer()</code>，我们让 func 变成了 inner 函数。</p>
<p>这里值得注意的地方是，我们 return 的明明只是 inner 函数，代码里只有 <code>print(a)</code>这行，为什么这个 inner 函数会记住自己所在的 scope 里有个 a 变量呢？这就是 closure 这个概念了。</p>
<p>当我们在 outer 函数里返回 inner 函数时，与 inner 函数在同一个 scope 里面的变量也会被“包”进 inner 函数中，变成 inner 函数的 private variable。</p>
<p>这是一个非常有用的概念。</p>
<h2 id="closure-的应用"><a href="#closure-的应用" class="headerlink" title="closure 的应用"></a>closure 的应用</h2><p>我最喜欢的 closure 应用场景，是批量生成函数。</p>
<p>问题场景：我需要生成一组幂函数的值，指数分别为 2、3、4, x 分别是 -10 到 10 之间的整数。</p>
<p>在我不知道 closure 时，我会想生成一个带有2个参数的函数，然后使用 list comprehension。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power_func</span><span class="params">(x, power)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> x ** power</span><br><span class="line"></span><br><span class="line">[ power_func(i, <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br><span class="line">[ power_func(i, <span class="number">3</span>) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br><span class="line">[ power_func(i, <span class="number">4</span>) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br></pre></td></tr></tbody></table></figure>

<p>这是一个看上去简单的解答，但并不是一个代码层面更“好”的解答。因为，有可能我们想要在多种场合重复使用某几个幂指数的函数，比如幂指数为2的函数，可能在我们的计算里非常常用，这时最好的做法是生成一个幂指数为2的函数，然后重复使用它。</p>
<p>这时就需要使用 closure了。如果使用 closure，上面的问题会这样解答：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power_func</span><span class="params">(power)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner_func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** power</span><br><span class="line">  <span class="keyword">return</span> inner_func</span><br><span class="line"></span><br><span class="line">power_two = power_func(<span class="number">2</span>)</span><br><span class="line">power_three = power_func(<span class="number">3</span>)</span><br><span class="line">power_four = power_func(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ power_two(i) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br><span class="line">[ power_three(i) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br><span class="line">[ power_four(i) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br></pre></td></tr></tbody></table></figure>

<p>这段代码看上去更长，但从“思路”上其实方便，代码的可读性也强了非常多。</p>
<p>类似的思考方式其实是写代码到一定阶段后必然会碰到的：如何抽象地设计出一个生成函数的函数，让我们的代码可读性更高，更加 DRY（ don’t repeat yourself ）。</p>
<p>同样一段代码，如果使用 JavaScript，可以这样写：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">powerFunc</span>(<span class="params">power</span>) </span>{</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span>(<span class="params">x</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, power)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> innerFunc</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> powerTwo = powerFunc(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> powerThree = powerFunc(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> powerFour = powerFunc(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numRange = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">21</span>), (x,i) =&gt; i - <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numRange.map(<span class="function"><span class="params">el</span> =&gt;</span> powerTwo(el)))</span><br><span class="line"><span class="built_in">console</span>.log(numRange.map(<span class="function"><span class="params">el</span> =&gt;</span> powerThree(el)))</span><br><span class="line"><span class="built_in">console</span>.log(numRange.map(<span class="function"><span class="params">el</span> =&gt;</span> powerFour(el)))</span><br></pre></td></tr></tbody></table></figure>


<h2 id="JavaScript-的连续箭头函数"><a href="#JavaScript-的连续箭头函数" class="headerlink" title="JavaScript 的连续箭头函数"></a>JavaScript 的连续箭头函数</h2><p>理解了 closure 的概念后，下面这段 JavaScript 代码就很好理解了：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeAddFunc = <span class="function"><span class="params">adder</span> =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> x + adder</span><br></pre></td></tr></tbody></table></figure>

<p>这其实就是 closure 的箭头函数写法，这里连续使用了两个箭头函数。完整写法如下：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAddFunc</span>(<span class="params">adder</span>) </span>{</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span>(<span class="params">x</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> x + adder</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> innerFunc</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以用上面的 makeAddFunc 生成若干自己需要的函数：</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addTwo = makeAddFunc(<span class="number">2</span>)</span><br><span class="line">addThree = makeAddFunc(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(addTwo(<span class="number">5</span>)) <span class="comment">// print 7</span></span><br><span class="line"><span class="built_in">console</span>.log(addThree(<span class="number">5</span>)) <span class="comment">// print 8</span></span><br></pre></td></tr></tbody></table></figure>



<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>个人经验来说，closure 是一个“分水岭”，区分开新手 coder 和中级 coder。</p>
<p>如果我们对 closure 足够熟悉，我们会发现某些特定的场合简直是为 closure 天然而生。学会在这些场合使用 closure，会让我们的代码质量上一个台阶。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div></article></div></main><footer><div class="paginator"><a class="prev" href="/blog/2018/05/06/2018-05-07-%E6%95%B0%E6%8D%AE%E5%9B%A2%E9%98%9F/">prev</a><a class="next" href="/blog/2017/02/03/2017-02-03-ggplot-mosaic/">next</a></div><div class="copyright"><p>&copy; 2020 <a href="http://yoursite.com">Yu Qin</a><br>Powered by <a href="https://hexo.io/" rel="noreferrer" target="_blank">Hexo</a></p></div></footer></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
    Barba.Pjax.start()
})</script></body></html>