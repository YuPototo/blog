<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>商业与数据</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-22T19:42:39.787Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yu Qin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>模拟“中心极限定理” - 比例篇</title>
    <link href="http://yoursite.com/2020/01/22/simu-clt-2/"/>
    <id>http://yoursite.com/2020/01/22/simu-clt-2/</id>
    <published>2020-01-22T19:13:45.000Z</published>
    <updated>2020-01-22T19:42:39.787Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇模拟了均值的中心极限定理，这一篇再扩展一下。</p><p>中心极限定理不只适用于均值，还可用于对“占比”的描述。什么是占比呢？</p><p>例子：</p><ul><li>总统选举中候选人 A 的支持率</li><li>App Store 落地页的下载转化率</li><li>认为 Google 股票会上涨的股民比例</li><li>…</li></ul><p>在互联网行业，这个指标最重要的应用应该是各种转化率。</p><p>中心极限定理公诉我们，当样本足够大时，样本的比例符合正态分布。</p><p>该分布的均值等于总体的分布：</p><p><img src="/blog/2020/01/22/simu-clt-2/mean.png" class="" title="mean_of_sample_dist"></p><p>该分布的标准差可以用如下公式计算：<br><img src="/blog/2020/01/22/simu-clt-2/se.png" class="" title="se_of_sample_dist"></p><p>接下来我们模拟 proportion 的中心极限定理。</p><p><a id="more"></a></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>假设某 app 有100万个用户，该 app 想上线一个新功能，但直接全量上线是不太好，风险太大。</p><p>为了测试这个新功能是否受欢迎，产品经理决定先让一部分用户试用，然后再对他们做调查，提问他们是否喜欢这个功能。</p><p>根据中心极限定理，样本量越大越符合正态分布，且方差越小。我们模拟不同样本量下的估计值的分布。</p><h2 id="R-代码"><a href="#R-代码" class="headerlink" title="R 代码"></a>R 代码</h2><p>代码跟上一篇差不多。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(tidyverse)</span><br><span class="line"><span class="keyword">library</span>(ggpubr)</span><br><span class="line"></span><br><span class="line">set.seed(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">pop_size &lt;- <span class="number">1000000</span></span><br><span class="line">pop_player &lt;- c(rep(<span class="string">"like"</span>, <span class="number">0.7</span> * pop_size), rep(<span class="string">"dislike"</span>, <span class="number">0.3</span> * pop_size))</span><br></pre></td></tr></tbody></table></figure><p>准备需要的 package，并定好随机数。然后创建100万名用户，其中有70%的人会喜欢新功能，有30%的人会不喜欢。</p><h3 id="函数：抽样、模拟、做图"><a href="#函数：抽样、模拟、做图" class="headerlink" title="函数：抽样、模拟、做图"></a>函数：抽样、模拟、做图</h3><p>这段代码跟上一篇差不多：</p><ul><li><code>sample_player</code> 进行一次抽样，可以选择抽样人数</li><li><code>simulate_df</code> 模拟 n 次实验</li><li><code>draw_plot</code> 对 n 次实验的结果做图</li><li><code>simulate_and_draw</code> 封装了上面几个函数</li></ul><p>针对这篇的主题，某些地方做了调整。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">sample_player &lt;- <span class="keyword">function</span>(size) {</span><br><span class="line">  sample_vec &lt;- sample(pop_player, size = size)</span><br><span class="line">  sum(sample_vec == <span class="string">"like"</span>) / size</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">simulate_df &lt;- <span class="keyword">function</span>(size, n) {</span><br><span class="line">  df &lt;- data.frame(sample_prop = rep(<span class="number">0</span>, n))</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:n) {</span><br><span class="line">    df[i, <span class="number">1</span>] &lt;- sample_player(size)</span><br><span class="line">  }</span><br><span class="line">  df</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">draw_plot &lt;- <span class="keyword">function</span>(df, size, bin_width=<span class="number">0.1</span>) {</span><br><span class="line">  stan_dev &lt;- round(sd(df$sample_prop), <span class="number">2</span>)</span><br><span class="line">  ggplot(df, aes(x = sample_prop)) + </span><br><span class="line">    geom_histogram(binwidth = bin_width) +</span><br><span class="line">    scale_x_continuous(labels = scales::percent,</span><br><span class="line">                       limits = c(<span class="number">0</span>: <span class="number">1</span>)) +</span><br><span class="line">    labs(title = str_c(<span class="string">'调查'</span>, size, <span class="string">'个玩家'</span>),</span><br><span class="line">         subtitle = str_c(<span class="string">'点估计标准差 = '</span>, stan_dev),</span><br><span class="line">         x = <span class="string">'表示"喜欢的"玩家占比'</span>,</span><br><span class="line">         y = <span class="string">'频数'</span>) </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">simulate_and_draw &lt;- <span class="keyword">function</span>(size, n = <span class="number">5000</span>, bin_width = <span class="number">0.1</span>) {</span><br><span class="line">  simulate_df(size, n) %&gt;%</span><br><span class="line">  draw_plot(size, bin_width)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="做图"><a href="#做图" class="headerlink" title="做图"></a>做图</h3><p>下面计算抽样5人、10人、20人、40人、100人和1000人的情况，为了节约运算时间，模拟5000轮：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p1 &lt;- simulate_and_draw(<span class="number">5</span>, bin_width = <span class="number">0.1</span>)</span><br><span class="line">p2 &lt;- simulate_and_draw(<span class="number">10</span>, bin_width = <span class="number">0.05</span>)</span><br><span class="line">p3 &lt;- simulate_and_draw(<span class="number">20</span>, bin_width = <span class="number">0.05</span>)</span><br><span class="line">p4 &lt;- simulate_and_draw(<span class="number">40</span>, bin_width = <span class="number">0.025</span>)</span><br><span class="line">p5 &lt;- simulate_and_draw(<span class="number">100</span>, bin_width = <span class="number">0.01</span>)</span><br><span class="line">p6 &lt;- simulate_and_draw(<span class="number">1000</span>, bin_width = <span class="number">0.003</span>)</span><br><span class="line"></span><br><span class="line">ggarrange(p1, p2, p3, p4, p5, p6,</span><br><span class="line">          nrow = <span class="number">3</span>, ncol = <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>做图结果如下：</p><p><img src="/blog/2020/01/22/simu-clt-2/plot_all.png" class="" title="plot_all"></p><p>可以看到：</p><ul><li>样本数量足够大时，样本内 proportion 的分布接近正态分布</li><li>样本数量越大，分布的标准差越小</li></ul><p>对于一个100万用户的产品，如果新功能受到70%人喜欢，调查1000个用户就足以知道新功能是否受欢迎了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇模拟了均值的中心极限定理，这一篇再扩展一下。&lt;/p&gt;
&lt;p&gt;中心极限定理不只适用于均值，还可用于对“占比”的描述。什么是占比呢？&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总统选举中候选人 A 的支持率&lt;/li&gt;
&lt;li&gt;App Store 落地页的下载转化率&lt;/li&gt;
&lt;li&gt;认为 Google 股票会上涨的股民比例&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在互联网行业，这个指标最重要的应用应该是各种转化率。&lt;/p&gt;
&lt;p&gt;中心极限定理公诉我们，当样本足够大时，样本的比例符合正态分布。&lt;/p&gt;
&lt;p&gt;该分布的均值等于总体的分布：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/01/22/simu-clt-2/mean.png&quot; class=&quot;&quot; title=&quot;mean_of_sample_dist&quot;&gt;&lt;/p&gt;
&lt;p&gt;该分布的标准差可以用如下公式计算：&lt;br&gt;&lt;img src=&quot;/blog/2020/01/22/simu-clt-2/se.png&quot; class=&quot;&quot; title=&quot;se_of_sample_dist&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来我们模拟 proportion 的中心极限定理。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计理论" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>模拟“中心极限定理” - 均值篇</title>
    <link href="http://yoursite.com/2020/01/22/simu-clt-1/"/>
    <id>http://yoursite.com/2020/01/22/simu-clt-1/</id>
    <published>2020-01-22T17:39:54.000Z</published>
    <updated>2020-01-22T19:42:39.787Z</updated>
    
    <content type="html"><![CDATA[<p>中心极限定理是统计学里最重要的定理，可能没有之一。</p><p>按照中心极限定理，在样本量足够大的时候，任何分布的样本均值，都会接近正态分布。</p><p>不管原先的分布是二项分布、泊松分布或任何千奇百怪的分布，如果我们对这个分布做抽样，只要样本量够大，作为随机变量的样本均值会呈现正态分布。</p><p>下图是个形象的说明：</p><p><img src="/blog/2020/01/22/simu-clt-1/clt.png" class="" title="clt"></p><p>这个定理在数学上有严谨的证明。数学证明太抽象，我们可以用 simulation 更好地展示这个定理。</p><p><a id="more"></a></p><h2 id="样本数量与均值的分布"><a href="#样本数量与均值的分布" class="headerlink" title="样本数量与均值的分布"></a>样本数量与均值的分布</h2><p>根据中心极限定理，样本均值在样本量足够大时符合正态分布，且该正态分布的均值是：</p><p><img src="/blog/2020/01/22/simu-clt-1/mean_of_sample_mean_dist.png" class="" title="mean_of_sample_dist"></p><p>另外，样本均值的正态分布的标准差是：</p><p><img src="/blog/2020/01/22/simu-clt-1/se_of_sample_mean_dist.png" class="" title="sd_of_sample_dist"></p><p>所以，随着样本逐渐增大，我们应该能观察到：</p><ul><li>均值的分布逐渐接近正态分布</li><li>该正态分布的标准差越来越小</li></ul><h2 id="扔骰子"><a href="#扔骰子" class="headerlink" title="扔骰子"></a>扔骰子</h2><p>扔骰子是个经典的概率现象。从1到6，概率都是1/6。这个分布的数学期望是3.5（有兴趣的小伙伴可以手动算算）。</p><p>如果投1次骰子，相当于抽取一个样本，虽然数学期望仍然是3.5，但我们只会观察到有1/6的概率落在1到6中任意一个数字上。我们重复10000次抽样，并记录每次的均值（其实就是投到的数字，因为只有1次），应该会看到1到6的数字都占1/6。</p><p>如果投10次骰子，相当于抽取10个样本，均值会相对集中。我们重复10000次抽样，并记录每次的均值，应该会看到均值相对之前集中。</p><p>如果投100次骰子，相当于抽取100个样本，均值会非常接近3.5.我们重复10000次抽样，并记录每次的均值，按照中心极限定理，均值的分布会是个方差很小的正态分布。</p><p>在现实生活里，如果模拟10000次抽样，且每次抽样要投100次骰子，我们一共要投个100万次骰子。实在不可能。好在现在有了计算机，我们可以让计算机模拟投掷骰子的过程。</p><h2 id="R-代码"><a href="#R-代码" class="headerlink" title="R 代码"></a>R 代码</h2><p>用 R 语言模拟投掷结果并做图。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(tidyverse)</span><br><span class="line"><span class="keyword">library</span>(ggpubr)</span><br><span class="line"></span><br><span class="line">set.seed(<span class="number">123</span>)</span><br></pre></td></tr></tbody></table></figure><p>使用 tidyverse 包，主要是为了使用 dplyr 和 ggplot2。<br>ggpubr 包是为了合并图片。<br>为了保证分析的可重复性，需要先设定一个随机数种子，这样能保证每次“随机”的结果是一样的。</p><h3 id="函数：掷骰子"><a href="#函数：掷骰子" class="headerlink" title="函数：掷骰子"></a>函数：掷骰子</h3><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">simu_dice_mean &lt;- <span class="keyword">function</span>(size) {</span><br><span class="line">  dice_vec &lt;- <span class="number">1</span>:<span class="number">6</span></span><br><span class="line">  sample_mean &lt;- sum(sample(dice_vec, size, replace = <span class="literal">T</span>)) / size</span><br><span class="line">  sample_mean</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>simu_dice_mean</code> 函数模拟了掷骰子后计算均值的过程，我给了一个参数<code>size</code>，表示掷骰子的次数。这里会返回本次投掷的均值。</p><h3 id="函数：重复实验-n-次"><a href="#函数：重复实验-n-次" class="headerlink" title="函数：重复实验 n 次"></a>函数：重复实验 n 次</h3><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">simulate_df &lt;- <span class="keyword">function</span>(size, n) {</span><br><span class="line">  df_mean &lt;- data.frame(sample_mean = rep(<span class="number">0</span>, n))</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:n) {</span><br><span class="line">    df_mean[i, <span class="number">1</span>] &lt;- simu_dice_mean(size)</span><br><span class="line">  }</span><br><span class="line">  df_mean</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>simulate_df</code> 重复了 n 次 <code>simu_dice_mean</code>，生成一个 data frame，包含 n 个均值。<br>如果需要经常做模拟，这一步代码可以大大优化。不过我只模拟这一次，所以用了最直接的 for loop。</p><h3 id="函数：做图"><a href="#函数：做图" class="headerlink" title="函数：做图"></a>函数：做图</h3><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">draw_plot &lt;- <span class="keyword">function</span>(df, size, bin_width) {</span><br><span class="line">  stan_dev &lt;- round(sd(df$sample_mean), <span class="number">2</span>)</span><br><span class="line">  ggplot(df, aes(x = sample_mean)) + </span><br><span class="line">    geom_histogram(binwidth = bin_width) +</span><br><span class="line">    scale_x_continuous(limits = c(<span class="number">0.5</span>, <span class="number">6.5</span>)) + </span><br><span class="line">    labs(title = str_c(<span class="string">'投掷骰子'</span>, size, <span class="string">'次'</span>),</span><br><span class="line">         subtitle = str_c(<span class="string">'点估计标准差 = '</span>, stan_dev),</span><br><span class="line">         x = <span class="string">'均值'</span>,</span><br><span class="line">         y = <span class="string">'频数'</span>) </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>前一步返回了均值的 data frame，我们可以用其画出直方图，展示分布情况。<br>同时我在这一步计算了这组分布的标准差。</p><h3 id="函数：汇总"><a href="#函数：汇总" class="headerlink" title="函数：汇总"></a>函数：汇总</h3><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">simulate_and_draw &lt;- <span class="keyword">function</span>(size, n = <span class="number">10000</span>, bin_width) {</span><br><span class="line">  simulate_df(size, n) %&gt;%</span><br><span class="line">    draw_plot(size, bin_width)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>把 <code>simulate_df</code> 和 <code>draw_plot</code> 两个函数结合，生成一个新的函数<code>simulate_and_draw</code>。<br>准备工作结束。</p><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>我们依次计算并画出掷骰子1次、5次、10次、20次、50次和100次的模拟结果（模拟10000次实验）：</p><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p1 &lt;- simulate_and_draw(size = <span class="number">1</span>, bin_width = <span class="number">0.2</span>)</span><br><span class="line">p2 &lt;-  simulate_and_draw(size = <span class="number">5</span>, bin_width = <span class="number">0.2</span>)</span><br><span class="line">p3 &lt;- simulate_and_draw(size = <span class="number">10</span>,  bin_width = <span class="number">0.2</span>)</span><br><span class="line">p4 &lt;- simulate_and_draw(size = <span class="number">20</span>,  bin_width = <span class="number">0.15</span>)</span><br><span class="line">p5 &lt;- simulate_and_draw(size = <span class="number">50</span>,  bin_width = <span class="number">0.1</span>)</span><br><span class="line">p6 &lt;- simulate_and_draw(size = <span class="number">200</span>,  bin_width = <span class="number">0.03</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合6个图片</span></span><br><span class="line">ggarrange(p1, p2, p3, p4, p5, p6,</span><br><span class="line">          nrow = <span class="number">3</span>, ncol = <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="模拟结果"><a href="#模拟结果" class="headerlink" title="模拟结果"></a>模拟结果</h2><p>如下图：</p><p><img src="/blog/2020/01/22/simu-clt-1/plot_all.png" class="" title="plot_all"></p><p>可以清晰地看到：</p><ul><li>分布的均值越来越集中在3.5</li><li>分布的标准差越来越小</li></ul><p>类似的模拟，不只是掷骰子所属的离散均匀分布能做，其他分布也能做。如果我是老师，就会在这里布置一门作业：在总体分布符合泊松分布的情形下模拟中心极限定理。</p><p>以上就是中心极限定理的直观展示了。有了中心极限定理，对均值做统计推断才成为可能。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中心极限定理是统计学里最重要的定理，可能没有之一。&lt;/p&gt;
&lt;p&gt;按照中心极限定理，在样本量足够大的时候，任何分布的样本均值，都会接近正态分布。&lt;/p&gt;
&lt;p&gt;不管原先的分布是二项分布、泊松分布或任何千奇百怪的分布，如果我们对这个分布做抽样，只要样本量够大，作为随机变量的样本均值会呈现正态分布。&lt;/p&gt;
&lt;p&gt;下图是个形象的说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/01/22/simu-clt-1/clt.png&quot; class=&quot;&quot; title=&quot;clt&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个定理在数学上有严谨的证明。数学证明太抽象，我们可以用 simulation 更好地展示这个定理。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计理论" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>ggplot 系列之：ggTimeSeries</title>
    <link href="http://yoursite.com/2020/01/21/gg-daily-heatmap/"/>
    <id>http://yoursite.com/2020/01/21/gg-daily-heatmap/</id>
    <published>2020-01-21T22:33:41.000Z</published>
    <updated>2020-01-22T19:42:39.779Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/21/gg-daily-heatmap/daily_heatmap.png" class="" title="heatmap"><p>今天看到一个有趣的 R pakcage：<a href="https://github.com/AtherEnergy/ggTimeSeries" target="_blank" rel="noopener">ggTimeSeries</a> 能够对时间序列数据做出有趣的图片。</p><p><a id="more"></a></p><h2 id="日期热点图"><a href="#日期热点图" class="headerlink" title="日期热点图"></a>日期热点图</h2><p>我最喜欢的是下面这个日期热点图，它能够展示连续变量在一年里每天的数据情况，月份在 x 轴，工作日在 y 轴，数据大小用填充色表示。</p><p>我随便找了个每日温度数据，做出了最上面那个图，做图代码如下：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本图</span></span><br><span class="line">p0 &lt;- df %&gt;%</span><br><span class="line">  ggplot_calendar_heatmap(<span class="string">'date'</span>,<span class="string">'meantemp'</span>, dayBorderColour = <span class="string">'#cccccc'</span>, monthBorderColour = <span class="string">'#777777'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加工</span></span><br><span class="line">p0 +</span><br><span class="line">  scale_fill_continuous(low = <span class="string">'green'</span>, high = <span class="string">'red'</span>) + </span><br><span class="line">  facet_wrap(~Year, ncol = <span class="number">1</span>) +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>,</span><br><span class="line">       y = <span class="literal">NULL</span>,</span><br><span class="line">       fill = <span class="literal">NULL</span>,</span><br><span class="line">       title = <span class="string">'每日平均气温'</span>) +</span><br><span class="line">  theme_minimal() +</span><br><span class="line">  theme(text=element_text(family=<span class="string">"Songti TC Regular"</span>)) </span><br></pre></td></tr></tbody></table></figure><p>这个展示方式很适合用来展示有工作日趋势和季度趋势的时间序列数据，比如每日销售、网站访问量。</p><p>寒假和暑假经常是游戏流量的高峰，这个信息就能在这个图片上一目了然。</p><p>工作日的游戏流量低于周末，也很适合在这个图表上展示。</p><h2 id="waterfall-图"><a href="#waterfall-图" class="headerlink" title="waterfall 图"></a>waterfall 图</h2><p>这个 package 里还有一个我喜欢的图，waterfall 图：</p><img src="/blog/2020/01/21/gg-daily-heatmap/gg_waterfall.png" class="" title="heatmap"><p>Waterfall 图用箭头标注了数据的每日变化，展示每天都有波动的数据很合适，比如股票价格等。</p><p>上图的做图代码：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本图</span></span><br><span class="line">df %&gt;%</span><br><span class="line">  ggplot_waterfall(<span class="string">'date'</span>,<span class="string">'meantemp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加工</span></span><br><span class="line">p0 +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>,</span><br><span class="line">       y = <span class="literal">NULL</span>,</span><br><span class="line">       color = <span class="string">'变化'</span>,</span><br><span class="line">       title = <span class="string">'每日平均气温'</span>) +</span><br><span class="line">  theme_classic(<span class="number">16</span>) +</span><br><span class="line">  theme(text=element_text(family=<span class="string">"Songti TC Regular"</span>),</span><br><span class="line">        plot.title = element_text(hjust = <span class="number">0.5</span>)) </span><br><span class="line"></span><br><span class="line">  theme(text=element_text(family=<span class="string">"Songti TC Regular"</span>)) </span><br></pre></td></tr></tbody></table></figure><p>这个 package 里还有其他几个可视化方法，个人觉得不太实用，有兴趣的同学可以去看看。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/21/gg-daily-heatmap/daily_heatmap.png&quot; class=&quot;&quot; title=&quot;heatmap&quot;&gt;
&lt;p&gt;今天看到一个有趣的 R pakcage：&lt;a href=&quot;https://github.com/AtherEnergy/ggTimeSeries&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ggTimeSeries&lt;/a&gt; 能够对时间序列数据做出有趣的图片。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>ggplot 系列之：别用漏斗图</title>
    <link href="http://yoursite.com/2020/01/21/gg-funnel/"/>
    <id>http://yoursite.com/2020/01/21/gg-funnel/</id>
    <published>2020-01-21T22:33:24.000Z</published>
    <updated>2020-01-22T19:42:39.779Z</updated>
    
    <content type="html"><![CDATA[<p>分析用户的转化路径时，经常需要使用漏斗图。但是，漏斗图并不是多好的数据可视化方案。</p><p>漏斗图的问题跟饼图有点相似：用面积表示数量多少，而人类视觉对面积的敏感度不够。</p><p>下面这张图是我从网上找到的漏斗图，我会用同样的数据做一个<strong>柱状图</strong>版本。</p><img src="/blog/2020/01/21/gg-funnel/funnel.png" class="" title="funnel"><p><a id="more"></a></p><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>原图展示了销售的四个步骤各自有多少人。</p><p>我们先准备一份数据：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(</span><br><span class="line">  stage = c(<span class="string">'Prospects'</span>, <span class="string">'Price Quotes'</span>, <span class="string">'Negotiations'</span>, <span class="string">'Closed Sales'</span>),</span><br><span class="line">  people = c(<span class="number">12000</span>, <span class="number">6800</span>, <span class="number">3000</span>, <span class="number">850</span>)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><h2 id="做图"><a href="#做图" class="headerlink" title="做图"></a>做图</h2><p>漏斗图有个值得借鉴的设计思路：从上到下展示数据的阶段性变化。我们想在柱状图上借用这个设计。</p><h3 id="基本版"><a href="#基本版" class="headerlink" title="基本版"></a>基本版</h3><p>先画一个基本版</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ggplot(df, aes(x = stage, y = people)) + </span><br><span class="line">  geom_bar(stat = <span class="string">'identity'</span>, width = <span class="number">0.7</span>) +</span><br><span class="line">  geom_text(aes(label = people), hjust= -<span class="number">0.1</span>) +</span><br><span class="line">  scale_y_continuous(limits = c(<span class="number">0</span>, <span class="number">13000</span>)) +</span><br><span class="line">  labs(title = <span class="string">'销售漏斗图'</span>,</span><br><span class="line">       y = <span class="string">'人数'</span>,</span><br><span class="line">       x= <span class="literal">NULL</span>) +</span><br><span class="line">  coord_flip() +</span><br><span class="line">  theme_classic(<span class="number">16</span>) </span><br></pre></td></tr></tbody></table></figure><p>几个要点：</p><ul><li>使用 <code>coord_flip</code> 可以把柱状图变成横向</li><li>使用<code>geom_text</code>标注人数</li><li>使用<code>theme_classic</code> 主题，减少画面中的元素。</li></ul><p>结果如图：</p><img src="/blog/2020/01/21/gg-funnel/plot_bar_1.png" class="" title="bar_1"><h3 id="加入百分比"><a href="#加入百分比" class="headerlink" title="加入百分比"></a>加入百分比</h3><p>有的漏斗图会显示每个步骤还剩下多少比例的人数。我也想借用这个思路。</p><p>先加工数据：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_2 &lt;- df %&gt;%</span><br><span class="line">  mutate(pct = str_c(round(people / max(people) * <span class="number">100</span>), <span class="string">'%'</span>))</span><br></pre></td></tr></tbody></table></figure><p>我新建了一列，计算各个阶段相对于最开始人数的百分比。</p><p>然后做图：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ggplot(df_2, aes(x = stage, y = people)) + </span><br><span class="line">  geom_bar(stat = <span class="string">'identity'</span>, width = <span class="number">0.7</span>) +</span><br><span class="line">  geom_text(aes(label = people), hjust= <span class="number">1.1</span>, color = <span class="string">'white'</span>) +</span><br><span class="line">  geom_text(aes(y = max(people) * <span class="number">1.05</span>, label = pct), hjust= <span class="number">0</span>) +</span><br><span class="line">  scale_y_continuous(limits = c(<span class="number">0</span>, <span class="number">13000</span>)) +</span><br><span class="line">  labs(title = <span class="string">'销售漏斗图'</span>,</span><br><span class="line">       y = <span class="string">'人数'</span>,</span><br><span class="line">       x= <span class="literal">NULL</span>) +</span><br><span class="line">  coord_flip() +</span><br><span class="line">  theme_classic(<span class="number">16</span>)</span><br></pre></td></tr></tbody></table></figure><p>跟之前相比有两个变化：</p><ul><li>人数移到柱子内部，调整为白色</li><li>新增一个 <code>geom_text</code>，用于展示百分比</li></ul><p>结果如下：</p><img src="/blog/2020/01/21/gg-funnel/plot_bar_2.png" class="" title="bar_2"><h3 id="视觉调整"><a href="#视觉调整" class="headerlink" title="视觉调整"></a>视觉调整</h3><p>仔细看漏斗图，我发现漏斗图还有一个好处：图片内的元素很少，让人感觉舒服。</p><p>参考漏斗图，我们修改自己的柱状图设计。</p><p>代码：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># p1 是上一个图片</span></span><br><span class="line">p1 + theme(axis.title.x=element_blank(),</span><br><span class="line">           axis.text.x=element_blank(),</span><br><span class="line">           axis.ticks =element_blank(),</span><br><span class="line">           axis.line = element_blank(),</span><br><span class="line">           plot.title = element_text(hjust = <span class="number">0.3</span>)) +</span><br><span class="line">  scale_y_continuous(limits = c(<span class="number">0</span>, <span class="number">14500</span>), expand = c(<span class="number">0</span>,<span class="number">0</span>))</span><br></pre></td></tr></tbody></table></figure><p>要点：</p><ul><li>隐藏 x 轴和 y 轴的线、刻度</li><li>图片的标题相对居中</li><li>减少柱子和 y 轴之间的 padding</li></ul><p>结果如下：</p><img src="/blog/2020/01/21/gg-funnel/plot_bar_3.png" class="" title="bar_3"><p>能够修改的地方还有很多，比如柱子是不是太短太粗，颜色是不是可以优化，百分比的展示是不是可以更明确。这里就不再细究了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://peltiertech.com/bad-graphics-funnel-chart/" target="_blank" rel="noopener">Bad Graphics – Funnel Chart</a></li><li><a href="https://crmchartguy.com/2015/10/26/funnel-charts-in-dynamics-crm/" target="_blank" rel="noopener">Funnel Charts Suck and You Shouldn’t Use Them</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析用户的转化路径时，经常需要使用漏斗图。但是，漏斗图并不是多好的数据可视化方案。&lt;/p&gt;
&lt;p&gt;漏斗图的问题跟饼图有点相似：用面积表示数量多少，而人类视觉对面积的敏感度不够。&lt;/p&gt;
&lt;p&gt;下面这张图是我从网上找到的漏斗图，我会用同样的数据做一个&lt;strong&gt;柱状图&lt;/strong&gt;版本。&lt;/p&gt;
&lt;img src=&quot;/blog/2020/01/21/gg-funnel/funnel.png&quot; class=&quot;&quot; title=&quot;funnel&quot;&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>ggplot系列之：theme</title>
    <link href="http://yoursite.com/2020/01/21/ggplot-theme/"/>
    <id>http://yoursite.com/2020/01/21/ggplot-theme/</id>
    <published>2020-01-21T14:21:31.000Z</published>
    <updated>2020-01-22T19:42:39.783Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/21/ggplot-theme/plot_all.png" class="" title="带数字的柱状图"><p>$\alpha$</p><p>人靠衣装，图靠 theme 装。好看的数据可视化，会一眼抓住人眼球，让你的报告更有说服力。</p><p>ggplot 生态提供了丰富的 theme 选择，如果你对已有的 theme 不满意，还可以自己创造 theme。</p><p>这篇文章介绍几个不错的 theme。</p><p><a id="more"></a></p><h2 id="数据和图片"><a href="#数据和图片" class="headerlink" title="数据和图片"></a>数据和图片</h2><p>先用 <a href="https://www.rdocumentation.org/packages/gapminder/versions/0.3.0" target="_blank" rel="noopener">Gapminder 数据</a>做一个基础图。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- gapminder %&gt;%</span><br><span class="line">  filter(year == <span class="number">2007</span>)</span><br></pre></td></tr></tbody></table></figure><p>Gapminder 里有1950年代到2007年各国的预期寿命、人口、人均 GDP 等数据。</p><p>我们只看2007年的样本，前几列数据如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">country</th><th style="text-align:center">continent</th><th style="text-align:center">year</th><th style="text-align:center">lifeExp</th><th style="text-align:center">pop</th><th style="text-align:center">gdpPercap</th></tr></thead><tbody><tr><td style="text-align:center">Afghanistan</td><td style="text-align:center">Asia</td><td style="text-align:center">2007</td><td style="text-align:center">43.828</td><td style="text-align:center">31889923</td><td style="text-align:center">974.5803</td></tr><tr><td style="text-align:center">Albania</td><td style="text-align:center">Europe</td><td style="text-align:center">2007</td><td style="text-align:center">76.423</td><td style="text-align:center">3600523</td><td style="text-align:center">5937.0295</td></tr><tr><td style="text-align:center">Algeria</td><td style="text-align:center">Africa</td><td style="text-align:center">2007</td><td style="text-align:center">72.301</td><td style="text-align:center">33333216</td><td style="text-align:center">6223.3675</td></tr><tr><td style="text-align:center">Angola</td><td style="text-align:center">Africa</td><td style="text-align:center">2007</td><td style="text-align:center">42.731</td><td style="text-align:center">12420476</td><td style="text-align:center">4797.2313</td></tr><tr><td style="text-align:center">Argentina</td><td style="text-align:center">Americas</td><td style="text-align:center">2007</td><td style="text-align:center">75.320</td><td style="text-align:center">40301927</td><td style="text-align:center">12779.3796</td></tr><tr><td style="text-align:center">Australia</td><td style="text-align:center">Oceania</td><td style="text-align:center">2007</td><td style="text-align:center">81.235</td><td style="text-align:center">20434176</td><td style="text-align:center">34435.3674</td></tr></tbody></table></div><p>我比较感兴趣的是人均 GDP 和预期寿命的相关性。所以，我会画一个人均 GDP 和预期寿命的散点图。除此之外，这里还有人口数据和国家所属的大洲，为了展示更多信息，我们可以用点的大小表示人口，用颜色表示所属的大洲。</p><p>做图代码如下：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p0 &lt;- ggplot(data = df, </span><br><span class="line">             aes(x = gdpPercap, </span><br><span class="line">                 y = lifeExp, </span><br><span class="line">                 size = pop,</span><br><span class="line">                 color = continent)) + </span><br><span class="line">  geom_point() +</span><br><span class="line">  scale_x_continuous(trans = <span class="string">'log'</span>,</span><br><span class="line">                     labels = round) +</span><br><span class="line">  labs(title = <span class="string">'人均gdp vs. 预期寿命'</span>,</span><br><span class="line">       x = <span class="string">'log(人均 GDP)'</span>,</span><br><span class="line">       y = <span class="string">'预期寿命'</span>,</span><br><span class="line">       color = <span class="string">'大洲'</span>,</span><br><span class="line">       size = <span class="string">'人口'</span>,</span><br><span class="line">       caption = <span class="string">"数据来源: gapminder"</span>)</span><br></pre></td></tr></tbody></table></figure><p>我怀疑人均 GDP 用 log 形式更能展示线性关系，所以这里对人均 GDP 数据做 log 处理。</p><h2 id="ggplot-的内置-theme"><a href="#ggplot-的内置-theme" class="headerlink" title="ggplot 的内置 theme"></a>ggplot 的内置 theme</h2><p>ggplot 内置了至少8个 theme，我选出了几个自己比较喜欢的。</p><h3 id="默认-theme-gray"><a href="#默认-theme-gray" class="headerlink" title="默认: theme gray"></a>默认: theme gray</h3><p>ggplot 的默认 theme 是 theme_gray：</p><img src="/blog/2020/01/21/ggplot-theme/plot_1.png" class="" title="theme_gray"><p>这个 theme 已经可以应付大部分场合了。</p><h3 id="theme-dark"><a href="#theme-dark" class="headerlink" title="theme dark"></a>theme dark</h3><p>既然有 gray，当然就有 dark。theme_dark 会把底色变黑，适用于在黑暗的环境做报告。</p><img src="/blog/2020/01/21/ggplot-theme/plot_2.png" class="" title="theme_dark"><h3 id="theme-minimal"><a href="#theme-minimal" class="headerlink" title="theme minimal"></a>theme minimal</h3><p>theme_minimal 是一个贯彻简单原则的 theme。</p><img src="/blog/2020/01/21/ggplot-theme/plot_3.png" class="" title="theme_minimal"><h3 id="theme-classic"><a href="#theme-classic" class="headerlink" title="theme classic"></a>theme classic</h3><p>theme_classic 是我的最爱，这应该是数据可视化最经典的主题。</p><img src="/blog/2020/01/21/ggplot-theme/plot_4.png" class="" title="theme_classic"><h2 id="package：ggthemes"><a href="#package：ggthemes" class="headerlink" title="package：ggthemes"></a>package：ggthemes</h2><p>ggthemes 是一个包含了十数个主题的 package，这里介绍其中的几个。</p><h3 id="theme-few"><a href="#theme-few" class="headerlink" title="theme few"></a>theme few</h3><p><code>theme_few</code> 也是个简单原则的主题。</p><img src="/blog/2020/01/21/ggplot-theme/plot_5.png" class="" title="theme_few"><h3 id="theme-economist"><a href="#theme-economist" class="headerlink" title="theme economist"></a>theme economist</h3><p><code>theme_economist</code> 是个参考《经济学人》风格设计的主题。</p><img src="/blog/2020/01/21/ggplot-theme/plot_6.png" class="" title="theme_economist"><h3 id="theme-gdocs"><a href="#theme-gdocs" class="headerlink" title="theme gdocs"></a>theme gdocs</h3><p><code>theme_gdocs</code> 是个参考 google docs 风格设计的主题。</p><img src="/blog/2020/01/21/ggplot-theme/plot_7.png" class="" title="theme_gdocs"><h3 id="theme-538"><a href="#theme-538" class="headerlink" title="theme 538"></a>theme 538</h3><p><code>theme_fivethirtyeight</code> 是个参考数据网站 <a href="https://fivethirtyeight.com/" target="_blank" rel="noopener">fivethirtyeight</a> 设计的主题。</p><img src="/blog/2020/01/21/ggplot-theme/plot_8.png" class="" title="theme_fivethirtyeight"><h3 id="theme-excel"><a href="#theme-excel" class="headerlink" title="theme_excel"></a>theme_excel</h3><p>package 作者出于搞笑目的做了一个经典 excel 主题。</p><img src="/blog/2020/01/21/ggplot-theme/plot_9.png" class="" title="theme_excel"><p>作者在 <a href="https://cran.r-project.org/web/packages/ggthemes/ggthemes.pdf" target="_blank" rel="noopener">ggthemes 的文档</a>里写道：</p><blockquote><p>Theme to replicate the ugly monstrosity that was the old gray-background Excel chart. Please never<br>use this. </p></blockquote><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61b.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61b.png?v8">😛</span></p><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>如果想要微调某个主题，需要用到 ggplot 的 <code>theme</code> 方法。</p><p>比如我们想修改默认主题：</p><ul><li>标题和副标题剧中</li><li>标题改为红色、加粗</li><li>副标题改为深绿色p</li></ul><p>我们可以这样做：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># p1 是最开始画的图</span></span><br><span class="line">p1 + theme(plot.title = element_text(color = <span class="string">'red'</span>,  hjust = <span class="number">0.5</span>, size = <span class="number">20</span>),</span><br><span class="line">           plot.subtitle = element_text(color = <span class="string">'darkgreen'</span>, hjust = <span class="number">0.5</span>))</span><br></pre></td></tr></tbody></table></figure><p>结果如下：</p><img src="/blog/2020/01/21/ggplot-theme/plot_10.png" class="" title="theme_edit"><p>这只是个说明性的例子，ggplot 提供了非常丰富的图片修改可能，图片上的任何“元素”都可以使用某个命令修改。</p><h2 id="bonus-theme-xkcd"><a href="#bonus-theme-xkcd" class="headerlink" title="bonus: theme_xkcd"></a>bonus: theme_xkcd</h2><p>最近刷到一个有意思的主题：xkcd。需要安装 package xkcd。<br>这是个卡通风格的主题，需要字体 xkcd，不支持中文。</p><p>用 <code>theme_xkcd()</code> 做图如下：</p><img src="/blog/2020/01/21/ggplot-theme/plot_xkcd.png" class="" title="theme_xkcd"><p>太可爱了 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8">😆</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/21/ggplot-theme/plot_all.png&quot; class=&quot;&quot; title=&quot;带数字的柱状图&quot;&gt;
&lt;p&gt;$\alpha$&lt;/p&gt;
&lt;p&gt;人靠衣装，图靠 theme 装。好看的数据可视化，会一眼抓住人眼球，让你的报告更有说服力。&lt;/p&gt;
&lt;p&gt;ggplot 生态提供了丰富的 theme 选择，如果你对已有的 theme 不满意，还可以自己创造 theme。&lt;/p&gt;
&lt;p&gt;这篇文章介绍几个不错的 theme。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>ggplot 系列之：折线图</title>
    <link href="http://yoursite.com/2020/01/21/ggplot-line/"/>
    <id>http://yoursite.com/2020/01/21/ggplot-line/</id>
    <published>2020-01-21T12:35:36.000Z</published>
    <updated>2020-01-22T19:42:39.783Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/21/ggplot-line/plot_example.png" class="" title="折线图"><p>折线图，经常用来展示时间序列数据。</p><p><a id="more"></a></p><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>这里使用 R 自带的 <a href="https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/UKLungDeaths.html" target="_blank" rel="noopener">UKLungDeaths</a> 数据，记录了英国1974到1979年每个月因为肺病死亡的人数。</p><p>源数据是 ts 格式，需要现转换成 ggplot 需要的 data.frame 格式，使用 <a href="https://cran.r-project.org/web/packages/tsbox/vignettes/tsbox.html" target="_blank" rel="noopener">tsbox 包</a>。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于基础做图</span></span><br><span class="line">df &lt;- ts_df(ts_c(ldeaths))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于分组做图</span></span><br><span class="line">df_2 &lt;- ts_df(ts_c(fdeaths, mdeaths))</span><br><span class="line">names(df_2)[<span class="number">1</span>] &lt;- <span class="string">'gender'</span></span><br><span class="line">df_2 &lt;- df_2 %&gt;%</span><br><span class="line">  mutate(gender = ifelse(gender == <span class="string">'fdeaths'</span>, <span class="string">'female'</span>, <span class="string">'male'</span>))</span><br></pre></td></tr></tbody></table></figure><p>这里准备了两个 data.frame。第一个 df 是每月因为肺病死亡的总人数，第二个 df 是分性别的死亡人数。</p><p>第1组数据的前几行:</p><div class="table-container"><table><thead><tr><th style="text-align:center">time</th><th style="text-align:center">value</th></tr></thead><tbody><tr><td style="text-align:center">1974-01-01</td><td style="text-align:center">3035</td></tr><tr><td style="text-align:center">1974-02-01</td><td style="text-align:center">2552</td></tr><tr><td style="text-align:center">1974-03-01</td><td style="text-align:center">2704</td></tr><tr><td style="text-align:center">1974-04-01</td><td style="text-align:center">2554</td></tr><tr><td style="text-align:center">1974-05-01</td><td style="text-align:center">2014</td></tr><tr><td style="text-align:center">1974-06-01</td><td style="text-align:center">1655</td></tr></tbody></table></div><p>第2组数据的前几行：</p><div class="table-container"><table><thead><tr><th style="text-align:center">time</th><th style="text-align:center">value</th><th style="text-align:center">gender</th></tr></thead><tbody><tr><td style="text-align:center">1974-01-01</td><td style="text-align:center">901</td><td style="text-align:center">female</td></tr><tr><td style="text-align:center">1974-02-01</td><td style="text-align:center">689</td><td style="text-align:center">female</td></tr><tr><td style="text-align:center">1974-03-01</td><td style="text-align:center">827</td><td style="text-align:center">female</td></tr><tr><td style="text-align:center">1974-04-01</td><td style="text-align:center">677</td><td style="text-align:center">female</td></tr><tr><td style="text-align:center">1974-05-01</td><td style="text-align:center">522</td><td style="text-align:center">female</td></tr><tr><td style="text-align:center">1974-06-01</td><td style="text-align:center">406</td><td style="text-align:center">female</td></tr></tbody></table></div><p>第2组数据多了一个表示性别的变量<code>gender</code>。</p><h2 id="基本折线图"><a href="#基本折线图" class="headerlink" title="基本折线图"></a>基本折线图</h2><p>先画一个每月总死亡人数的图：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df %&gt;%</span><br><span class="line">  ggplot(aes(x = time, y = value)) + </span><br><span class="line">  geom_line() +</span><br><span class="line">  scale_x_date(date_breaks = <span class="string">'2 years'</span>,</span><br><span class="line">               date_labels = <span class="string">"%Y-%m"</span>) +</span><br><span class="line">  labs(title = <span class="string">'1974-1979年英国死于肺病的人数/每月'</span>,</span><br><span class="line">       x = <span class="string">'月份'</span>,</span><br><span class="line">       y = <span class="string">'死亡人数'</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>geom_line</code> 是画折线图的函数。</p><p>这里还出现了一个常用的方法<code>scale_x_date</code>，处理时间格式时很方便。我用 <code>date_breaks = '2 years'</code> 表示 x 轴的标签每隔两年显示，然后用<code>date_labels = '%Y-%m'</code>将显示的格式设定为”xxxx年-xx月”。</p><p>做图结果如下：<br><img src="/blog/2020/01/21/ggplot-line/plot_0.png" class="" title="折线图"></p><h2 id="分组折线图"><a href="#分组折线图" class="headerlink" title="分组折线图"></a>分组折线图</h2><p>有时我们需要对不同的组别画折线：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df_2 %&gt;%</span><br><span class="line">  ggplot(aes(x = time, y = value, color = gender)) + </span><br><span class="line">  geom_line() +</span><br><span class="line">  scale_x_date(date_breaks = <span class="string">'2 years'</span>,</span><br><span class="line">               date_labels = <span class="string">"%Y-%m"</span>) +</span><br><span class="line">  labs(title = <span class="string">'1974-1979年英国死于肺病的人数/每月'</span>,</span><br><span class="line">       x = <span class="string">'月份'</span>,</span><br><span class="line">       y = <span class="string">'死亡人数'</span>,</span><br><span class="line">       color = <span class="string">'性别'</span>)</span><br></pre></td></tr></tbody></table></figure><p>这里的关键是第2行的<code>color = gender</code>。</p><p>做图结果如下：<br><img src="/blog/2020/01/21/ggplot-line/plot_1.png" class="" title="折线图"></p><h2 id="折线图-点"><a href="#折线图-点" class="headerlink" title="折线图 + 点"></a>折线图 + 点</h2><p>有时我们想要同时展示折线和点：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df_2 %&gt;%</span><br><span class="line">  ggplot(aes(x = time, y = value, color = gender)) + </span><br><span class="line">  geom_line() +</span><br><span class="line">  geom_point() + </span><br><span class="line">  scale_x_date(date_breaks = <span class="string">'2 years'</span>,</span><br><span class="line">               date_labels = <span class="string">"%Y-%m"</span>) +</span><br><span class="line">  labs(title = <span class="string">'1974-1979年英国死于肺病的人数/每月'</span>,</span><br><span class="line">       x = <span class="string">'月份'</span>,</span><br><span class="line">       y = <span class="string">'死亡人数'</span>,</span><br><span class="line">       color = <span class="string">'性别'</span>)</span><br></pre></td></tr></tbody></table></figure><p>加上 <code>geom_point</code> 即可。</p><p>做图结果如下：<br><img src="/blog/2020/01/21/ggplot-line/plot_2.png" class="" title="折线图"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/21/ggplot-line/plot_example.png&quot; class=&quot;&quot; title=&quot;折线图&quot;&gt;
&lt;p&gt;折线图，经常用来展示时间序列数据。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>ggplot系列之：柱状图</title>
    <link href="http://yoursite.com/2020/01/20/ggplot-barplot/"/>
    <id>http://yoursite.com/2020/01/20/ggplot-barplot/</id>
    <published>2020-01-20T12:25:12.000Z</published>
    <updated>2020-01-22T19:42:39.779Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/20/ggplot-barplot/plot_2.png" class="" title="带数字的柱状图"><p>柱状图，个人认为最实用的可视化图形。这里总结如何在 ggplot2 里使用柱状图。</p><p><a id="more"></a></p><h2 id="默认柱状图"><a href="#默认柱状图" class="headerlink" title="默认柱状图"></a>默认柱状图</h2><p>先生成一份简单的数据：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(</span><br><span class="line">  user_num = c(<span class="number">3000</span>, <span class="number">5000</span>, <span class="number">7000</span>),</span><br><span class="line">  version = factor(c(<span class="string">'version 1'</span>, <span class="string">'version 2'</span>, <span class="string">'version 3'</span>))</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>我们生成了某 app 不同版本下的用户数据，我们需要展示这个信息。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ggplot(data=df, aes(x=version, y = user_num)) +</span><br><span class="line">  geom_bar(stat=<span class="string">"identity"</span>, width = <span class="number">0.5</span>) +</span><br><span class="line">  labs(title = <span class="string">'各个版本的用户数量'</span>,</span><br><span class="line">       x = <span class="string">'版本'</span>,</span><br><span class="line">       y = <span class="string">'用户数'</span>)</span><br></pre></td></tr></tbody></table></figure><p>最重要的代码是第7行的<code>geom_bar</code>，其中<code>stat="identity"</code>指直接用 data.frame 里的数字作为 y 轴的值。<code>width</code> 是柱子的宽度。</p><p>结果如下：</p><img src="/blog/2020/01/20/ggplot-barplot/plot_0.png" class="" title="初级柱状图"><h2 id="进阶版：分组"><a href="#进阶版：分组" class="headerlink" title="进阶版：分组"></a>进阶版：分组</h2><p>app 的用户数据可以按照各个维度做拆分，最常用的一个维度是性别。我们把用户数拆分为不同性别。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df_2 &lt;- data.frame(</span><br><span class="line">  user_num = c(<span class="number">1600</span>, <span class="number">1400</span>, <span class="number">3000</span>, <span class="number">2000</span>, <span class="number">4000</span>, <span class="number">3000</span>),</span><br><span class="line">  version = factor(c(<span class="string">'version 1'</span>, <span class="string">'version 1'</span>, <span class="string">'version 2'</span>,  <span class="string">'version 2'</span>, <span class="string">'version 3'</span>, <span class="string">'version 3'</span>)),</span><br><span class="line">  gender = factor(c(<span class="string">'male'</span>, <span class="string">'female'</span>, <span class="string">'male'</span>, <span class="string">'female'</span>, <span class="string">'male'</span>, <span class="string">'female'</span>))</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>然后我们展示分组柱状图。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ggplot(data=df_2, aes(x=version, y = user_num, fill = gender)) +</span><br><span class="line">  geom_bar(stat=<span class="string">"identity"</span>, width = <span class="number">0.5</span>, position = <span class="string">'dodge'</span>) +</span><br><span class="line">  scale_fill_brewer(palette=<span class="string">"Set2"</span>) +</span><br><span class="line">  labs(title = <span class="string">'各个版本的用户数量'</span>,</span><br><span class="line">       x = <span class="string">'版本'</span>,</span><br><span class="line">       y = <span class="string">'用户数'</span>,</span><br><span class="line">       fill = <span class="string">'性别'</span>) </span><br></pre></td></tr></tbody></table></figure><p>我在第一行用了<code>fill = gender</code>，实现了对不同组填色。<br>然后在第二行用了<code>position = 'dodge'</code>，实现了对把不同组的柱子并排展示。如果不使用这个参数，柱子会叠加在一起展示。<br>为了替换默认颜色，我在第三行用了<code>scale_fill_brewer(palette="Set2")</code>，这里的 <code>Set2</code>是调色板名称。</p><p>结果如下：</p><img src="/blog/2020/01/20/ggplot-barplot/plot_1.png" class="" title="分组柱状图"><h2 id="在柱子上显示数量"><a href="#在柱子上显示数量" class="headerlink" title="在柱子上显示数量"></a>在柱子上显示数量</h2><p>有时为了更清晰地展示信息，我们需要在柱子上展示数字。</p><p>这时需要用到 <code>geom_text()</code>:</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ggplot(data=df_2, aes(x=version, y = user_num, fill = gender)) +</span><br><span class="line">  geom_bar(stat=<span class="string">"identity"</span>, width = <span class="number">0.8</span>, position = <span class="string">'dodge'</span>) +</span><br><span class="line">  geom_text(aes(label = user_num), position = position_dodge(<span class="number">0.8</span>), vjust = -<span class="number">0.2</span>) +</span><br><span class="line">  scale_fill_brewer(palette=<span class="string">"Set2"</span>) +</span><br><span class="line">  labs(title = <span class="string">'各个版本的用户数量'</span>,</span><br><span class="line">       x = <span class="string">'版本'</span>,</span><br><span class="line">       y = <span class="string">'用户数'</span>,</span><br><span class="line">       fill = <span class="string">'性别'</span>) </span><br></pre></td></tr></tbody></table></figure><p>第3行就是 <code>geom_text()</code> 命令，我们令文字内容等于<code>user_num</code>。</p><p>结果如下：</p><img src="/blog/2020/01/20/ggplot-barplot/plot_2.png" class="" title="带数字的柱状图"><p>更多柱状图控制，可以参考 ggplot2 的文档。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/20/ggplot-barplot/plot_2.png&quot; class=&quot;&quot; title=&quot;带数字的柱状图&quot;&gt;
&lt;p&gt;柱状图，个人认为最实用的可视化图形。这里总结如何在 ggplot2 里使用柱状图。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>ggplot 系列之：饼图</title>
    <link href="http://yoursite.com/2020/01/20/ggplot-pie-chart/"/>
    <id>http://yoursite.com/2020/01/20/ggplot-pie-chart/</id>
    <published>2020-01-20T05:20:15.000Z</published>
    <updated>2020-01-22T19:42:39.783Z</updated>
    
    <content type="html"><![CDATA[<p>说到数据可视化，就逃不了饼图。我还记得在学校里做 presentation 的时候，饼图大概是最常见的图片类型。</p><p>这篇文章介绍怎么用 ggplot 做饼图。</p><p><a id="more"></a></p><h2 id="别用饼图"><a href="#别用饼图" class="headerlink" title="别用饼图"></a>别用饼图</h2><p>其实，饼图是糟糕的数据可视化方法，<strong>别用饼图</strong>。</p><p>原因：饼图用面积表示数量的大小，但视觉对面积的感知能力很弱，使用饼图会导致较低的信息传递效率。</p><p>先看下面这个饼图：</p><img src="/blog/2020/01/20/ggplot-pie-chart/pie_1.png" class="" title="pie one"><p>上面这个图让人有至少两个困惑：</p><ul><li>第2和第4位是不是一样多呢？</li><li>第1位到底比第2位多多少呢？</li></ul><p>一个更好的可视化，是使用柱状图：</p><img src="/blog/2020/01/20/ggplot-pie-chart/bar_1.png" class="" title="bar one"><p>柱状图符合人类进化的结果：眼睛对长度的敏锐度远远高于面积。</p><h2 id="Less-is-More"><a href="#Less-is-More" class="headerlink" title="Less is More"></a>Less is More</h2><p>有的时候，我们可能想通过饼图强调某一个分类的占比最大。其实这里也可以用柱状图。</p><p>先看下图：<br><img src="/blog/2020/01/20/ggplot-pie-chart/pie_2.png" class="" title="pie two"></p><p>使用饼图已经足够给人困扰了，使用3D形式简直就是在犯罪。</p><p>看看Joey Cherdarchuk的优化成果：<br><img src="/blog/2020/01/20/ggplot-pie-chart/bar_2.png" class="" title="bar two"></p><p>清晰，简洁，美观，舒服。</p><p><a href="https://www.darkhorseanalytics.com/blog/salvaging-the-pie" target="_blank" rel="noopener">Joey Cherdarchuk 的原文</a>一步步把前面那个丑陋的饼图简化成了后面的样子，非常震撼。</p><h2 id="如何用-ggplot-做饼图"><a href="#如何用-ggplot-做饼图" class="headerlink" title="如何用 ggplot 做饼图"></a>如何用 ggplot 做饼图</h2><p>回答最开始提出的问题，如何用 ggplot 做饼图呢？答案：<strong>别做饼图，改用柱状图</strong>。</p><p>如果你真的非饼图不画，ggplot 可能不是个好工具。饼图的缺点基本已经是统计学届的共识，所以 ggplot 完全没有提供制作饼图的 <code>geom_pie</code>。</p><p>当然，ggplot 灵活的语法还是可以画出饼图的，可以先用<code>geom_bar</code>，然后做一个坐标变换<code>coord_polar</code>。具体代码可以<a href="http://www.sthda.com/english/wiki/ggplot2-pie-chart-quick-start-guide-r-software-and-data-visualization" target="_blank" rel="noopener">参考这里</a>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到数据可视化，就逃不了饼图。我还记得在学校里做 presentation 的时候，饼图大概是最常见的图片类型。&lt;/p&gt;
&lt;p&gt;这篇文章介绍怎么用 ggplot 做饼图。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>Python OOP 之 Property</title>
    <link href="http://yoursite.com/2020/01/20/python-property/"/>
    <id>http://yoursite.com/2020/01/20/python-property/</id>
    <published>2020-01-20T01:54:12.000Z</published>
    <updated>2020-01-22T19:42:39.787Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习 Python OOP 编程的一个 interface：property。</p><p>OOP 编程有两个常用的概念：getter 和 setter。Property 装饰器是 Python 实现 getter 和 setter 的方式。</p><p>这篇文章用一个例子说明如何使用 property。</p><p><a id="more"></a></p><h2 id="业务代码-v1"><a href="#业务代码-v1" class="headerlink" title="业务代码 v1"></a>业务代码 v1</h2><p>背景：初出茅庐的你，在为公司写一个记录员工信息的系统。</p><p>第1版系统里需要记录员工的姓名和收入。</p><p>员工可以用一个 class 表示，每个 instance 都包含员工的姓名和收入。</p><p>初步掌握 OOP 编程的你，很快完成了第1版代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, income)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.income = income</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'Person <span class="subst">{self.name}</span> with income <span class="subst">{self.income}</span>'</span></span><br><span class="line"></span><br><span class="line">Tom = Person(name = <span class="string">'Tom'</span>,</span><br><span class="line">             income = <span class="number">3000</span>)</span><br><span class="line">print(Tom) <span class="comment"># Person Tom with income 3000</span></span><br><span class="line">Tom.income = <span class="number">5000</span></span><br><span class="line">print(Tom.income)  <span class="comment"># 5000</span></span><br></pre></td></tr></tbody></table></figure><p>然后老板提出了一个需求：我们是社会主义国家的企业，为了体现社会主义的先进性，员工工资只能增加，不能减少，你要把这个特点写到系统里。</p><p>这个神奇的需求当然很容易实现，不需要修改 <code>Person</code> 这个对象的代码，只需要在客户端用 POST 方法修改工资时做一个条件判断，这个需求大概只需要3分钟完成。</p><p>可是，你仔细思考了老板的话，如果只是在 Restful API 上做检查，岂不只是“表面文章”，社会主义的先进性，难道不是应该体现在 object 层面吗？</p><p>于是，你决定实现一个功能：修改 income 时，如果 income 不增加，会报错。</p><h2 id="测试逻辑"><a href="#测试逻辑" class="headerlink" title="测试逻辑"></a>测试逻辑</h2><p>除了实现老板的需求外，你还有另一个追求：你希望 <code>Person</code> 对象的 API 不会改变，也就是说，新版本的 <code>Person</code> 对象会实现对低版本的兼容。</p><p>完成新的<code>Person</code>后，你要做两个测试。</p><p>第1个测试：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tom = Person(name = <span class="string">'Tom'</span>,</span><br><span class="line">             income = <span class="number">3000</span>)</span><br><span class="line">print(Tom) <span class="comment"># Person Tom with income 3000</span></span><br><span class="line">Tom.income = <span class="number">5000</span></span><br><span class="line">print(Tom.income)  <span class="comment"># 5000</span></span><br></pre></td></tr></tbody></table></figure><p>上面这段代码的运行结果，要跟第1个版本一样。</p><p>第2个测试：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tom = Person(name = <span class="string">'Tom'</span>,</span><br><span class="line">             income = <span class="number">3000</span>)</span><br><span class="line">Tom.income = <span class="number">1000</span></span><br></pre></td></tr></tbody></table></figure><p>在运行到<code>Tom.income = 1000</code>时，会报错。</p><h2 id="业务代码-v2"><a href="#业务代码-v2" class="headerlink" title="业务代码 v2"></a>业务代码 v2</h2><p>然后，你开始研究怎么实现新的需求。聪明的你很快发现，Property 是实现上述需求的好方法。</p><p>新版本代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, income)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self._income = income  <span class="comment">#第4行</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  @property  #第6行</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">income</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._income</span><br><span class="line">  </span><br><span class="line"><span class="meta">  @income.setter  #第10行</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">income</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> value &lt; self.income :</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">"收入不能减少"</span>)</span><br><span class="line">    self._income = value</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'Person <span class="subst">{self.name}</span> with incom <span class="subst">{self.income}</span>'</span></span><br></pre></td></tr></tbody></table></figure><p>我们依次查看这段代码里的新东西。</p><h3 id="第4行：self-income-income"><a href="#第4行：self-income-income" class="headerlink" title="第4行：self._income = income"></a>第4行：<code>self._income = income</code></h3><p>这里用 _ 表示 private variable。</p><p>Python 其实没有真正的 private variable。下面这段代码会正常返回 <code>_income</code>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, income)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self._income = income </span><br><span class="line"></span><br><span class="line">Tom = Person(name=<span class="string">'Tom'</span>, income = <span class="number">3000</span>)</span><br><span class="line">print(Tom._income) <span class="comment"># 打印出 3000</span></span><br></pre></td></tr></tbody></table></figure><p>使用 _ 表示 private variable，其实是一种约定俗成。Python 有非常多的约定俗成，比如 class 里的<code>self</code>，其实也可以用其他字段代替。</p><h3 id="第6行：-property"><a href="#第6行：-property" class="headerlink" title="第6行：@property"></a>第6行：<code>@property</code></h3><p><code>@property</code> 装饰器把 income 变成了一个 <strong>getter</strong>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ....省略 class 的代码</span></span><br><span class="line"></span><br><span class="line">Tom = Person(name=<span class="string">'Tom'</span>, income = <span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">print(Tom.income) <span class="comment"># 打印出 3000</span></span><br></pre></td></tr></tbody></table></figure><p>此时我们不需要使用<code>Tom._income</code>，只需要像第1版一样用<code>Tom.income</code>就能获取 <code>_income</code>的内容。</p><p>如果没有<code>@property</code>装饰器，<code>income</code>就变成了一个<strong>方法</strong>，只能用<code>Tom.income()</code>的方式调用。</p><h3 id="第10行：-income-setter"><a href="#第10行：-income-setter" class="headerlink" title="第10行：@income.setter"></a>第10行：<code>@income.setter</code></h3><p>这是 setter 装饰器，把下面的函数变成了 income 的 setter。</p><p>setter 这个名称很直观，我们会在满足条件后设置 income 的值。</p><p>在之后的函数里，我们检查了新的值是否小于原先的 income，如果不满足条件，我们就 raise 一个错误。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一顿操作后，第2版的业务代码使用 property 实现了老板的需求和 API 的兼容。非常完美。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.geeksforgeeks.org/python-property-function/" target="_blank" rel="noopener">Geeksforgeeks: Python | property() function</a></li><li><a href="https://www.programiz.com/python-programming/property" target="_blank" rel="noopener">Programiz : Python @property</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天学习 Python OOP 编程的一个 interface：property。&lt;/p&gt;
&lt;p&gt;OOP 编程有两个常用的概念：getter 和 setter。Property 装饰器是 Python 实现 getter 和 setter 的方式。&lt;/p&gt;
&lt;p&gt;这篇文章用一个例子说明如何使用 property。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://yoursite.com/categories/Coding/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>理解 JavaScript 的 this</title>
    <link href="http://yoursite.com/2020/01/19/js-this/"/>
    <id>http://yoursite.com/2020/01/19/js-this/</id>
    <published>2020-01-19T16:53:05.000Z</published>
    <updated>2020-01-22T19:42:39.783Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = {</span><br><span class="line">  name: <span class="string">'Harry Potter'</span>,</span><br><span class="line">  myMethod: <span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">myObject.myMethod() <span class="comment">// undefined</span></span><br></pre></td></tr></tbody></table></figure><p>上面这段代码为什么会返回<code>undefined</code>呢？因为万恶的<code>this</code>。</p><img src="/blog/2020/01/19/js-this/this.jpeg" class="" title="wtf is this"><p>MDN 对 <strong>this</strong> 的定义是：代码运行的环境。这句话给我的最大感觉是：what the <em>**</em> is this?</p><p>这里总结下 <strong>this</strong> 的几个用法。</p><p><a id="more"></a></p><h2 id="Default-Binding"><a href="#Default-Binding" class="headerlink" title="Default Binding"></a>Default Binding</h2><p>在 Chrome 浏览器打开 inspector 的 console，输入如下代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.count)</span><br><span class="line">}</span><br><span class="line">Func()</span><br></pre></td></tr></tbody></table></figure><p>console 会显示<code>5</code>。</p><p>因为我们的代码在环境下运行，this 默认绑定到了全局环境。</p><p>在<code>use strict</code>模式下，默认绑定不会发生。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="string">`use strict`</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.count)</span><br><span class="line">}</span><br><span class="line">Func()</span><br></pre></td></tr></tbody></table></figure><p>此时 Chrome 会报错。</p><h2 id="Implicit-Binding"><a href="#Implicit-Binding" class="headerlink" title="Implicit Binding"></a>Implicit Binding</h2><p>在 object 里创建函数时，运行函数时的<code>this</code>就是这个对象。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anObj = {</span><br><span class="line">  name: <span class="string">'Harry Potter'</span>,</span><br><span class="line">  callName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">anObj.callName()</span><br></pre></td></tr></tbody></table></figure><p>此时屏幕会打印 Harry Potter。</p><h2 id="Explicit-Binding"><a href="#Explicit-Binding" class="headerlink" title="Explicit Binding"></a>Explicit Binding</h2><p>如果不想在 object 创建函数，我们可以手动把函数的<code>this</code>绑定到对象上。</p><p>可以使用<code>bind</code>、<code>call</code>或<code>apply</code>。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anObj = {</span><br><span class="line">  name: <span class="string">'Harry Potter'</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">callName.call(anObj) <span class="comment">// Harry Potter</span></span><br><span class="line">callName.apply(anObj) <span class="comment">// Harry Potter</span></span><br><span class="line"></span><br><span class="line">newCallname = callName.bind(anObj)</span><br><span class="line">newCallname() <span class="comment">// Harry Potte</span></span><br></pre></td></tr></tbody></table></figure><p><code>call</code> 和 <code>apply</code> 可以直接以 object 作为 argument。<br><code>bind</code> 需要指向一个新的变量。</p><h2 id="new-Binding"><a href="#new-Binding" class="headerlink" title="new Binding"></a><code>new</code> Binding</h2><p>创建 class 的 instance 时，<code>this</code> 会指向这个 instance</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>{</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) {</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  showCoord() {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">p1.showCoord()  <span class="comment">// 1, 2</span></span><br><span class="line"></span><br><span class="line">p2 = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">p2.showCoord()  <span class="comment">// 3, 4</span></span><br></pre></td></tr></tbody></table></figure><p>每个 instance 都会有自己的 context。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数的<code>this</code>跟普通函数不一样，箭头函数会继承 parent scope 的<code>this</code>。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Ron Weasley'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObject = {</span><br><span class="line">  name: <span class="string">'Harry Potter'</span>,</span><br><span class="line">  myMethod: <span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">myObject.myMethod() <span class="comment">// Ron Weasley</span></span><br></pre></td></tr></tbody></table></figure><p>在上面这段代码里，我们用箭头函数定义了 myMethod，结果屏幕打印的是 global context 里的 <code>name</code>，因为 <code>myObject</code> 位于 global context。</p><p>如果是在<code>use strict</code>下，上面这段代码会打印<code>undifined</code>。</p><p>所以，谨慎在箭头函数里使用<code>this</code>，非常容易出错啊。</p><p>既然不能使用箭头函数，上面这段的代码要怎么写才更简洁呢？用 ES6 的函数写写法：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = {</span><br><span class="line">  name: <span class="string">'Harry Potter'</span>,</span><br><span class="line">  myMethod() {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">myObject.myMethod() <span class="comment">// Harry Potter</span></span><br></pre></td></tr></tbody></table></figure><p>搞清楚上面这些用法后，<code>this</code> 就没那么奇怪了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; myObject = {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  name: &lt;span class=&quot;string&quot;&gt;&#39;Harry Potter&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  myMethod: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myObject.myMethod() &lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这段代码为什么会返回&lt;code&gt;undefined&lt;/code&gt;呢？因为万恶的&lt;code&gt;this&lt;/code&gt;。&lt;/p&gt;
&lt;img src=&quot;/blog/2020/01/19/js-this/this.jpeg&quot; class=&quot;&quot; title=&quot;wtf is this&quot;&gt;
&lt;p&gt;MDN 对 &lt;strong&gt;this&lt;/strong&gt; 的定义是：代码运行的环境。这句话给我的最大感觉是：what the &lt;em&gt;**&lt;/em&gt; is this?&lt;/p&gt;
&lt;p&gt;这里总结下 &lt;strong&gt;this&lt;/strong&gt; 的几个用法。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://yoursite.com/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>为什么数据团队应该采用 reproducible research</title>
    <link href="http://yoursite.com/2020/01/19/reproducible-research/"/>
    <id>http://yoursite.com/2020/01/19/reproducible-research/</id>
    <published>2020-01-19T10:07:01.000Z</published>
    <updated>2020-01-22T19:42:39.787Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/19/reproducible-research/plot.jpg" class="" title="plot"><p>Reproducible research （可重复研究）是学术界的一个潮流。它的意思是，所有研究都应该是可以“复制”的。如果你给我一个研究报告，你不能只给我看结果，你还要给我看到<strong>整个分析过程</strong>，而且我能够在自己的电脑上<strong>复制</strong>出同样的结果。</p><p>经历过几个公司的数据相关业务后，我深深地感觉到：这个规范不只应该用在科学研究里，它也应该用在商业公司的数据团队里。</p><p><a id="more"></a></p><h2 id="传统的分析报告"><a href="#传统的分析报告" class="headerlink" title="传统的分析报告"></a>传统的分析报告</h2><p>为了简化讨论，我们假设数据已经自动搜集并存储在数据仓库中。我们先不讨论研究团队需要自己搜集数据的情况。</p><p>产品经理想了解一个问题：“我们为提升用户留存设计了一个新功能，这个新功能已经上线了1个月，它是否有效果呢？”</p><p>某分析师做了如下操作：</p><ol><li>从数据库提取数据，或从数据后台“下载”数据</li><li>把数据导入 excel 中，开始清洗数据</li><li>做某些假设检验、或模型分析</li><li>把分析结果展示在 excel 中，或另外写一份 word 报告</li></ol><p>在某些公司里，上面的做法已经“足够”了。但是，经历过学术训练的人会有如下问题：</p><ul><li>怎么判断报告作者使用了“正确”的数据源？例子：提取数据的时候日期搞错了。</li><li>怎么判断作者正确清洗了数据？例子：float 变 int。</li><li>怎么判断作者做了需要做的检验？例子：使用 lm 模型却没检查假设是否能被满足。</li><li>怎么判断作者没有为了推销自己的结论而“调整”数据？例子：选择性展示数据。</li><li>……</li></ul><p>上面这些问题可以总结为：<strong>怎么知道分析师没有犯错，无论是有意的错误还是无意的错误</strong>。</p><p>按照传统的方法，“找分析报告的 bug”是个成本很高的活儿，我们几乎只能被动接受分析师给的结果。</p><p>这意味着，我们没有办法系统性地保证数据分析的质量。一个小公司也许可以容忍这样的错误可能，但对严重依赖数据做出决策、并且需要做出大量决策的公司，这不是最优解。</p><h2 id="一个可复制的分析报告"><a href="#一个可复制的分析报告" class="headerlink" title="一个可复制的分析报告"></a>一个可复制的分析报告</h2><p>用可复制的分析报告，之前的研究问题会用下面的方法做。</p><h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><p>要求：数据的获取必须调用 API 或者写 SQL 语句。</p><p>作用：</p><ul><li>当我拿到你的分析，我能复制这段代码，然后调出完全一样的数据</li><li>如果我怀疑数据提取过程有问题，我可以检查代码，判断是不是取数据的代码写错了</li></ul><p>禁止行为：在后台“下载”数据。没人知道你在下载前做了哪些操作。</p><h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>要求：</p><ul><li>清洗数据必须使用代码完成。</li><li>整个数据清洗流程，都用注释清晰的标注。</li></ul><p>作用：其他人能检查整个分析流程，判断是否有某些地方出错。</p><p>禁止行为：在 excel 或其他工具上用<strong>鼠标点选</strong>完成数据清洗。鼠标点选也是不可复制的，不只别人复制不了，分析师自己都很难复制（也许第一次分析时点错了某个地方却不自知）。</p><h3 id="数据分析过程"><a href="#数据分析过程" class="headerlink" title="数据分析过程"></a>数据分析过程</h3><p>要求：</p><ul><li>需要给出使用某个分析模型的原因</li><li>需要说明参数选择的过程</li><li>需要用代码展示完整的分析流程</li></ul><p>作用：</p><ul><li>数据分析包含一定的理论知识，也包含很多相对主观的判断，记录这些判断过程，有助于其他人理解</li><li>方便检查代码正确情况</li></ul><p>禁止行为：不能把数据分析的过程当成“黑箱子”，过程和结果同样重要。</p><h3 id="报告形式"><a href="#报告形式" class="headerlink" title="报告形式"></a>报告形式</h3><p>要求：</p><ul><li>核心分析内容和分析结论在报告主干部分</li><li>从数据获取到分析部分的代码，都在备注部分，或者放在另一个文件里</li></ul><p>作用：</p><ul><li>报告使用者只需要阅读主要部分</li><li>报告<strong>审阅者</strong>可以在备注部分查找可复制研究的过程</li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>目前似乎只有2个选择：</p><ul><li>R：使用 Rmarkdown </li><li>Python：使用 Notebook</li></ul><p>其他工具满足不了“可复制”的需求。</p><h2 id="“可复制研究”的意义"><a href="#“可复制研究”的意义" class="headerlink" title="“可复制研究”的意义"></a>“可复制研究”的意义</h2><p>本质上，“可复制研究” 把数据分析从黑箱子变成了可以审阅的文本，发现分析错误变得相对便宜。</p><p>它让每个人的工作都变得 accountable。每一行代码、每一个分析决策，都被暴露在光天化日之下，东郭先生就无处藏身了。想象一下，写了你名字的报告上竟然有低级的数据清洗错误，这是件多么丢人的事情。</p><p>整体上，“可复制研究”会提高整个数据团队的分析质量。</p><p>我还没有机会在这样的团队工作，但过去的经历让我知道“普通”的数据分析团队可以糟糕到什么程度。看到某些分析师的报告，会让你怀疑他们是否上过统计学入门课，我一直为使用这些报告的决策者捏把汗。</p><p>可复制研究也对团队成员的能力有巨大的要求：</p><ul><li>必须会 R 或 Python，会还不够，还必须能写出 readable code</li><li>表达能力要足够强</li><li>有一定的统计基础，能够做到引用文献</li></ul><p>所谓“可复制研究”，除了是一种理念，还是一套工作流 workflow。就像 readable code 能整体上提高团队的开发质量，reproducible report 能整体上提高团队的数据分析质量。</p><p>使用可复制研究还有一个好处，“知识”变得可以沉淀，不再只是某些分析师脑子里的经验。后来者可以通过前人的报告学习分析思路、复用代码。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/19/reproducible-research/plot.jpg&quot; class=&quot;&quot; title=&quot;plot&quot;&gt;
&lt;p&gt;Reproducible research （可重复研究）是学术界的一个潮流。它的意思是，所有研究都应该是可以“复制”的。如果你给我一个研究报告，你不能只给我看结果，你还要给我看到&lt;strong&gt;整个分析过程&lt;/strong&gt;，而且我能够在自己的电脑上&lt;strong&gt;复制&lt;/strong&gt;出同样的结果。&lt;/p&gt;
&lt;p&gt;经历过几个公司的数据相关业务后，我深深地感觉到：这个规范不只应该用在科学研究里，它也应该用在商业公司的数据团队里。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据科学" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 其实很像 Python</title>
    <link href="http://yoursite.com/2020/01/18/js-python/"/>
    <id>http://yoursite.com/2020/01/18/js-python/</id>
    <published>2020-01-18T12:21:29.000Z</published>
    <updated>2020-01-22T19:42:39.783Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/18/js-python/js-py.jpg" class="" title="js-python"><p>在我刚入门 JavaScript 的时候，感觉 JavaScript 是个莫名其妙的语言。在那之前，我真正称得上了解的语言只有 python。写 python 是一种享受，相比之下，写 JavaScript 的体验很“怪异”。</p><p>后来我才直到，JavaScript 是一个在很短时间内创造的语言，是为了在浏览器上运行。我所学习的 JavaScript，还是20多年前的版本。拿老版本的 JavaScript 和今天的 python3 去比较，是挺不合理的。</p><p>在了解到最新的 JS 功能后，JavaScript 突然变得“可爱”了，甚至在某些地方很像 python。</p><p><a id="more"></a></p><h2 id="多行-string"><a href="#多行-string" class="headerlink" title="多行 string"></a>多行 string</h2><p>问题：如何给 string 换行呢？</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poem = <span class="string">"""Programming is fun</span></span><br><span class="line"><span class="string">Except for syntax errors</span></span><br><span class="line"><span class="string">Missing curly brace""</span></span><br></pre></td></tr></tbody></table></figure><p>老版本的 JavaScript 不支持，但现在支持了：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> poem = <span class="string">`Programming is fun</span></span><br><span class="line"><span class="string">Except for syntax errors</span></span><br><span class="line"><span class="string">Missing curly brace`</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="Expression-Interpolation"><a href="#Expression-Interpolation" class="headerlink" title="Expression Interpolation"></a>Expression Interpolation</h2><p>问题：如何方便地在 string 中使用变量呢？</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">print(<span class="string">f'Fifteen is <span class="subst">{a + b}</span> and not <span class="subst">{<span class="number">2</span> * a + b}</span>.'</span>)</span><br></pre></td></tr></tbody></table></figure><p>上面这个功能很实用，让代码的可读性提高了几个档次。JavaScript 也有类似的写法：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Fifteen is <span class="subst">${a + b}</span> and not <span class="subst">${<span class="number">2</span> * a + b}</span>.`</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="Destructuring"><a href="#Destructuring" class="headerlink" title="Destructuring"></a>Destructuring</h2><p>问题：如何同时 assign 几个变量的值呢？</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x, y, z = numbers</span><br></pre></td></tr></tbody></table></figure><p>Destructuring 在某些场合有用，ES2017 里有了类似的设计：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> [x, y, z] = numbers</span><br></pre></td></tr></tbody></table></figure><h2 id="Spread-Operator"><a href="#Spread-Operator" class="headerlink" title="Spread Operator"></a>Spread Operator</h2><p>问题：如何 assign 数组里的一个变量，并忽略其他变量呢？</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">first, *remaining = numbers</span><br></pre></td></tr></tbody></table></figure><p>下面是 JavaScript 的写法：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> [first, ...remaining] = numbers</span><br></pre></td></tr></tbody></table></figure><h2 id="Rest-Operator"><a href="#Rest-Operator" class="headerlink" title="Rest Operator"></a>Rest Operator</h2><p>问题：如何给函数任意多个 argument 呢？</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myFun</span><span class="params">(*argv)</span>:</span>  </span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> argv:  </span><br><span class="line">        <span class="keyword">print</span> (arg)</span><br><span class="line"></span><br><span class="line">myFun(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br></pre></td></tr></tbody></table></figure><p>在 python 里这个规则叫 <em>wargs。在 JavaScript 里，使用 <code>...</code>，这三个点叫 <em>*rest operator</em></em></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">product</span>(<span class="params">...args</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> arg</span><br><span class="line">  <span class="keyword">for</span> (arg <span class="keyword">of</span> args) {</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">product(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>问题：如何把一个数组里的数字全部开方</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">list(map(<span class="keyword">lambda</span> x: x * <span class="number">2</span>, numbers))</span><br><span class="line"><span class="comment"># or [x * 2 for x in numbers]</span></span><br></pre></td></tr></tbody></table></figure><p>JavaScript 里使用<strong>箭头函数</strong>：=&gt;</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">numbers.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><p>相比 lambda，箭头函数甚至更加 elegant。</p><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>问题：如何创建一个 class</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"({x}, {y})"</span>.format(x=self.x, y=self.y)</span><br></pre></td></tr></tbody></table></figure><p>在 ES2017 之前，JavaScript 的做法：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>{</span><br><span class="line">  <span class="keyword">this</span>.x = x</span><br><span class="line">  <span class="keyword">this</span>.y = y</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>第一次看到上面这段代码时我非常费解，这是什么鬼<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8">😰</span>？现在有新的写法了：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>{</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) {</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  toString() {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>习惯 python 的开发者可以无缝理解了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8">😆</span>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在 Hacker News 上看到过一句话：</p><blockquote><p>我招人的时候从来不问对方会什么编程语言，因为只要你会一门语言，掌握其他语言都很容易。作为一个工程师，真正重要的不是你会什么语言或框架，而是……</p></blockquote><p>这句话我只记得前半句，现在有点理解为什么编程语言不重要了。不过重要的到底是什么呢？虽然我不是软件工程师，不过还是对这个答案很好奇。</p><p>如果我需要招一个软件工程师，我会希望他/她有什么特质？</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/18/js-python/js-py.jpg&quot; class=&quot;&quot; title=&quot;js-python&quot;&gt;
&lt;p&gt;在我刚入门 JavaScript 的时候，感觉 JavaScript 是个莫名其妙的语言。在那之前，我真正称得上了解的语言只有 python。写 python 是一种享受，相比之下，写 JavaScript 的体验很“怪异”。&lt;/p&gt;
&lt;p&gt;后来我才直到，JavaScript 是一个在很短时间内创造的语言，是为了在浏览器上运行。我所学习的 JavaScript，还是20多年前的版本。拿老版本的 JavaScript 和今天的 python3 去比较，是挺不合理的。&lt;/p&gt;
&lt;p&gt;在了解到最新的 JS 功能后，JavaScript 突然变得“可爱”了，甚至在某些地方很像 python。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://yoursite.com/categories/Coding/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 vs. 统计学</title>
    <link href="http://yoursite.com/2020/01/18/statistics-ml/"/>
    <id>http://yoursite.com/2020/01/18/statistics-ml/</id>
    <published>2020-01-18T07:47:56.000Z</published>
    <updated>2020-01-22T19:42:39.787Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/18/statistics-ml/statistic-ml.jpeg" class="" title="线性回归"><p>机器学习和统计学不是一回事，可是机器学习里和统计学里又有很多交集，比如线性回归。两者都使用了相同的理论框架，但强调的东西完全不一样。</p><p>在具体的公司业务场景中，我们需要明确，自己需要的到底是统计学，还是机器学习。两者会对分析场景有不同的需求。</p><p>这篇文章总结两个学科的需求。</p><p><a id="more"></a></p><h2 id="统计学"><a href="#统计学" class="headerlink" title="统计学"></a>统计学</h2><p>统计学至少有两个典型的使用场景：</p><ul><li>使用样本估计总体</li><li>建立解释性模型</li></ul><h3 id="样本估计总体"><a href="#样本估计总体" class="headerlink" title="样本估计总体"></a>样本估计总体</h3><p>问卷调查是公司了解用户的重要手段。我最喜欢的例子是乐高。2004年时，乐高亏损严重。乐高的美国分公司老大跟《星球大战》的版权方谈妥了合作意向，于是飞到丹麦总部跟公司提出这个方案。乐高公司的高层对这个提议非常“震怒”，因为这违背了乐高一直以来“反对暴力”的理念：乐高的产品里一定不会有暴力元素，更别说要出一个名字里带“war”的产品系列了。</p><p>提出这个方案的美国老大动用了一个杀手锏：要不我们对家长做个问卷调查，看看家长们是否愿意为孩子们购买星战题材的乐高。问卷调查的结果说服了保守的乐高高层。《星球大战》系列开启了乐高的新时代，乐高开始频繁与全球大IP合作，各大 IP 为乐高带来了持续十几年的高速增长。</p><p>这里的问卷调查，其实就是统计学的重要应用：问卷调查的样本数据是整体市场数据的有效代表吗？把这个问题更抽象地表达：我只有 x 个样本，我是否能用这 x 个样本去有效的估计总体。</p><p>商业调查可以通过花钱解决样本数量问题，毕竟一份问卷也没多贵，但在医学药物实验里，一个样本就没那么便宜了。一轮药物实验经常只有几十个样本。用这几十个样本去估计总体，难度要大得多。</p><p>在互联网公司，最经常使用的统计学的场景是 A/B 测试，这里的核心问题是：A/B 测试的样本数据，是有效的总体代表吗？换句话说，我们可以通过这几千个样本，判断 A 版本比 B 版本更好吗？</p><h3 id="建立解释性模型"><a href="#建立解释性模型" class="headerlink" title="建立解释性模型"></a>建立解释性模型</h3><p>社会科学的论文需要利用统计学证明自己想描述的理论关系。</p><p>比如：</p><ul><li>收入的决定因素是什么？</li><li>是否存在收入上的性别/种族歧视？</li><li>R&amp;D投入和市场投入对公司长期盈利能力的影响分别有多大？</li><li>……</li></ul><p>所有这些问题，都需要建立一个模型去描述现象，然后通过数据验证这个模型的准确性。这里既存在样本代表性的问题（样本估计总体），还有模型解释力的问题。</p><p>比如在线性回归里，我们关注 R-square，一个好的模型，应该有比较好的 R-square。同时，这个模型应该是“可解释”的。相比机器学习，统计学的模型不能是个“黑箱子”。机器学习可以接受模型的“不可解释”，统计学则要求模型 make sense。</p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>机器学习与统计学有两个大的区别：</p><ul><li>大样本</li><li>以预测为目的</li></ul><h3 id="大样本"><a href="#大样本" class="headerlink" title="大样本"></a>大样本</h3><p>统计学里有100个样本可能就是很大了，一个 excel 表格就能轻松装下。机器学习利用了互联网时代的数据爆发，有海量的数据可供使用。实际上，机器学习已经存在了几十年，但因为没有足够“喂养”模样的数据和算力，一直没能发展，直到互联网时代。</p><p>统计学需要考虑“样本少”的问题，机器学习不只不用担心样本量，有时甚至能用“总体”做计算。</p><p>在大数据的前提下，很多统计学需要担心的问题不存在了。比如小样本下不适合使用某些 test。</p><h3 id="以预测为目的"><a href="#以预测为目的" class="headerlink" title="以预测为目的"></a>以预测为目的</h3><p>机器学习的最核心特征，是以预测为目的，预测准确度越高越好，过程并不重要。</p><p>机器学习<strong>不关心</strong>模型的解释效力。注意，这里说的是”不关心“。有的模型，比如线性回归，允许人对模型过程做解释，但另外一些模型，比如神经网络，很难解释。</p><p>在应用层面，机器学习非常的“务实”：别跟我扯理论，show me the accuracy。</p><p>同样是线性回归，即使用同样的数据集，我们也可能因为目标而不同而有各自的侧重。想象我们是一家连锁蛋糕公司，旗下有100家店铺。我们搜集了过去几年这些店铺的人流量、营业收入、商圈竞争对手数量等信息。我们可以：</p><ul><li>研究哪些因素最影响营业收入。</li><li>预测这些店铺未来的收入。</li></ul><p>上面两个任务都是可以用线性回归来做，但前者会偏重统计学，需要解释力，后者会偏重机器学习，需要预测力。</p><h2 id="如何选择技能点"><a href="#如何选择技能点" class="headerlink" title="如何选择技能点"></a>如何选择技能点</h2><p>单纯的统计学使用者，可以选择忽略机器学习。统计学使用者包括：</p><ul><li>社会科学领域的学者</li><li>咨询公司的数据分析师</li><li>大公司的用户调查团队</li><li>医药学研究者</li><li>…</li></ul><p>数据工作者成千上万，真正有机会用到机器学习解决问题的并不多。</p><p>但是，在互联网公司工作的数据工作者，或者希望在互联网公司做数据工作的人，大概率有机会使用机器学习，这个时候了解机器学习就会非常必要了。从学科脉络来看，机器学习的部分理论基础就是统计学，所以搞机器学习的人，是逃不过学习统计学的。所以，如果你想再互联网公司做数据工作，统计学和机器学习都是要有所了解的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/18/statistics-ml/statistic-ml.jpeg&quot; class=&quot;&quot; title=&quot;线性回归&quot;&gt;
&lt;p&gt;机器学习和统计学不是一回事，可是机器学习里和统计学里又有很多交集，比如线性回归。两者都使用了相同的理论框架，但强调的东西完全不一样。&lt;/p&gt;
&lt;p&gt;在具体的公司业务场景中，我们需要明确，自己需要的到底是统计学，还是机器学习。两者会对分析场景有不同的需求。&lt;/p&gt;
&lt;p&gt;这篇文章总结两个学科的需求。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据科学" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python 的 Generator</title>
    <link href="http://yoursite.com/2020/01/17/python-generator/"/>
    <id>http://yoursite.com/2020/01/17/python-generator/</id>
    <published>2020-01-17T13:52:13.000Z</published>
    <updated>2020-01-22T19:42:39.787Z</updated>
    
    <content type="html"><![CDATA[<p>问题：x 是一个由数字组成的 list，我们想求出每个元素的平方。</p><p>一个解决方法是：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_numbers</span><span class="params">(nums)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        result.append(i * i)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">my_nums = square_numbers([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">print(my_nums) <span class="comment"># [1, 4, 9, 16]</span></span><br></pre></td></tr></tbody></table></figure><p>这是个正确的答案，但不完美。我们可以使用 generator 写出更简洁的答案：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_numbers</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">yield</span>(i * i)</span><br><span class="line"></span><br><span class="line">my_nums = square_numbers([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">print(list(my_nums))</span><br></pre></td></tr></tbody></table></figure><p><a id="more"></a></p><h2 id="generator-函数"><a href="#generator-函数" class="headerlink" title="generator 函数"></a>generator 函数</h2><p>普通的函数使用 <code>return</code> 返回结果，<strong>generator 函数</strong>使用 <code>yield</code> 返回结果。</p><p>generator 函数可以使用 <code>next()</code> 获取下一个返回值。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dumb_generator</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">a = dumb_generator()</span><br><span class="line"></span><br><span class="line">print(next(a)) <span class="comment"># 1</span></span><br><span class="line">print(next(a)) <span class="comment"># 2</span></span><br><span class="line">print(next(a)) <span class="comment"># 3</span></span><br><span class="line">print(next(a)) <span class="comment"># 报错：StopIteration</span></span><br></pre></td></tr></tbody></table></figure><p>上面这段代码会在运行<code>next(a)</code>依次返回1、2、3，然后报错。</p><p>我们可以直接把 generator 函数的返回对象用在 for loop 里：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dumb_generator</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">a = dumb_generator()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">  print(i)</span><br></pre></td></tr></tbody></table></figure><p>for loop 在完成循环后会自动停止，不会报错。</p><h2 id="generator-comprehension"><a href="#generator-comprehension" class="headerlink" title="generator comprehension"></a>generator comprehension</h2><p>文章最开始的问题，其实可以用 list comprehension 快速解决：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_nums = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br></pre></td></tr></tbody></table></figure><p>generator 也可以用 comprehension 的形式快速生成：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_nums = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) <span class="comment"># 这是一个 generator</span></span><br></pre></td></tr></tbody></table></figure><h2 id="为什么使用-generator"><a href="#为什么使用-generator" class="headerlink" title="为什么使用 generator"></a>为什么使用 generator</h2><p>除了方便之外，generator 还有什么好处呢？最大的好处是，节约内存。</p><p>假设生成从1到100万的 list，这个 list 会被存在内存里，占据大量空间。<br>如果生成从1到100万的 generator，内存占用量几乎可以忽略不计。</p><p>另外，generator 还可以用来表达数学上的无穷数列，比如 <a href="https://en.wikipedia.org/wiki/Fibonacci_number" target="_blank" rel="noopener">Finabocci 数列</a>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fib():</span><br><span class="line">  print(i)</span><br><span class="line">  <span class="keyword">if</span> i &gt; <span class="number">1000</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></tbody></table></figure><p>上面的代码会打印出从0开始的 Finabocchi 数列，直到数列大于1000（第18个数字就会大于1000）。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题：x 是一个由数字组成的 list，我们想求出每个元素的平方。&lt;/p&gt;
&lt;p&gt;一个解决方法是：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;square_numbers&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nums)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; nums:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result.append(i * i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;my_nums = square_numbers([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(my_nums) &lt;span class=&quot;comment&quot;&gt;# [1, 4, 9, 16]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是个正确的答案，但不完美。我们可以使用 generator 写出更简洁的答案：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;square_numbers&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nums)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; nums:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;(i * i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;my_nums = square_numbers([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(list(my_nums))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://yoursite.com/categories/Coding/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>决策树模型里的 Entropy</title>
    <link href="http://yoursite.com/2020/01/17/decision-tree-entropy/"/>
    <id>http://yoursite.com/2020/01/17/decision-tree-entropy/</id>
    <published>2020-01-17T07:06:33.000Z</published>
    <updated>2020-01-22T19:42:39.779Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/17/decision-tree-entropy/decision-tree.png" class="" title="决策树"><p>决策树模型是机器学习的重要模型。决策树里有个概念，叫 entropy，模型的最优化函数基于 entropy 做出。</p><p>用一个诗意的说法，entropy 描述了世界的混乱程度。Split 能帮助降低混乱程度。</p><p>这篇文章用具体例子说明，split 如何降低 entropy。</p><p><a id="more"></a></p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>给定数据集中有 C 个分组，entropy 的公式如下：</p><img src="/blog/2020/01/17/decision-tree-entropy/entropy.png" class="" title="entropy公式"><p>公式中的 pi 是第 c 类元素的出现概率。</p><h2 id="不可知与可知"><a href="#不可知与可知" class="headerlink" title="不可知与可知"></a>不可知与可知</h2><p>想象一个世界上只有“好人”，那么好人的概率是1。因为 log_2(1) = 0，此时的 entropy = 0。</p><p>想象另一个世界，只有坏人，那么好人的概率是0，这时 entropy = -1 * 0 * log_2(1) = 0。</p><p>上面两种情况，如果以 entropy 来描述，都是“可知”的，不存在任何混乱，这是个稳定的世界。</p><p>想象第3个世界：好人和坏人各占一半，那么 entropy = (0.5 * log_2(0.5)) + (0.5 * log_2(0.5)) = 1。</p><p>这是个极端“混乱”的世界，路上随便碰到一个人，你完全不知道他是好人还是坏人。在这里，不确定性达到最大值。</p><h2 id="引入解释变量"><a href="#引入解释变量" class="headerlink" title="引入解释变量"></a>引入解释变量</h2><p>我们还在第3个世界里，作为数据工作者，我们无法忍受这种混乱，于是我们决定建立一个模型，找到识别坏人和好人的方法。</p><p>我们去警察局获取了100个人的档案，其中有50个好人、50个坏人。档案里还有另一个数据：是否染发。</p><p>根据上面的档案数据，我们绘制表格如下：</p><img src="/blog/2020/01/17/decision-tree-entropy/table.png" class="" title="好人坏人以及染发"><p>我们似乎可以用染发与否判断一个人是好人还是坏人。</p><p>如果使用上面的判断方式，我们的 entropy 会减少多少呢？</p><p>E(染发) =  10/45 * log_2(10/45) + 35/45 * log_2(35/45) = 0.76<br>E(不染发) =  40/55 * log_2(40/55) + 15/55 * log_2(15/55) = 0.85</p><p>然后按照频率加权平均，得到以染发预测好人的 entropy：<br>E(是否好人｜是否染发) = 45/100 * 0.76  + 55/100 * 0.85 = 0.81</p><p>现在我们看到一个染发者，就判断他是坏人，然后躲得远远的。我们会有一定的错判率（大概29%），但这已经比之前无法判断的情况有了进步，这个世界没有那么混乱了。怎么衡量混乱程度的减少呢？我们用原先的 entropy 减去基于某个因素做判断的 entropy，得到这个因素的 <strong>information gain</strong>：</p><p>IG= = E(是否好人) - E(是否好人|是否染发) = 1 - 0.81 = 0.19</p><p>引入染发这个 split，我们获得了 0.19 的进步。</p><p>如果我们有更多变量，我们就可以依次计算每个变量的 IG，并选择 IG 效果最好的变量作为解释变量。当我们依次选择出了若干个解释变量，所谓的决策树<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f332.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f332.png?v8">🌲</span>就出现了。</p><h2 id="一个引申"><a href="#一个引申" class="headerlink" title="一个引申"></a>一个引申</h2><p>如果公司对 A 方案有5成把握，在 entropy 函数里，混乱程度是最严重的。另外一个方案 B，公司只有2成把握，这时的 entropy 值比较低。</p><p>这是一个有意思的发现：我们希望 entropy 越低越好。站在公司角度，B 方案是个可以快速拒绝的方案：我们清楚地知道它大概率失败（假设两个方案的预期回报相等）。真正造成混乱后果，往往是 A 方案这样模棱两可的方案。</p><p>再看一个（半搞笑的）场景，假设有两个同事：</p><ul><li>A 员工的判断准确度是50%</li><li>B 员工的判断准确度是20%</li></ul><p>我会更希望自己的手下是哪个呢？按照 entropy 公式，B 员工的 entropy 值更低。此时我们选择 B 员工：我们只要做出跟 B 员工的判断相反的选择，就大概率正确了。而 A 员工呢，价值还不如一枚硬币，毕竟通过抛硬币做选择也能达到50%的准确度。</p><p>现实生活里有没有类似 B 员工的人呢？可能没有这样的人，但在某一类问题上，有人开能会习惯性犯错。</p><p>我曾经有个同事喜欢追求完美，总是没有办法按期完成任务，ta 经常会说“我觉得这个版本还不够好/我还没准备好，要不再等一等”。如果选择延期，结果往往更糟糕。在按期交付问题上，ta 的判断力就像只有20%的准确度 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span>。当我意识到这点后，每次 ta 提出“可以延期“时，我总会立刻做出判断：不能延期了，必须交付。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/17/decision-tree-entropy/decision-tree.png&quot; class=&quot;&quot; title=&quot;决策树&quot;&gt;
&lt;p&gt;决策树模型是机器学习的重要模型。决策树里有个概念，叫 entropy，模型的最优化函数基于 entropy 做出。&lt;/p&gt;
&lt;p&gt;用一个诗意的说法，entropy 描述了世界的混乱程度。Split 能帮助降低混乱程度。&lt;/p&gt;
&lt;p&gt;这篇文章用具体例子说明，split 如何降低 entropy。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计理论" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>线性回归的假设</title>
    <link href="http://yoursite.com/2020/01/16/lm-assumptions/"/>
    <id>http://yoursite.com/2020/01/16/lm-assumptions/</id>
    <published>2020-01-16T12:56:06.000Z</published>
    <updated>2020-01-22T19:42:39.783Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/16/lm-assumptions/assumption.png" class="" title="假设"><p>数据可以骗人，这个道理大家都知道。我印象最深的经历是：同事给了一个基于 linear regression 的研究报告，但报告完全没有对线性回归的假设做<strong>任何诊断</strong>。不做假设检验的分析报告在大学作业里会被判断为不及格。</p><p>但这份报告在业务部门中传阅，成为了产品的决策依据。这是一个上市公司，报告分析的产品也是公司的现金牛产品。</p><p>糟糕的数据分析，最好的结果是浪费了大家的时间，最坏的结果是指导决策者做出错误的决策。</p><p>这篇文章小结一下 linear regression 的几个核心假设，就当是大学知识的一次复习。</p><p><a id="more"></a></p><h2 id="LM的假设"><a href="#LM的假设" class="headerlink" title="LM的假设"></a>LM的假设</h2><ol><li>线性关系</li><li>自变量之间不具有多重共线性</li><li>扰动项符合正态分布</li><li>同方差</li><li>没有自相关：这种情况在非时间序列里很少见，所以我们不讨论了</li></ol><h2 id="1-线性关系"><a href="#1-线性关系" class="headerlink" title="1. 线性关系"></a>1. 线性关系</h2><p>第一个假设最直接：自变量和因变量之间是线性关系。</p><p>反例：<code>y = a + b * x ^ 3</code>，这里的 y 和 x 就不是线性关系。</p><p>做一元回归时，散点图可以揭示自变量与因变量之间的关系。</p><p>如果是多元回归，可以使用 R 的 <code>lm</code> 对象自带的 <code>plot</code> 函数。函数返回的第1个图片：<strong>Residuals vs Fitted</strong> 能够用来检查线性假设。</p><p>我们模拟数据并示例如下：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">size &lt;- <span class="number">30</span></span><br><span class="line">x &lt;- rnorm(size, <span class="number">15</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">y1 &lt;- <span class="number">3</span> + <span class="number">5</span> * x + rnorm(size, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">y2 &lt;- <span class="number">3</span> + <span class="number">5</span> * x^<span class="number">3</span> + rnorm(size, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">fit_1 &lt;- lm(y1 ~ x)</span><br><span class="line">fit_2 &lt;- lm(y2 ~ x)</span><br><span class="line"></span><br><span class="line">p1 &lt;- autoplot(fit_1)</span><br><span class="line">p2 &lt;- autoplot(fit_2)</span><br><span class="line"></span><br><span class="line">p1_1 &lt;- p1[[<span class="number">1</span>]] + ggtitle(<span class="string">'满足线性假设'</span>) + theme(plot.title = element_text(size = <span class="number">18</span>))</span><br><span class="line">p2_1 &lt;- p2[[<span class="number">1</span>]] + ggtitle(<span class="string">'不满足线假设'</span>) + theme(plot.title = element_text(size = <span class="number">18</span>))</span><br><span class="line"></span><br><span class="line">ggarrange(p1_1, p2_1 + rremove(<span class="string">'y.title'</span>), ncol = <span class="number">2</span>, nrow = <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><p>我使用了 ggfortify 包处理 lm 的图片，并用 ggpubr 包把两个模型的图片并列在一起。</p><p>图片如下：</p><img src="/blog/2020/01/16/lm-assumptions/plot_1.png" class="" title="线性假设"><p>当模型满足线性假设时，fitted value 和 residuals 的关系接近一条直线（如左图），右图则明显不是直线。</p><h2 id="2-多重共线性"><a href="#2-多重共线性" class="headerlink" title="2. 多重共线性"></a>2. 多重共线性</h2><p>要求：自变量之间没有<strong>过于强</strong>的线性关系。</p><p>有一些线性关系是没问题的。在研究现实问题时，我们很难找到完全没线性关系的自变量。</p><p>比如研究收入的影响因素，我们会考虑智商和学历。智商越高，自然收入越高；学历越高，当然收入也越高。可是，学历也同时跟智商有线性关系。这会是个问题吗?</p><p>只要这两个变量不是完全的线性关系，我们就不用担心。这两个因素当然不是完全线性关系，除了智商之外，家庭条件、考生的所处省份、个人兴趣等因素也跟学历有巨大关系。</p><p>我们可以查看所有自变量之间的相关性。ggplot 生态里有个非常好用的 <code>ggcorrplot</code> 包：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggcorrplot)</span><br><span class="line">data(mtcars)</span><br><span class="line">corr &lt;- round(cor(mtcars), <span class="number">1</span>)</span><br><span class="line">ggcorrplot(corr, hc.order = <span class="literal">TRUE</span>, type = <span class="string">"lower"</span>,</span><br><span class="line">           outline.col = <span class="string">"white"</span>,</span><br><span class="line">           ggtheme = ggplot2::theme_gray,</span><br><span class="line">           colors = c(<span class="string">"#6D9EC1"</span>, <span class="string">"white"</span>, <span class="string">"#E46726"</span>)) </span><br></pre></td></tr></tbody></table></figure><p>结果如下图：</p><img src="/blog/2020/01/16/lm-assumptions/plot_2.png" class="" title="多重共线性"><p>如果想更严格地描述多重共线性问题，可以参考一个叫 <a href="https://en.wikipedia.org/wiki/Variance_inflation_factor" target="_blank" rel="noopener">variance inflation factor</a> 的指标。</p><h2 id="3-扰动项符合正态分布"><a href="#3-扰动项符合正态分布" class="headerlink" title="3. 扰动项符合正态分布"></a>3. 扰动项符合正态分布</h2><p>扰动项 error term 是一个理论概念：没有被观察到的影响因素，都算在扰动项里。扰动项无法直接衡量，所以我们用残差 residuals 来代替。残差是真实值和拟合值之间的差。</p><p>一般使用 Normal QQ 图来检查扰动项是否符合正态分布。</p><p>我们先 simulate 两组数据，然后对比它们的 QQ 图：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">size &lt;- <span class="number">100</span></span><br><span class="line">x &lt;- rnorm(size, <span class="number">15</span>, <span class="number">10</span>)</span><br><span class="line">err &lt;- rnorm(size, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">  </span><br><span class="line">y1 &lt;- <span class="number">3</span> + <span class="number">5</span> * x + err</span><br><span class="line">y2 &lt;- <span class="number">3</span> + <span class="number">5</span> * x + err ^ <span class="number">3</span></span><br><span class="line"></span><br><span class="line">fit_1 &lt;- lm(y1 ~ x)</span><br><span class="line">fit_2 &lt;- lm(y2 ~ x)</span><br><span class="line"></span><br><span class="line">p1 &lt;- autoplot(fit_1)</span><br><span class="line">p2 &lt;- autoplot(fit_2)</span><br><span class="line"></span><br><span class="line">p1_2 &lt;- p1[[<span class="number">2</span>]] + ggtitle(<span class="string">'扰动项正态分布'</span>) + theme(plot.title = element_text(size = <span class="number">18</span>))</span><br><span class="line">p2_2 &lt;- p2[[<span class="number">2</span>]] + ggtitle(<span class="string">'非正态分布'</span>) + theme(plot.title = element_text(size = <span class="number">18</span>))</span><br><span class="line"></span><br><span class="line">ggarrange(p1_2, p2_2 + rremove(<span class="string">'y.title'</span>),</span><br><span class="line">           ncol = <span class="number">2</span>, nrow = <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><p>我们让第1个模型的扰动项完美符合正态分布，让第2个模型第扰动项严重偏离正态分布。<br>得到的 QQ 图如下：</p><img src="/blog/2020/01/16/lm-assumptions/plot_3.png" class="" title="扰动项符合正态分布"><p>在完美假设的情况下，所有的点几乎跟图中直线重合。右图中的点则严重偏离了图中直线。</p><h2 id="4-同方差"><a href="#4-同方差" class="headerlink" title="4. 同方差"></a>4. 同方差</h2><p>同方差假设的内容是：对不同的自变量值，扰动项的方差是相同的。如果违反了这个假设，就叫“异方差”。</p><p>典型的的异方差场景：研究收入和学历的关系，我们可以大概预料到，学历越高的人，收入的反差越大（有的人混得非常好，有的人混得一般）。</p><p>这是线性回归里非常重要的假设，我们可以用 <code>ncvTest()</code> 检测异方差。也可以在做出模型后做可视化检查，即使用 scale-location 图。</p><p>跟之前的思路一样，我在下面的代码里模拟一个正常模型和一个异方差模型。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">123</span>)</span><br><span class="line">size &lt;- <span class="number">100</span></span><br><span class="line">x &lt;- rnorm(size, <span class="number">15</span>, <span class="number">10</span>)</span><br><span class="line">err_1 &lt;- rnorm(size, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">err_2 &lt;- (x -<span class="number">1</span>)* rnorm(size, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">y1 &lt;- <span class="number">3</span> + <span class="number">5</span> * x + err_1</span><br><span class="line">y2 &lt;- <span class="number">3</span> + <span class="number">5</span> * x + err_2</span><br><span class="line"></span><br><span class="line">fit_1 &lt;- lm(y1 ~ x)</span><br><span class="line">fit_2 &lt;- lm(y2 ~ x)</span><br></pre></td></tr></tbody></table></figure><p>这里我们查看 scale-location 图，下图中同方差的情况是一条比较直的线，异方差则比较斜。</p><img src="/blog/2020/01/16/lm-assumptions/plot_4.png" class="" title="scale-location"><p>另一个更符合直接的参考图，是 x 和对应残差的散点图。<br>参考下图：下图的异方差现象很明显，残差随着x的变大而变大。</p><img src="/blog/2020/01/16/lm-assumptions/plot_5.png" class="" title="x和残差的散点图"><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>线性回归模型的前提是模型满足假设，这是科学研究的规范，在公司里生成研究报告时，也应该做相应的检查。</p><p>在 R 语言里查看这几个假设很简单，只需要在 <code>fit = lm(y ~ x)</code>使用<code>plot(fit)</code>函数。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/16/lm-assumptions/assumption.png&quot; class=&quot;&quot; title=&quot;假设&quot;&gt;
&lt;p&gt;数据可以骗人，这个道理大家都知道。我印象最深的经历是：同事给了一个基于 linear regression 的研究报告，但报告完全没有对线性回归的假设做&lt;strong&gt;任何诊断&lt;/strong&gt;。不做假设检验的分析报告在大学作业里会被判断为不及格。&lt;/p&gt;
&lt;p&gt;但这份报告在业务部门中传阅，成为了产品的决策依据。这是一个上市公司，报告分析的产品也是公司的现金牛产品。&lt;/p&gt;
&lt;p&gt;糟糕的数据分析，最好的结果是浪费了大家的时间，最坏的结果是指导决策者做出错误的决策。&lt;/p&gt;
&lt;p&gt;这篇文章小结一下 linear regression 的几个核心假设，就当是大学知识的一次复习。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计理论" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>AB测试的例子：访问时长</title>
    <link href="http://yoursite.com/2020/01/16/ab-test-length/"/>
    <id>http://yoursite.com/2020/01/16/ab-test-length/</id>
    <published>2020-01-16T03:46:52.000Z</published>
    <updated>2020-01-22T19:42:39.779Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇关于AB测试的文章里，我们模拟了一个常见的 ab 测试场景：转化率。这个场景适用于计算百分比数据的场景。</p><p>还有一种场景，数据不是百分比，而是连续数值。例如：</p><ul><li>访问时长</li><li>人均消费</li><li>人均阅读数量</li><li>…</li></ul><p>这个问题场景下，不适合使用 r 的 <code>prop.test</code> 函数。我们可以使用 z-test。</p><p><a id="more"></a></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>我们是一个内容 app，产品部门开发了一个新版本，我们想要测试新版本下的用户访问时长是否会提高。</p><p>我们的原假设和备择假设是：</p><ul><li>H0：新方案的访问时长 &lt;= 老方案的访问时长</li><li>Ha：新方案的访问时长 &gt; 老方案的访问时长</li></ul><p>我们选择单侧检验有2个原因：</p><ul><li>从产品迭代流程考虑，如果没有证据正面新方案比老方案好，我们就不会全面部署新方案，所以我们寻找证据“证伪”老方案</li><li>从统计功效考虑，使用单侧检验能在相同样本下保证更高的统计功效，也就是节约成本了</li></ul><p>因为比较的是两个总体的分布是否有差距，我们使用 two sample t-test。</p><h2 id="参数设定和样本数量估计"><a href="#参数设定和样本数量估计" class="headerlink" title="参数设定和样本数量估计"></a>参数设定和样本数量估计</h2><p>跟之前一样，我们设定 80% 的 power 和 0.05 的 significance level。</p><p>t-test 的样本量估算需要先给定一个 cohen’d。</p><p>d = (m1 - m2 ) /  delta，其中：</p><ul><li>m1 和 m2 分别是两组的均值</li><li>delta 是 common standard deviation</li></ul><p>在开始测试之前，我们只知道 m2 的时长，假设 m2 = 60。理论上我们不可能知道 delta，但我们可以用老方案的样本去估算。一个“便利公式”是 delta = （最大值 - 最小值）/4。假定 delta = 25。</p><p>现在，我们要判断：我们预期新方案的均值有多大的提升呢？假设我们期望新方案会比老方案提高5，也就是从60提高到65。这时我们可以计算 cohen’d = （65 - 60） / 25 = 0.2</p><p>这时我们可以用 R 的 pwr package 估算需要的样本量：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwr.t.test(d = <span class="number">0.2</span>, sig.level = <span class="number">0.05</span>, power = <span class="number">0.8</span>, type = <span class="string">'two.sample'</span>, alternative=<span class="string">'greater'</span>)</span><br></pre></td></tr></tbody></table></figure><p>这个计算告诉我们，每个组需要310个样本。我们着手安排测试。</p><h2 id="检查数据"><a href="#检查数据" class="headerlink" title="检查数据"></a>检查数据</h2><p>一天之后，我们搜集够了650个样本，每组325个样本，我们开始检查数据。</p><p>我们发现两个组的数据如下：</p><ul><li>新方案：平均时长64秒，标准差43秒</li><li>原方案：平均时长60秒，标准差40秒</li></ul><p>看上去新方案更好，但我们能得出新方案更好的结论吗？</p><p>我们可以用 <code>t.test</code> 做检验：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- rnorm(<span class="number">315</span>, <span class="number">64</span>, <span class="number">43</span>)</span><br><span class="line">y &lt;- rnorm(<span class="number">315</span>, <span class="number">60</span> ,<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">t.test(x, y , alternative = <span class="string">'greater'</span>)</span><br></pre></td></tr></tbody></table></figure><p>我在这里模拟了数据，实际上我们可以直接带入两个 list 进 t.test，或者用现成的能输入均值和标准差的函数。</p><p>结果：p值 = 0.21，我们无法拒绝原假设。</p><p>结论：新方案未必比老方案好，我们需要做进一步测试（增加样本量），或保留老方案。</p><p>另一个平行宇宙里，新方案的平均时长还是64秒，标准差是40秒，我们的结论又会变成怎样呢？</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- rnorm(<span class="number">315</span>, <span class="number">64</span>, <span class="number">40</span>)</span><br><span class="line">y &lt;- rnorm(<span class="number">315</span>, <span class="number">60</span> ,<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">t.test(x, y , alternative = <span class="string">'greater'</span>)</span><br></pre></td></tr></tbody></table></figure><p>p值 = 0.04956，小于 0.05。<br>结论：我们拒绝原假设，认为新方案更好。</p><h2 id="AB-测试不只关注均值，还关注分布"><a href="#AB-测试不只关注均值，还关注分布" class="headerlink" title="AB 测试不只关注均值，还关注分布"></a>AB 测试不只关注均值，还关注分布</h2><p>我经常看到不了解统计学的同事用两个均值作为方案优劣的比较依据。上面的例子可以说明：均值差异是不够的。很多时候，我们观察到的均值差异只是随机现象的结果。</p><p>科学的方法还会考虑分布，怎么考虑分布呢？选择一个合适的 test 计算统计显著性。</p><p>不是每个人都懂统计学，但有的人会懂得尊重科学。</p><p>当我们从公司层面追求科学的数据方法论，公司从上到下的决策水平都会提高。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇关于AB测试的文章里，我们模拟了一个常见的 ab 测试场景：转化率。这个场景适用于计算百分比数据的场景。&lt;/p&gt;
&lt;p&gt;还有一种场景，数据不是百分比，而是连续数值。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问时长&lt;/li&gt;
&lt;li&gt;人均消费&lt;/li&gt;
&lt;li&gt;人均阅读数量&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个问题场景下，不适合使用 r 的 &lt;code&gt;prop.test&lt;/code&gt; 函数。我们可以使用 z-test。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="增长黑客" scheme="http://yoursite.com/categories/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>AB测试的例子：转化率</title>
    <link href="http://yoursite.com/2020/01/15/ab-test-ctr/"/>
    <id>http://yoursite.com/2020/01/15/ab-test-ctr/</id>
    <published>2020-01-15T14:26:03.000Z</published>
    <updated>2020-01-22T19:42:39.779Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/15/ab-test-ctr/abtest.jpeg" class="" title="题图"><p>AB 测试是互联网产品优化的科学方法，甚至可能是唯一科学的方法。在这篇文章里，我用 R 语言模拟 AB 测试的流程。</p><p><a id="more"></a></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>假设我们有一个购物 APP，我们重新设计了商品页面，现在我们要回答的问题是：新设计方案对用户的购买率有提高吗？令原方案为 A，新方案为 B。</p><p>我们的原假设和备择假设是：</p><ul><li>原假设：新方案的转化率 &lt;= 老方案的转化率</li><li>备择假设：新方案的转化率 &gt; 老方案的转化率</li></ul><p>因为我们只关心 B 方案是否会比 A 方案好，所以我们使用 one-sided test。原假设是我们想要通过数据去“证伪”的假设，所以原假设是“新方案是没有用处的”，即新方案的转化率低于或等于老方案。</p><p>因为需要判断的是转化率，我们可以使用 <a href="https://www.statisticshowto.datasciencecentral.com/z-test/" target="_blank" rel="noopener">Z-test</a>。</p><h2 id="参数设定和样本数量估计"><a href="#参数设定和样本数量估计" class="headerlink" title="参数设定和样本数量估计"></a>参数设定和样本数量估计</h2><p>在开始搜集数据前，我们需要设定几个参数。</p><ul><li>显著性水平 significance level：我们愿意接受的犯第1类错误的概率是多少？</li><li>统计功效 power：我们希望的统计功效是多少？</li><li>给定当前的转化率（10%），我们希望 B 方案的转化率提高到多少？</li></ul><p>我们依次设定参数如下：</p><ul><li>显著性水平 5%</li><li>统计功效 80%</li><li>转化率提高到 12%</li></ul><p>我们假设样本会平均分配到两个方案中。</p><p>我们使用 <code>pwr</code> packag 来计算需要的样本量</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwr.2p.test(h=ES.h(p1 = <span class="number">0.10</span>, p2 = <span class="number">0.12</span>), </span><br><span class="line">            sig.level = <span class="number">0.05</span>, </span><br><span class="line">            power=<span class="number">0.8</span>, </span><br><span class="line">            alternative = <span class="string">'less'</span>)</span><br></pre></td></tr></tbody></table></figure><p>这个计算告诉我们，每组大概需要 3021 个样本，一共需要大约6100个样本。</p><p>根据 app 流量，我们预计1天的时间可以搜集完所有的数据。于是我们使用现成的工具（或者让工程师开发），并开始测试。</p><h2 id="检查数据"><a href="#检查数据" class="headerlink" title="检查数据"></a>检查数据</h2><p>一天之后，我们搜集够了6100个样本，我们开始检查数据。</p><p>我们发现两个组的数据如下：</p><ul><li>原始方案：3500个样本中，有360个用户发生了转化</li><li>新方案：3500个样本中，有400个用户发生了转化</li></ul><p>看上去是新方案“获胜”了，可是，这个差异在统计学上显著吗？</p><p>我们做一个使用 r 的 <code>prop.test</code> 函数：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prop.test(x = c(<span class="number">360</span>, <span class="number">400</span>), n = c(<span class="number">3500</span>, <span class="number">3500</span>), alternative = <span class="string">'less'</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果：p 值 = 0.067，比预先设定的显著性水平高，我们不能拒绝原假设。</p><p>结论：我们没有理由认为新方案更好。</p><p>想象再另一个平行宇宙，新方案有410个用户发生了转化，我们的 p 值会是多少呢？</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prop.test(x = c(<span class="number">360</span>, <span class="number">410</span>), n = c(<span class="number">3500</span>, <span class="number">3500</span>), alternative = <span class="string">'less'</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果：p 值 = 0.031，我们可以拒绝原假设了。</p><p>结论：新方案的转化率更高。</p><h2 id="为什么是-80-和-5-？"><a href="#为什么是-80-和-5-？" class="headerlink" title="为什么是 80% 和 5%？"></a>为什么是 80% 和 5%？</h2><p>在上面的例子中，我们选择了 80% 的 power 和 5% 的 significane level。为什么呢？Stackoverflow 的数据科学家给了<a href="https://stackoverflow.blog/2017/10/17/power-calculations-p-values-ab-testing-stack-overflow/" target="_blank" rel="noopener">一个非常好的解释</a>。</p><p>如果选择95%的 power 和1%的 significance level，我们的结论准确度会有极大提高，但测试会消耗更多的时间，导致影响商业决策的效率。</p><p>如果我们在刚才的例子追求这样的准确度，我们需要的样本量会翻倍，也就是说，时间成本翻倍。</p><p>如果只看单个测试，翻倍似乎是可以接受的，但一个成熟的互联网产品可能在同时进行几十个优化测试，如果每个测试都追求极端准确性，产品的迭代速度会减少50%。对于“天下武功，唯快不破”的互联网产品，这样的效率损失是绝对不可接受的。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://www.invespcro.com/blog/one-tailed-vs-two-tailed-a-b-testing-everything-you-possibly-need-to-know/" target="_blank" rel="noopener">为什么使用单侧检验</a></li><li><a href="https://cran.r-project.org/web/packages/pwr/vignettes/pwr-vignette.html" target="_blank" rel="noopener">pwr package</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/15/ab-test-ctr/abtest.jpeg&quot; class=&quot;&quot; title=&quot;题图&quot;&gt;
&lt;p&gt;AB 测试是互联网产品优化的科学方法，甚至可能是唯一科学的方法。在这篇文章里，我用 R 语言模拟 AB 测试的流程。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="增长黑客" scheme="http://yoursite.com/categories/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>1类错误和2类错误</title>
    <link href="http://yoursite.com/2020/01/15/type-one-error/"/>
    <id>http://yoursite.com/2020/01/15/type-one-error/</id>
    <published>2020-01-15T11:45:10.000Z</published>
    <updated>2020-01-22T19:42:39.787Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/15/type-one-error/plot_0.jpg" class="" title="题图"><p>统计学里有两个基石一样的概念：一类错误和二类错误。这两个概念是统计检验的基础。</p><p><a id="more"></a></p><h2 id="原假设"><a href="#原假设" class="headerlink" title="原假设"></a>原假设</h2><p>在定义这两类错误前，我们需要先复习假设检验。</p><p>在检验检验里，我们定义了<strong>原假设</strong> null hypothesis。原假设是我们希望通过数据去“证伪”的假设，习惯被表述为 H0。</p><p>一个典型的 H0 是：本市的人均收入大于或等于8000元。</p><p>原假设的对立面，是备择假设 alternative hypothesis，习惯被表述为 Ha。</p><p>上面的 H0 对应的 Ha 是：本市的人均收入小于8000元。</p><p>我们对本市市民做了一次问卷调查，搜集了10000份问卷，根据数据调查结果，我们会有两种结论：</p><ul><li>拒绝 H0，即接受 Ha</li><li>无法拒绝 H0</li></ul><p>在上面的表述里，我们没有说“接受 H0”。这是外行最常用错的表达。</p><h2 id="为啥不能说“接受”原假设"><a href="#为啥不能说“接受”原假设" class="headerlink" title="为啥不能说“接受”原假设"></a>为啥不能说“接受”原假设</h2><p>在解答这个问题之前，我们需要先了解假设检验的方法论。</p><p>对每一个研究课题，我们的工作流程是：</p><ol><li>确定 H0 和 Ha</li><li>根据过往的研究和理论，确定要使用的假设检验方法</li><li>选好一个<strong>显著性水平</strong> significance level，比如 alhpa = 0.05</li><li>搜集数据，并计算 p 值</li><li>如果 p 值 &lt; alpha，我们说<strong>拒绝原假设</strong>，否则，我们说<strong>无法拒绝原假设</strong></li></ol><p>是否拒绝原假设，受到我们选择的 significance level 影响。如果 p 值等于 0.06，而我们的 significance level 选了0.05，因为<code>0.06 &gt; 0.1</code>，这个时候我们会“无法拒绝原假设”。而如果 significance level 选了0.1，因为<code>0.06 &lt; 0.1</code>，我们就能够拒绝原假设。</p><p>当我们做假设检验时，我们其实是在研究这个问题：<strong>给定原假设为真，我们有多大的可能观察到自己所搜集的数据，如果这个可能性很小，我们就拒绝原假设</strong>。当我们 p 值 &gt; alpha 时，本质上等价于：<strong>我们所搜集到的数据并没有极端到能说明原假设是错的</strong>。这里的极端程度标准，就是我们选好的 significance level。</p><p>以这个 H0 为例：本市的人均收入大于或等于8000元。 </p><p>我们发现调查1万人的平均收入是7990元，这个数字比8000小，看上去人均收入似乎低于8000了，但要注意，抽样调查存在随机性，这10元的差距很有可能是随机现象导致。换句话说，我们观察到的数据不足以证明原假设是错的。</p><p>但我们是否能接受“人均收入大于或等于8000”的说法呢？显然不能，7990 的调查结果当然支撑不了这个说法。</p><p>如果我们想要证明人均收入大于8000，我们的原假设就应该是：人均收入小于或等于8000（原假设里一定要有等号）。</p><h2 id="第1类错误和第2类错误"><a href="#第1类错误和第2类错误" class="headerlink" title="第1类错误和第2类错误"></a>第1类错误和第2类错误</h2><p>理论部分搞清楚后，我们开始介绍第1类错误和第2类错误。</p><p>第1类错误：原假设为真，但我们拒绝了原假设。这类错误叫<strong>去真</strong>，英文文献里说 false positive。<br>第2类错误：原假设为假，但我们没有拒绝原假设。这类错误叫<strong>存伪</strong>，英文文献里叫 false negative。</p><p>如下图：<br><img src="/blog/2020/01/15/type-one-error/error.png" class="" title="假设检验的错误"></p><p>犯第1类错误的概率，就是之前出现的 significance level。如果我们确定了 alpha = 0.05，那么在100次假设检验中，就会有5次出现第1类错误。</p><p>犯第2类错误的概率，被称为 beta，另一个常用统计学概念 power（统计功效）就等于 1 - beta。犯第2类错误的概率越低，建设检验的 power 就越高。</p><p>在这两类错误中，我们更关心哪一类呢？有的书籍会告诉我们第1类错误更重要，它们会用法庭审判的例子，说审判一个无罪的人有罪（第1类错误）是更大的风险，这其实只是个比喻，不是个好例子。下面我们看两个例子。</p><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><p>我们用统计学使用的最严格的场景做例子：药物效果的判断。新药上市前，要经过一系列严格的医学试验。</p><p>H0：药物 A 对治疗某疾病没有帮助<br>Ha：药物 A 对治疗某疾病有帮助</p><p>相关错误和结果如下：</p><p>第1类错误：药物 A 是没用的，但我们拒绝了原假设，给出了药物 A 是有用的的判断。药物上市，患者购买后没有帮助，患者因为使用 A 药物可能没有使用其他有效的药物，最后可能有负面结果（甚至死亡），进一步研究发现药物 A 是无效的，公司面料患者诉讼，甚至可能破产。</p><p>第2类错误：药物 A 是有用的，但我们没有拒绝原假设。结果：药物无法上市，公司损失了潜在的收入，病人失去了一种潜在的治疗方案。</p><p>两种结果，作为公司管理者的你，你会更希望减少哪一种错误的概率呢？显然是第1种。</p><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>我们做疾病筛查时，H0 和 Ha 分别是：</p><p>H0：病人没有疾病<br>Ha：病人有疾病</p><p>相关错误如下：</p><p>第1类错误：病人是没病的，被诊断为有病。病人痛哭流涕，但在之后的进一步检查中，病人发现自己并没有生病，虚惊一场，进而联想到生命的可贵，于是变成一个好父亲好丈夫。</p><p>第2类错误：病人是有病的，但原假设没有被拒绝，病人不知道自己生病了，于是逍遥快活，错过了治疗时机，然后症状变严重时，才进一步检查，发现得了病。</p><p>在这个例子里，你会更希望减少哪一类错误的概率呢？显然是第2种。在 HIV 检测中，false negative 确实比 false positve 更少见。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>在实际研究中，我们可以降低两类错误的概率：</p><ol><li>第1类错误：通过选择更低的 significant level</li><li>第2类错误：通过扩大样本量或选择单侧检验</li></ol><p>样本量足够大的时候，我们总是能把两类错误的概率降到足够低。但在实际应用中，更大的样本意味着成本：时间成本和金钱成本。</p><p>以 A/B 测试为例，只要样本量足够大，一定发现更好的方案。但产品有自己的迭代计划，每个产品有一系列的 A/B 测试需要做，不可能等每一个测试出现结果。这个时候就必须为了效率牺牲准确性。</p><p>有的领域，准确性非常非常重要，比如治疗癌症的药物研究，那是人命关天的事情，而且每天都在烧钱，真的是字面意义上的烧钱。</p><p>相比之下，互联网产品的容错率还是很高的。业界能够接受的标准一般是：</p><ul><li>5%的犯一类错误的概率</li><li>20%的犯二类错误的概率</li></ul><p>一般的产品按照这个标准去做研究，不会有大问题。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/15/type-one-error/plot_0.jpg&quot; class=&quot;&quot; title=&quot;题图&quot;&gt;
&lt;p&gt;统计学里有两个基石一样的概念：一类错误和二类错误。这两个概念是统计检验的基础。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计理论" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>R 语言里常用的分布函数</title>
    <link href="http://yoursite.com/2020/01/13/r-dist-func/"/>
    <id>http://yoursite.com/2020/01/13/r-dist-func/</id>
    <published>2020-01-13T16:59:44.000Z</published>
    <updated>2020-01-22T19:42:39.787Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文小结 R 语言里涉及概率分布的几个函数。</p><p>每个概率分布函数在 R 里都有4个对应的函数，分别以1个字母开头：</p><ul><li>d：表示 density，指概率密度函数 probability density function (pdf)</li><li>p：表示 probability，指累计分布函数 cumulative density function (cdf)</li><li>q: 表示 quantile，是 cdf 的逆函数</li><li>r：表示 random，符合该概率分布的随机数</li></ul><p>如果你像我一样已经不记得概率论的老师长啥样，上个的一些名词应该会让你一头雾水。没关系，我们接下来就用 R 代码一一测试。</p><p><a id="more"></a></p><h2 id="二项分布-Binomial-Distribution"><a href="#二项分布-Binomial-Distribution" class="headerlink" title="二项分布 Binomial Distribution"></a>二项分布 Binomial Distribution</h2><p>我们先以二项分布作为例子。二项分布是一个离散随机变量。</p><p>二项分布描述的问题是：每次试验有两个结果，成功或失败，n 次试验后成功 k 次的概率有多少？</p><p>R 语言里是 binom。</p><h3 id="dbinom"><a href="#dbinom" class="headerlink" title="dbinom"></a>dbinom</h3><p><code>dbinom(x, size, prob)</code> 就是计算概率的公式，其中：</p><ul><li>x：成功次数</li><li>size：总试验次数</li><li>prob：单次试验的成功概率</li></ul><p>比如，扔5次硬币，正面2次的概率可以计算为：</p><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbinom(<span class="number">2</span>, size=<span class="number">5</span>, prob=<span class="number">0.5</span>) </span><br></pre></td></tr></tbody></table></figure><p>结果：0.3125</p><h3 id="pbinom"><a href="#pbinom" class="headerlink" title="pbinom"></a>pbinom</h3><p><code>pbinom(q, size, prob)</code> 是计算累计概率的函数，其中 q 是 quantile。</p><p>例子：扔5次硬币，最多有1次正面的概率是对少？(即0次或1次)</p><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pbinom(<span class="number">1</span>, size=<span class="number">5</span>, prob=<span class="number">0.5</span>) </span><br></pre></td></tr></tbody></table></figure><p>答案：0.1875。</p><p>我们可以用 <code>dbinom(0, 5, 0.5) + dbinom(1, 5, 0.5)</code> 来做验证</p><h3 id="qbinom"><a href="#qbinom" class="headerlink" title="qbinom"></a>qbinom</h3><p><code>qbinom</code> 是 <code>pbinom</code> 的逆函数。我可以计算累计概率为 p 的对应 quntile 是多少。</p><p>使用刚才的0.1875去计算：</p><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qbinom(<span class="number">0.1875</span>, size=<span class="number">5</span>, prob=<span class="number">0.5</span>) </span><br></pre></td></tr></tbody></table></figure><p>我们应该得到 1。</p><h3 id="rbinom"><a href="#rbinom" class="headerlink" title="rbinom"></a>rbinom</h3><p><code>rbinom(n, size, prob)</code> 给出 n 个符合二项分布的随机数。</p><p>我们刚才计算了扔5次硬币时，成功2次的概率是 0.3125。</p><p>现在我们分别生成100、1000和10000个随机数，看看 x = 2 的频率是不是接近这个数字。</p><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">123</span>)</span><br><span class="line">sum(rbinom(<span class="number">100</span>, <span class="number">5</span>, <span class="number">0.5</span>) == <span class="number">2</span>) / <span class="number">100</span>  <span class="comment"># 0.28</span></span><br><span class="line">sum(rbinom(<span class="number">1000</span>, <span class="number">5</span>, <span class="number">0.5</span>) == <span class="number">2</span>) / <span class="number">1000</span>   <span class="comment"># 0.294</span></span><br><span class="line">sum(rbinom(<span class="number">10000</span>, <span class="number">5</span>, <span class="number">0.5</span>) == <span class="number">2</span>) / <span class="number">10000</span>  <span class="comment"># 0.3139</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到，随着随机次数的增加，成功2次的频率越来越接近理论值。</p><h2 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h2><p>正态分布是一个连续随机变量。</p><h3 id="dnorm"><a href="#dnorm" class="headerlink" title="dnorm"></a>dnorm</h3><p>dnorm(x) 计算 x 的对应概率密度函数值。这个函数用处不大。因为连续随机变量在某一点的概率为 0。</p><p>这个函数的唯一用处，大概是方便大家画出概率密度函数图。</p><h3 id="pnorm"><a href="#pnorm" class="headerlink" title="pnorm"></a>pnorm</h3><p><code>pnorm(5)</code> 实际上就是  P(X &lt;= 5)，计算了 X 小于等于5的概率。</p><p>所以，<code>pnorm(0)</code> 的结果是0.5，标准正态分布的一半嘛。</p><p>如果想计算期望等于1，标准差等于2的正太分布在 -3 &lt; x &lt;= 0 的概率呢？</p><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnorm(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>) - pnorm(-<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果：0.2857874</p><h3 id="qnorm"><a href="#qnorm" class="headerlink" title="qnorm"></a>qnorm</h3><p><code>qnorm</code> 是 <code>pnorm</code> 的逆函数。<br>因为 pnorm(0)等于0.5，所以 qnorm(0.5)肯定等于0，不信你试试 :) 。</p><h3 id="rnorm"><a href="#rnorm" class="headerlink" title="rnorm"></a>rnorm</h3><p><code>rnorm</code> 生成一组符合正态分布的随机数。</p><p>我们可以生成1000个数据，然后画图看看效果。</p><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n1000 &lt;- rnorm(<span class="number">1000</span>, mean = <span class="number">70</span>, sd = <span class="number">5</span>)</span><br><span class="line">hist(n1000, breaks = <span class="number">20</span>)</span><br></pre></td></tr></tbody></table></figure><p>确实很符合正态分布。</p><img src="/blog/2020/01/13/r-dist-func/hist.png" class="" title="直方图-例子"><p><code>rnorm</code> 是个好伙伴，在 simulation study 时用得非常多。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文小结 R 语言里涉及概率分布的几个函数。&lt;/p&gt;
&lt;p&gt;每个概率分布函数在 R 里都有4个对应的函数，分别以1个字母开头：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;d：表示 density，指概率密度函数 probability density function (pdf)&lt;/li&gt;
&lt;li&gt;p：表示 probability，指累计分布函数 cumulative density function (cdf)&lt;/li&gt;
&lt;li&gt;q: 表示 quantile，是 cdf 的逆函数&lt;/li&gt;
&lt;li&gt;r：表示 random，符合该概率分布的随机数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你像我一样已经不记得概率论的老师长啥样，上个的一些名词应该会让你一头雾水。没关系，我们接下来就用 R 代码一一测试。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://yoursite.com/categories/Coding/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
</feed>
