<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>商业与数据</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-23T18:34:35.887Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yu Qin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>t-test</title>
    <link href="http://yoursite.com/2020/01/23/t-test/"/>
    <id>http://yoursite.com/2020/01/23/t-test/</id>
    <published>2020-01-23T16:49:49.000Z</published>
    <updated>2020-01-23T18:34:35.887Z</updated>
    
    <content type="html"><![CDATA[<p>T-test 应该是统计学里学习的第1个检验，可谓大家的统计学初恋。</p><p>T-test 可以用来：</p><ul><li>比较一个总体的均值和一个常数</li><li>比较两个总体的均值</li></ul><p>这篇文章介绍如何用 R 做 t-test。</p><p><a id="more"></a></p><h2 id="R-函数"><a href="#R-函数" class="headerlink" title="R 函数"></a>R 函数</h2><p>R 提供了 <code>t.test</code> 函数来做 t-test，非常直观。</p><h3 id="t-test-同方差"><a href="#t-test-同方差" class="headerlink" title="t-test: 同方差"></a>t-test: 同方差</h3><p>我们随机生成两个标准正态分布，然后调用 <code>t.test</code> 做个检测。</p><p>原假设：两个分布的均值相等<br>备择假设：两个分布的均值不同</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- rnorm(<span class="number">50</span>)</span><br><span class="line">y &lt;- rnorm(<span class="number">30</span>)</span><br><span class="line">ts &lt;- t.test(x, y, var.equal = <span class="literal">TRUE</span>)  </span><br><span class="line">ts</span><br></pre></td></tr></tbody></table></figure><p>注意 <code>t.test</code> 函数里的 <code>var.equal = TRUE</code>，我们的检测假设两个分布的方差相同。</p><p>返回结果如下：<br></p><figure class="highlight r"><table><tbody><tr><td class="code"><pre><span class="line">Two Sample t-test</span><br><span class="line"></span><br><span class="line">data:  x and y</span><br><span class="line marked">t = -<span class="number">0.83616</span>, df = <span class="number">78</span>, p-value = <span class="number">0.4056</span></span><br><span class="line">alternative hypothesis: true difference <span class="keyword">in</span> means is not equal to <span class="number">0</span></span><br><span class="line"><span class="number">95</span> percent confidence interval:</span><br><span class="line"> -<span class="number">0.5532166</span>  <span class="number">0.2259611</span></span><br><span class="line">sample estimates:</span><br><span class="line">mean of x mean of y </span><br><span class="line"><span class="number">0.1215518</span> <span class="number">0.2851795</span> </span><br></pre></td></tr></tbody></table></figure><p></p><p>可以看到 p-value 很大，我们不能拒绝原假设。</p><h3 id="t-test：异方差"><a href="#t-test：异方差" class="headerlink" title="t-test：异方差"></a>t-test：异方差</h3><p>上面的 t.test 假设两个分布的方差相同，我们知道这个假设成立，因为是我们自己生成的随机数。</p><p>如果两个分布的方差不相同呢？</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- rnorm(<span class="number">50</span>, mean = <span class="number">0</span>, sd = <span class="number">3</span>)</span><br><span class="line">y &lt;- rnorm(<span class="number">30</span>, mean = <span class="number">0</span>, sd = <span class="number">10</span>)</span><br><span class="line">ts &lt;- t.test(x, y)  </span><br><span class="line">ts</span><br></pre></td></tr></tbody></table></figure><p>我们删除了 <code>t.test</code> 里的 <code>var.equal = TRUE</code>。</p><p>结果如下：<br>返回结果如下：<br></p><figure class="highlight r"><table><tbody><tr><td class="code"><pre><span class="line marked">Welch Two Sample t-test</span><br><span class="line"></span><br><span class="line">data:  x and y</span><br><span class="line">t = <span class="number">0.8916</span>, df = <span class="number">32.443</span>, p-value = <span class="number">0.3792</span></span><br><span class="line">alternative hypothesis: true difference <span class="keyword">in</span> means is not equal to <span class="number">0</span></span><br><span class="line"><span class="number">95</span> percent confidence interval:</span><br><span class="line"> -<span class="number">1.964907</span>  <span class="number">5.027061</span></span><br><span class="line">sample estimates:</span><br><span class="line"> mean of x  mean of y </span><br><span class="line"> <span class="number">0.4192239</span> -<span class="number">1.1118530</span> </span><br></pre></td></tr></tbody></table></figure><p></p><p>注意第一行的检测名称跟之前不一样了。</p><p>如果想要假设两个样本的方差是否一样，可以考虑使用 F-test，在 R 里是 <code>var.test</code> 函数。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>父母的学历（只算最高一方）会影响孩子的成绩吗？研究者搜集了相关数据：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">colleage_grads &lt;- c(<span class="number">485</span>, <span class="number">534</span>, <span class="number">650</span>, <span class="number">554</span>, <span class="number">550</span>, <span class="number">572</span>, <span class="number">497</span>, <span class="number">592</span>, <span class="number">487</span>, <span class="number">533</span>, <span class="number">526</span>, <span class="number">410</span>, <span class="number">515</span>, <span class="number">578</span>, <span class="number">448</span>, <span class="number">469</span>)</span><br><span class="line">high_school_grads &lt;- c(<span class="number">442</span>, <span class="number">580</span>, <span class="number">479</span>, <span class="number">486</span>, <span class="number">528</span>, <span class="number">524</span>, <span class="number">492</span>, <span class="number">478</span>, <span class="number">425</span>, <span class="number">485</span>, <span class="number">390</span>, <span class="number">535</span>)</span><br></pre></td></tr></tbody></table></figure><p>注意，上面两组 vector 的长度不一样。</p><p>针对研究问题，我们的原假设是：</p><p>H0：父母是高中学历的学生的考试成绩均值 = 父母是大学学历的学生的考试成绩均值<br>Ha：父母是高中学历的学生的考试成绩均值 != 父母是大学学历的学生的考试成绩均值</p><p>我们选定显著性水平为 5%。</p><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><p>在做进一步研究前，我们应该先看看两组数据的分布：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整理做图需要的 long format</span></span><br><span class="line">df &lt;- data.frame(</span><br><span class="line">  value = c(colleage_grads, high_school_grads),</span><br><span class="line">  parent_deg = c(</span><br><span class="line">    rep(<span class="string">'大学'</span>, length(colleage_grads)),</span><br><span class="line">    rep(<span class="string">'高中'</span>, length(high_school_grads))</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 ggplot2 做图</span></span><br><span class="line">ggplot(df, aes(x = parent_deg, y = value)) + </span><br><span class="line">  geom_boxplot() +</span><br><span class="line">  theme_classic(<span class="number">14</span>) + </span><br><span class="line">  labs(x = <span class="string">'父母最高学历'</span>,</span><br><span class="line">       y = <span class="string">'小孩的SAT成绩'</span>)</span><br></pre></td></tr></tbody></table></figure><p>图片如下：</p><p><img src="/blog/2020/01/23/t-test/boxplot.png" class="" title="boxplot"></p><p>可以看到“大学”组的 box 比“高中”组更高，但这个差距是否具有统计显著性呢？</p><h3 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h3><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.test(colleage_grads, high_school_grads)  </span><br></pre></td></tr></tbody></table></figure><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Welch Two Sample t-test</span><br><span class="line"></span><br><span class="line">data:  colleage_grads and high_school_grads</span><br><span class="line marked">t = <span class="number">1.8038</span>, df = <span class="number">25.34</span>, p-value = <span class="number">0.08317</span></span><br><span class="line">alternative hypothesis: true difference <span class="keyword">in</span> means is not equal to <span class="number">0</span></span><br><span class="line"><span class="number">95</span> percent confidence interval:</span><br><span class="line"> -<span class="number">5.359164</span> <span class="number">81.359164</span></span><br><span class="line">sample estimates:</span><br><span class="line">mean of x mean of y </span><br><span class="line">      <span class="number">525</span>       <span class="number">487</span> </span><br></pre></td></tr></tbody></table></figure><p>p-value = 0.08，大于我们商量好的显著性水平 0.05，所以我们无法拒绝原假设。</p><p>虽然从图片来看，学历会对小孩成绩有影响，但数据表现出的差异并不能通过显著性检验。我们无法做出“父母学历会对小孩成绩有影响”的判断。</p><p>这个例子很好，它说明了一个重要的道理：<strong>不要仅仅依靠数据可视化做判断</strong>。</p><blockquote><p>数据可视化代替不了统计检验。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;T-test 应该是统计学里学习的第1个检验，可谓大家的统计学初恋。&lt;/p&gt;
&lt;p&gt;T-test 可以用来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比较一个总体的均值和一个常数&lt;/li&gt;
&lt;li&gt;比较两个总体的均值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章介绍如何用 R 做 t-test。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计理论" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>对两个样本的方差做统计检验</title>
    <link href="http://yoursite.com/2020/01/23/test-two-variance/"/>
    <id>http://yoursite.com/2020/01/23/test-two-variance/</id>
    <published>2020-01-23T15:22:15.000Z</published>
    <updated>2020-01-23T18:34:35.887Z</updated>
    
    <content type="html"><![CDATA[<p>最近在工作上遇到一个问题：如何评估两个买量渠道的质量。</p><p>一般来说，最好的指标是如下几个：</p><ul><li>LTV：越高越好</li><li>CPI：越低越好</li><li>量级：越大越好</li></ul><p>游戏最关心的是 LTV（用户生命周期价值）。我们日常定义的 LTV 是个均值，但实际上它应该是个分布。描述两个分布时，除了期望（均值），我们还关心方差。</p><p>假设两个渠道的 LTV 一样，则方差越低的渠道效果越好，因为渠道回收的不确定性更低。</p><p>这篇文章介绍如何在 R 里对两个方差做统计检验。</p><p><a id="more"></a></p><h2 id="在-R-里做-F-test"><a href="#在-R-里做-F-test" class="headerlink" title="在 R 里做 F-test"></a>在 R 里做 F-test</h2><p>当两个样本都符合正态分布时，可以用 F-test 检查两个样本的方差是否一样。</p><p>在 R 里做 F-test 的函数是 <code>var.test</code>。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- rnorm(<span class="number">50</span>, mean = <span class="number">0</span>, sd = <span class="number">2</span>)</span><br><span class="line">y &lt;- rnorm(<span class="number">30</span>, mean = <span class="number">1</span>, sd = <span class="number">1</span>)</span><br><span class="line">var.test(x, y)  </span><br></pre></td></tr></tbody></table></figure><p>我们会发现 p-value 远远小于0。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>衡量机器质量的重要指标是产品的方差不会太高。给定两台机器和两台机器的一组产品，我们想判断是否两台机器的质量一样。</p><p>H0：两台机器产品的方差一样<br>Ha：两台机器产品的方差不一样</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">machine_1 &lt;- c(<span class="number">2.95</span>, <span class="number">3.45</span>, <span class="number">3.5</span>, <span class="number">3.75</span>, <span class="number">3.48</span>, <span class="number">3.26</span>, <span class="number">3.33</span>, <span class="number">3.2</span>,</span><br><span class="line">               <span class="number">3.16</span>, <span class="number">3.2</span>, <span class="number">3.22</span>, <span class="number">3.38</span>, <span class="number">3.9</span>, <span class="number">3.36</span>,  <span class="number">3.25</span>, <span class="number">3.28</span>,</span><br><span class="line">               <span class="number">3.2</span>, <span class="number">3.22</span>, <span class="number">2.98</span>, <span class="number">3.45</span>, <span class="number">3.7</span>, <span class="number">3.34</span>, <span class="number">3.18</span>, <span class="number">3.35</span>, <span class="number">3.12</span>)</span><br><span class="line"></span><br><span class="line">machine_2 &lt;- c(<span class="number">3.22</span>, <span class="number">3.3</span>, <span class="number">3.34</span>, <span class="number">3.28</span>, <span class="number">3.29</span>, <span class="number">3.25</span>, <span class="number">3.3</span>, <span class="number">3.27</span>,</span><br><span class="line">               <span class="number">3.38</span>, <span class="number">3.34</span>, <span class="number">3.35</span>, <span class="number">3.19</span>, <span class="number">3.35</span>, <span class="number">3.05</span>, <span class="number">3.36</span>, <span class="number">3.28</span>,</span><br><span class="line">               <span class="number">3.3</span>, <span class="number">3.28</span>, <span class="number">3.3</span>, <span class="number">3.2</span>, <span class="number">3.16</span>, <span class="number">3.33</span>)</span><br></pre></td></tr></tbody></table></figure><p>上面的数据来自 Statistics for Business and Economics 一书的习题。</p><h3 id="做图"><a href="#做图" class="headerlink" title="做图"></a>做图</h3><p>我们可以先做图看看分布：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(value = c(machine_1, machine_2),</span><br><span class="line">                 machine = c(rep(<span class="string">'machine_1'</span>, length(machine_1)),</span><br><span class="line">                             rep(<span class="string">'machine_2'</span>, length(machine_2))))</span><br><span class="line"></span><br><span class="line">df %&gt;% ggplot(aes(x = value, fill = machine)) + </span><br><span class="line">  geom_density() +</span><br><span class="line">  scale_fill_manual(values = alpha(c(<span class="string">'blue'</span>, <span class="string">'red'</span>), <span class="number">0.5</span>)) +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>,</span><br><span class="line">       fill = <span class="literal">NULL</span>) + </span><br><span class="line">  theme_classic(<span class="number">14</span>) +</span><br><span class="line">  theme(legend.position = <span class="string">'top'</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果如图：</p><p><img src="/blog/2020/01/23/test-two-variance/plot_density.png" class="" title="density"></p><p>在图片里可以看到两个机器的分布确实不太一样，机器1的方差明显要大一些。</p><h3 id="F-test"><a href="#F-test" class="headerlink" title="F-test"></a>F-test</h3><p>使用 <code>var.test</code> 对两组数据做检测。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var.test(machine_1, machine_2)  </span><br></pre></td></tr></tbody></table></figure><p>结果：p-value = 0.000007，我们非常有把握拒绝原假设。结论：两台机器的方差不一样。</p><h2 id="引申：非正态分布呢？"><a href="#引申：非正态分布呢？" class="headerlink" title="引申：非正态分布呢？"></a>引申：非正态分布呢？</h2><p>F-test 的一个重要前提是：两个样本符合正态分布。再看我最开始提出的问题：不同渠道 LTV 的方差是否一致。这个问题能够用 F-test 吗？</p><p>如果你对游戏用户的 LTV 有所了解就会知道，LTV 分布不是正态分布。所以，我不能用 F-test 处理上面的问题。</p><p>如果真的想要解决这个问题，我会这样做：</p><ol><li>Google 查询 compare variances of non-normal data</li><li>找到教程或大家对这个问题的讨论</li><li>寻找能满足自己需求的方法、并找到 R 代码</li><li>测试</li></ol><p>简单搜索之后就会定位到这个页面：<a href="http://www.sthda.com/english/wiki/compare-multiple-sample-variances-in-r#statistical-tests-for-comparing-variances" target="_blank" rel="noopener">Compare Multiple Sample Variances in R</a>。它提供了偏离正态假设时也会比较健壮的 test：</p><ul><li>Levene’s test</li><li>Fligner-Killeen test</li></ul><p>接下来就按照上面的步骤走就可以了。</p><blockquote><p>重要的不是解决问题的方法，而是寻找解决方法的能力。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在工作上遇到一个问题：如何评估两个买量渠道的质量。&lt;/p&gt;
&lt;p&gt;一般来说，最好的指标是如下几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LTV：越高越好&lt;/li&gt;
&lt;li&gt;CPI：越低越好&lt;/li&gt;
&lt;li&gt;量级：越大越好&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;游戏最关心的是 LTV（用户生命周期价值）。我们日常定义的 LTV 是个均值，但实际上它应该是个分布。描述两个分布时，除了期望（均值），我们还关心方差。&lt;/p&gt;
&lt;p&gt;假设两个渠道的 LTV 一样，则方差越低的渠道效果越好，因为渠道回收的不确定性更低。&lt;/p&gt;
&lt;p&gt;这篇文章介绍如何在 R 里对两个方差做统计检验。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计理论" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>Test of Independence</title>
    <link href="http://yoursite.com/2020/01/23/test-of-independence/"/>
    <id>http://yoursite.com/2020/01/23/test-of-independence/</id>
    <published>2020-01-23T11:26:24.000Z</published>
    <updated>2020-01-23T18:34:35.887Z</updated>
    
    <content type="html"><![CDATA[<p>在产品运营中，我们经常需要关心如下问题：</p><ul><li>F2P游戏：用户的是否付费与性别相关吗？</li><li>电子杂志：用户是否订阅与手机类型相关吗？</li><li>懂球帝 App：用户是否推荐新闻与自己的球队是否赢球相关吗？</li></ul><p>以上问题有个共性：判断两个 categorical variable 是否相关。</p><p>这个时候，我们可以用 chi-square test 做 test of independence。</p><p><a id="more"></a></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>某杂志调查了公务出行人群在出差时的航班选择，得到数据如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:center">国内航班</th><th style="text-align:center">国际航班</th></tr></thead><tbody><tr><td style="text-align:left">头等舱</td><td style="text-align:center">29</td><td style="text-align:center">22</td></tr><tr><td style="text-align:left">商务舱</td><td style="text-align:center">95</td><td style="text-align:center">121</td></tr><tr><td style="text-align:left">经济舱</td><td style="text-align:center">518</td><td style="text-align:center">135</td></tr></tbody></table></div><p>提问：旅行目的地与机票类型相互独立吗？</p><p>假设检验如下：</p><ul><li>H0:旅行目的地与机票类型相互独立</li><li>Ha：旅行目的地与机票类型不相互独立</li></ul><p>我们选定的显著性水平是 5%。</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>我们先生成需要的数据：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ma &lt;- matrix(data = c(<span class="number">29</span>, <span class="number">95</span>, <span class="number">518</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">135</span>), nrow = <span class="number">3</span>)</span><br><span class="line">df &lt;- data.frame(ma)</span><br><span class="line">names(df) &lt;- c(<span class="string">'国内航班'</span>, <span class="string">'国际航班'</span>)</span><br><span class="line">row.names(df) &lt;- c(<span class="string">'头等舱'</span>, <span class="string">'商务舱'</span>, <span class="string">'经济舱'</span>)</span><br></pre></td></tr></tbody></table></figure><p>在 R 里做 chi-square test 可以直接用 matrix 对象，但我们还想做图看看，所以生成了一个 data.frame。</p><h3 id="做图"><a href="#做图" class="headerlink" title="做图"></a>做图</h3><p>按照一般步骤，我们可以先做个柱状图看看。</p><p>先把数据变成 ggplot 需要的 long format。<br></p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_long &lt;- df %&gt;%</span><br><span class="line">  mutate(ticket_type = row.names(df)) %&gt;%</span><br><span class="line">  gather(<span class="string">'flight_type'</span>, <span class="string">'value'</span>, -ticket_type)</span><br></pre></td></tr></tbody></table></figure><p></p><p>然后做图：<br></p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ggplot(df_long, aes(x = ticket_type, y = value, fill = flight_type)) + </span><br><span class="line">  geom_bar(stat = <span class="string">'identity'</span>, position = <span class="string">'dodge'</span>) +</span><br><span class="line">  scale_x_discrete(limits = c(<span class="string">'头等舱'</span>, <span class="string">'商务舱'</span>, <span class="string">'经济舱'</span>)) +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>, y = <span class="literal">NULL</span>, fill = <span class="literal">NULL</span>) +</span><br><span class="line">  theme_classic(<span class="number">14</span>) +</span><br><span class="line">  scale_fill_brewer(palette=<span class="string">'Set2'</span>)</span><br></pre></td></tr></tbody></table></figure><p></p><p>如下图：</p><p><img src="/blog/2020/01/23/test-of-independence/plot_bar.png" class="" title="plot"></p><p>可以看到对经济舱来说，国内航班的数量明显高于国内航班。</p><p>我们还可以从另一个视角查看（代码略）：</p><p><img src="/blog/2020/01/23/test-of-independence/plot_2.png" class="" title="plot"></p><p>这里能更清晰地看到，国内航班跟国外航班的“图片形状”不太一样。</p><p>我们可以推测出：两个变量不独立。接下来我们做统计检验。</p><h3 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h3><p>这里略过 <a href="https://online.stat.psu.edu/stat414/node/312/" target="_blank" rel="noopener">chi-squre test 的数学推导</a>，直接做检验。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chisq.test(ma)</span><br></pre></td></tr></tbody></table></figure><p>结果：p-value &lt; 2.2e-16。即使显著性水平是1%，我们也可以拒绝原假设。</p><p>我怀疑是因为国内经济舱的数量太多，才导致两个变量不独立。假设国内经济舱的数量从518变成145， 这个检验还能拒绝原假设吗？</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ma_2 &lt;- matrix(data = c(<span class="number">29</span>, <span class="number">95</span>, <span class="number">145</span>, <span class="number">22</span>, <span class="number">121</span>, <span class="number">135</span>), nrow = <span class="number">3</span>)</span><br><span class="line">chisq.test(ma_2)</span><br></pre></td></tr></tbody></table></figure><p>结果：p-value = 0.1164，不能拒绝原假设。跟我们的推测一致。</p><h2 id="优化一下柱状图"><a href="#优化一下柱状图" class="headerlink" title="优化一下柱状图"></a>优化一下柱状图</h2><p>这是一个跟 test of independence 不相关的话题：感觉这里的柱状图可以用极简风格优化一下。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ggplot(df_long, aes(x = ticket_type, y = value, fill = flight_type)) + </span><br><span class="line">  geom_bar(stat = <span class="string">'identity'</span>, position = <span class="string">'dodge'</span>) +</span><br><span class="line">  geom_text(aes(label = value), </span><br><span class="line">            color = <span class="string">'#444444'</span>,</span><br><span class="line">            position = position_dodge(<span class="number">0.9</span>),</span><br><span class="line">            vjust = -<span class="number">0.2</span>) +</span><br><span class="line">  scale_x_discrete(limits = c(<span class="string">'头等舱'</span>, <span class="string">'商务舱'</span>, <span class="string">'经济舱'</span>)) +</span><br><span class="line">  scale_y_continuous(expand = c(<span class="number">0</span>, <span class="number">0</span>), limits = c(<span class="number">0</span>, <span class="number">540</span>)) +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>, </span><br><span class="line">       y = <span class="literal">NULL</span>, </span><br><span class="line">       fill = <span class="literal">NULL</span>) +</span><br><span class="line">  theme_classic(<span class="number">14</span>) +</span><br><span class="line">  theme(legend.position = <span class="string">'top'</span>,</span><br><span class="line">        axis.ticks = element_blank(),</span><br><span class="line">        axis.line = element_blank(),</span><br><span class="line">        axis.text.y = element_blank()) +</span><br><span class="line">  scale_fill_brewer(palette=<span class="string">'Set2'</span>) </span><br></pre></td></tr></tbody></table></figure><p>做了如下几个事情：</p><ul><li>删除 x 轴的 axis.line, axis.ticks</li><li>删除 y 轴</li><li>缩短 bar 和 x 轴之间的 padding</li><li>在柱子上增加表示数量的 text</li><li>legend 移动到顶部</li></ul><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="/blog/2020/01/23/test-of-independence/plot_3.png" class="" title="plot"></p><p>还不错 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8">😃</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在产品运营中，我们经常需要关心如下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;F2P游戏：用户的是否付费与性别相关吗？&lt;/li&gt;
&lt;li&gt;电子杂志：用户是否订阅与手机类型相关吗？&lt;/li&gt;
&lt;li&gt;懂球帝 App：用户是否推荐新闻与自己的球队是否赢球相关吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上问题有个共性：判断两个 categorical variable 是否相关。&lt;/p&gt;
&lt;p&gt;这个时候，我们可以用 chi-square test 做 test of independence。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计理论" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>如何理解“置信区间”</title>
    <link href="http://yoursite.com/2020/01/23/conf-interval/"/>
    <id>http://yoursite.com/2020/01/23/conf-interval/</id>
    <published>2020-01-23T07:56:51.000Z</published>
    <updated>2020-01-23T18:34:35.879Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/2020/01/23/conf-interval/plot_0.png" class="" title="plot"></p><p>Google Play Store 对提供了商店页 A/B 测试功能，公司使用这个功能对新版商店页做了测试。测试结果会提供一个置信区间 confidence interval，同事很难理解置信区间的概念。</p><p>这篇文章尝试用普通人能理解的方式解释置信区间。</p><p><a id="more"></a></p><h2 id="理解“总体”和“样本”"><a href="#理解“总体”和“样本”" class="headerlink" title="理解“总体”和“样本”"></a>理解“总体”和“样本”</h2><p>先给定一个研究问题：中国人里多少人喜欢足球。</p><p>这个问题里，“总体”是全体中国人，大概14亿。我们不可能调查所有中国人，所以必须用抽样调查的方法，<strong>随机抽取</strong>一定数量的人获取他们的观点。</p><p>抽取到的这部分人，被称为“样本”。</p><p>我们会用“样本”数据去<strong>估计</strong>总体的情况。</p><h2 id="误差一定存在"><a href="#误差一定存在" class="headerlink" title="误差一定存在"></a>误差一定存在</h2><p>核心前提：<strong>即使是随机抽样，也会有误差</strong>。</p><p>硬币理论上是平均的，那么我们扔10次硬币，正反面刚好55开的概率是多大呢？这是个二项分布。可以用 R 计算：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbinom(<span class="number">5</span>, size=<span class="number">10</span>, prob=<span class="number">0.5</span>) </span><br></pre></td></tr></tbody></table></figure><p>结果：24.6%。只有不到1/4的概率，我们能观测到5次正面和5次反面。所以，随机抽样无法避免误差。</p><p>随机调查1000个中国人，其中有12%的人喜欢足球，这个12%很大可能不是中国人喜欢足球的真实比率。</p><p>那么，我们如何根据这1000个人确定到底有多少中国人喜欢足球呢？</p><h2 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h2><p>这时统计学就发挥作用了。根据<strong>中心极限定理</strong>，在样本量足够大且抽样随机时，点估计值符合正态分布，且我们知道这个正态分布的标准差和均值。分布的均值就是样本的估计值，标准差可以用一个公式计算。</p><p>上面的表达比较抽象。更直接地说，对1000个人抽样是否喜欢足球的结果，可以让我们画出如下的正态分布图片：</p><p><img src="/blog/2020/01/23/conf-interval/plot_estimate_dist.png" class="" title="plot"></p><p>这个分布的均值是0.12，标准差是0.0103（用某个公式计算出，这里不讨论）。</p><h2 id="分布函数的特征"><a href="#分布函数的特征" class="headerlink" title="分布函数的特征"></a>分布函数的特征</h2><p>一旦我们有了分布函数，我们就可以计算：</p><ul><li>给定 x 范围，对应的概率是多少</li><li>给定一个概率，以均值为中心时，x 的上限和下限各是多少</li></ul><h3 id="用两个例子计算"><a href="#用两个例子计算" class="headerlink" title="用两个例子计算"></a>用两个例子计算</h3><p>对标准正态分布， - 1 &lt; x &lt; 1 的概率是多少呢？</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnorm(<span class="number">1</span>) - pnorm(-<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果：68%。</p><p>对一个均值为3，标准差是0.5的正态分布，90%概率对应的上下限各是多少呢？</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">upper_x &lt;- qnorm(<span class="number">0.95</span>, <span class="number">3</span>, sd = <span class="number">0.5</span>)</span><br><span class="line">lower_x &lt;- qnorm(<span class="number">0.05</span>, <span class="number">3</span>, sd = <span class="number">0.5</span>)</span><br></pre></td></tr></tbody></table></figure><p>这里计算出的结果是：3.82 和 2.71，也就是说，该分布从 x = 2.71 到 x = 3.82 的部分，概率是90%。</p><h3 id="计算调查数据"><a href="#计算调查数据" class="headerlink" title="计算调查数据"></a>计算调查数据</h3><p>用这样的计算方法，我们可以计算刚才调查1000个中国人的数据。</p><p>我们从刚才的正态分布里找到一个上限和一个下限，让这之间的概率是 95%。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sd &lt;- sqrt(<span class="number">0.12</span> * <span class="number">0.88</span> / <span class="number">1000</span>)</span><br><span class="line">upper_x &lt;- qnorm(<span class="number">0.975</span>, <span class="number">0.12</span>, sd = sd)</span><br><span class="line">lower_x &lt;- qnorm(<span class="number">0.025</span>, <span class="number">0.12</span>, sd = sd)</span><br></pre></td></tr></tbody></table></figure><p>我们得到下限是 0.1，上限是 0.14。</p><p>如下图（偷懒不用 R 做图了）：</p><p><img src="/blog/2020/01/23/conf-interval/plot_estimate_dist2.png" class="" title="plot"></p><p>根据这个计算，我们有95%的把握做出如下判断：10%到14%这个区间内包含中国人喜欢足球的真实比例。</p><p>严格地说，我们不能这样表达：中国人喜欢足球的真实比例有95%的概率落在10%到14%之间。这是个很微妙的区别，有兴趣的同学可以<a href="https://www.graphpad.com/guides/prism/7/statistics/stat_more_about_confidence_interval.htm?toc=0&amp;printWindow" target="_blank" rel="noopener">进一步深究</a>。从业务角度来说，这个表达也是可以接受的，而且按照我个人经验，同事会更容易理解这个表达。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>那么，到底什么是置信区间呢？</p><p>如果我们有一个95%的置信区间，我们可以说，有95%的把握真实值落在置信区间内。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/2020/01/23/conf-interval/plot_0.png&quot; class=&quot;&quot; title=&quot;plot&quot;&gt;&lt;/p&gt;
&lt;p&gt;Google Play Store 对提供了商店页 A/B 测试功能，公司使用这个功能对新版商店页做了测试。测试结果会提供一个置信区间 confidence interval，同事很难理解置信区间的概念。&lt;/p&gt;
&lt;p&gt;这篇文章尝试用普通人能理解的方式解释置信区间。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计理论" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>模拟“中心极限定理” - 比例篇</title>
    <link href="http://yoursite.com/2020/01/22/simu-clt-2/"/>
    <id>http://yoursite.com/2020/01/22/simu-clt-2/</id>
    <published>2020-01-22T19:13:45.000Z</published>
    <updated>2020-01-23T18:34:35.887Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇模拟了均值的中心极限定理，这一篇再扩展一下。</p><p>中心极限定理不只适用于均值，还可用于对“占比”的描述。什么是占比呢？</p><p>例子：</p><ul><li>总统选举中候选人 A 的支持率</li><li>App Store 落地页的下载转化率</li><li>认为 Google 股票会上涨的股民比例</li><li>…</li></ul><p>在互联网行业，这个指标最重要的应用应该是各种转化率。</p><p>中心极限定理公诉我们，当样本足够大时，样本的比例符合正态分布。</p><p>该分布的均值等于总体的分布：</p><p><img src="/blog/2020/01/22/simu-clt-2/mean.png" class="" title="mean_of_sample_dist"></p><p>该分布的标准差可以用如下公式计算：<br><img src="/blog/2020/01/22/simu-clt-2/se.png" class="" title="se_of_sample_dist"></p><p>接下来我们模拟 proportion 的中心极限定理。</p><p><a id="more"></a></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>假设某 app 有100万个用户，该 app 想上线一个新功能，但直接全量上线是不太好，风险太大。</p><p>为了测试这个新功能是否受欢迎，产品经理决定先让一部分用户试用，然后再对他们做调查，提问他们是否喜欢这个功能。</p><p>根据中心极限定理，样本量越大越符合正态分布，且方差越小。我们模拟不同样本量下的估计值的分布。</p><h2 id="R-代码"><a href="#R-代码" class="headerlink" title="R 代码"></a>R 代码</h2><p>代码跟上一篇差不多。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(tidyverse)</span><br><span class="line"><span class="keyword">library</span>(ggpubr)</span><br><span class="line"></span><br><span class="line">set.seed(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">pop_size &lt;- <span class="number">1000000</span></span><br><span class="line">pop_player &lt;- c(rep(<span class="string">"like"</span>, <span class="number">0.7</span> * pop_size), rep(<span class="string">"dislike"</span>, <span class="number">0.3</span> * pop_size))</span><br></pre></td></tr></tbody></table></figure><p>准备需要的 package，并定好随机数。然后创建100万名用户，其中有70%的人会喜欢新功能，有30%的人会不喜欢。</p><h3 id="函数：抽样、模拟、做图"><a href="#函数：抽样、模拟、做图" class="headerlink" title="函数：抽样、模拟、做图"></a>函数：抽样、模拟、做图</h3><p>这段代码跟上一篇差不多：</p><ul><li><code>sample_player</code> 进行一次抽样，可以选择抽样人数</li><li><code>simulate_df</code> 模拟 n 次实验</li><li><code>draw_plot</code> 对 n 次实验的结果做图</li><li><code>simulate_and_draw</code> 封装了上面几个函数</li></ul><p>针对这篇的主题，某些地方做了调整。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">sample_player &lt;- <span class="keyword">function</span>(size) {</span><br><span class="line">  sample_vec &lt;- sample(pop_player, size = size)</span><br><span class="line">  sum(sample_vec == <span class="string">"like"</span>) / size</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">simulate_df &lt;- <span class="keyword">function</span>(size, n) {</span><br><span class="line">  df &lt;- data.frame(sample_prop = rep(<span class="number">0</span>, n))</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:n) {</span><br><span class="line">    df[i, <span class="number">1</span>] &lt;- sample_player(size)</span><br><span class="line">  }</span><br><span class="line">  df</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">draw_plot &lt;- <span class="keyword">function</span>(df, size, bin_width=<span class="number">0.1</span>) {</span><br><span class="line">  stan_dev &lt;- round(sd(df$sample_prop), <span class="number">2</span>)</span><br><span class="line">  ggplot(df, aes(x = sample_prop)) + </span><br><span class="line">    geom_histogram(binwidth = bin_width) +</span><br><span class="line">    scale_x_continuous(labels = scales::percent,</span><br><span class="line">                       limits = c(<span class="number">0</span>: <span class="number">1</span>)) +</span><br><span class="line">    labs(title = str_c(<span class="string">'调查'</span>, size, <span class="string">'个玩家'</span>),</span><br><span class="line">         subtitle = str_c(<span class="string">'点估计标准差 = '</span>, stan_dev),</span><br><span class="line">         x = <span class="string">'表示"喜欢的"玩家占比'</span>,</span><br><span class="line">         y = <span class="string">'频数'</span>) </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">simulate_and_draw &lt;- <span class="keyword">function</span>(size, n = <span class="number">5000</span>, bin_width = <span class="number">0.1</span>) {</span><br><span class="line">  simulate_df(size, n) %&gt;%</span><br><span class="line">  draw_plot(size, bin_width)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="做图"><a href="#做图" class="headerlink" title="做图"></a>做图</h3><p>下面计算抽样5人、10人、20人、40人、100人和1000人的情况，为了节约运算时间，模拟5000轮：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p1 &lt;- simulate_and_draw(<span class="number">5</span>, bin_width = <span class="number">0.1</span>)</span><br><span class="line">p2 &lt;- simulate_and_draw(<span class="number">10</span>, bin_width = <span class="number">0.05</span>)</span><br><span class="line">p3 &lt;- simulate_and_draw(<span class="number">20</span>, bin_width = <span class="number">0.05</span>)</span><br><span class="line">p4 &lt;- simulate_and_draw(<span class="number">40</span>, bin_width = <span class="number">0.025</span>)</span><br><span class="line">p5 &lt;- simulate_and_draw(<span class="number">100</span>, bin_width = <span class="number">0.01</span>)</span><br><span class="line">p6 &lt;- simulate_and_draw(<span class="number">1000</span>, bin_width = <span class="number">0.003</span>)</span><br><span class="line"></span><br><span class="line">ggarrange(p1, p2, p3, p4, p5, p6,</span><br><span class="line">          nrow = <span class="number">3</span>, ncol = <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>做图结果如下：</p><p><img src="/blog/2020/01/22/simu-clt-2/plot_all.png" class="" title="plot_all"></p><p>可以看到：</p><ul><li>样本数量足够大时，样本内 proportion 的分布接近正态分布</li><li>样本数量越大，分布的标准差越小</li></ul><p>对于一个100万用户的产品，如果新功能受到70%人喜欢，调查1000个用户就足以知道新功能是否受欢迎了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇模拟了均值的中心极限定理，这一篇再扩展一下。&lt;/p&gt;
&lt;p&gt;中心极限定理不只适用于均值，还可用于对“占比”的描述。什么是占比呢？&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总统选举中候选人 A 的支持率&lt;/li&gt;
&lt;li&gt;App Store 落地页的下载转化率&lt;/li&gt;
&lt;li&gt;认为 Google 股票会上涨的股民比例&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在互联网行业，这个指标最重要的应用应该是各种转化率。&lt;/p&gt;
&lt;p&gt;中心极限定理公诉我们，当样本足够大时，样本的比例符合正态分布。&lt;/p&gt;
&lt;p&gt;该分布的均值等于总体的分布：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/01/22/simu-clt-2/mean.png&quot; class=&quot;&quot; title=&quot;mean_of_sample_dist&quot;&gt;&lt;/p&gt;
&lt;p&gt;该分布的标准差可以用如下公式计算：&lt;br&gt;&lt;img src=&quot;/blog/2020/01/22/simu-clt-2/se.png&quot; class=&quot;&quot; title=&quot;se_of_sample_dist&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来我们模拟 proportion 的中心极限定理。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计理论" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>模拟“中心极限定理” - 均值篇</title>
    <link href="http://yoursite.com/2020/01/22/simu-clt-1/"/>
    <id>http://yoursite.com/2020/01/22/simu-clt-1/</id>
    <published>2020-01-22T17:39:54.000Z</published>
    <updated>2020-01-23T18:34:35.887Z</updated>
    
    <content type="html"><![CDATA[<p>中心极限定理是统计学里最重要的定理，可能没有之一。</p><p>按照中心极限定理，在样本量足够大的时候，任何分布的样本均值，都会接近正态分布。</p><p>不管原先的分布是二项分布、泊松分布或任何千奇百怪的分布，如果我们对这个分布做抽样，只要样本量够大，作为随机变量的样本均值会呈现正态分布。</p><p>下图是个形象的说明：</p><p><img src="/blog/2020/01/22/simu-clt-1/clt.png" class="" title="clt"></p><p>这个定理在数学上有严谨的证明。数学证明太抽象，我们可以用 simulation 更好地展示这个定理。</p><p><a id="more"></a></p><h2 id="样本数量与均值的分布"><a href="#样本数量与均值的分布" class="headerlink" title="样本数量与均值的分布"></a>样本数量与均值的分布</h2><p>根据中心极限定理，样本均值在样本量足够大时符合正态分布，且该正态分布的均值是：</p><p><img src="/blog/2020/01/22/simu-clt-1/mean_of_sample_mean_dist.png" class="" title="mean_of_sample_dist"></p><p>另外，样本均值的正态分布的标准差是：</p><p><img src="/blog/2020/01/22/simu-clt-1/se_of_sample_mean_dist.png" class="" title="sd_of_sample_dist"></p><p>所以，随着样本逐渐增大，我们应该能观察到：</p><ul><li>均值的分布逐渐接近正态分布</li><li>该正态分布的标准差越来越小</li></ul><h2 id="扔骰子"><a href="#扔骰子" class="headerlink" title="扔骰子"></a>扔骰子</h2><p>扔骰子是个经典的概率现象。从1到6，概率都是1/6。这个分布的数学期望是3.5（有兴趣的小伙伴可以手动算算）。</p><p>如果投1次骰子，相当于抽取一个样本，虽然数学期望仍然是3.5，但我们只会观察到有1/6的概率落在1到6中任意一个数字上。我们重复10000次抽样，并记录每次的均值（其实就是投到的数字，因为只有1次），应该会看到1到6的数字都占1/6。</p><p>如果投10次骰子，相当于抽取10个样本，均值会相对集中。我们重复10000次抽样，并记录每次的均值，应该会看到均值相对之前集中。</p><p>如果投100次骰子，相当于抽取100个样本，均值会非常接近3.5.我们重复10000次抽样，并记录每次的均值，按照中心极限定理，均值的分布会是个方差很小的正态分布。</p><p>在现实生活里，如果模拟10000次抽样，且每次抽样要投100次骰子，我们一共要投个100万次骰子。实在不可能。好在现在有了计算机，我们可以让计算机模拟投掷骰子的过程。</p><h2 id="R-代码"><a href="#R-代码" class="headerlink" title="R 代码"></a>R 代码</h2><p>用 R 语言模拟投掷结果并做图。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(tidyverse)</span><br><span class="line"><span class="keyword">library</span>(ggpubr)</span><br><span class="line"></span><br><span class="line">set.seed(<span class="number">123</span>)</span><br></pre></td></tr></tbody></table></figure><p>使用 tidyverse 包，主要是为了使用 dplyr 和 ggplot2。<br>ggpubr 包是为了合并图片。<br>为了保证分析的可重复性，需要先设定一个随机数种子，这样能保证每次“随机”的结果是一样的。</p><h3 id="函数：掷骰子"><a href="#函数：掷骰子" class="headerlink" title="函数：掷骰子"></a>函数：掷骰子</h3><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">simu_dice_mean &lt;- <span class="keyword">function</span>(size) {</span><br><span class="line">  dice_vec &lt;- <span class="number">1</span>:<span class="number">6</span></span><br><span class="line">  sample_mean &lt;- sum(sample(dice_vec, size, replace = <span class="literal">T</span>)) / size</span><br><span class="line">  sample_mean</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>simu_dice_mean</code> 函数模拟了掷骰子后计算均值的过程，我给了一个参数<code>size</code>，表示掷骰子的次数。这里会返回本次投掷的均值。</p><h3 id="函数：重复实验-n-次"><a href="#函数：重复实验-n-次" class="headerlink" title="函数：重复实验 n 次"></a>函数：重复实验 n 次</h3><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">simulate_df &lt;- <span class="keyword">function</span>(size, n) {</span><br><span class="line">  df_mean &lt;- data.frame(sample_mean = rep(<span class="number">0</span>, n))</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:n) {</span><br><span class="line">    df_mean[i, <span class="number">1</span>] &lt;- simu_dice_mean(size)</span><br><span class="line">  }</span><br><span class="line">  df_mean</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>simulate_df</code> 重复了 n 次 <code>simu_dice_mean</code>，生成一个 data frame，包含 n 个均值。<br>如果需要经常做模拟，这一步代码可以大大优化。不过我只模拟这一次，所以用了最直接的 for loop。</p><h3 id="函数：做图"><a href="#函数：做图" class="headerlink" title="函数：做图"></a>函数：做图</h3><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">draw_plot &lt;- <span class="keyword">function</span>(df, size, bin_width) {</span><br><span class="line">  stan_dev &lt;- round(sd(df$sample_mean), <span class="number">2</span>)</span><br><span class="line">  ggplot(df, aes(x = sample_mean)) + </span><br><span class="line">    geom_histogram(binwidth = bin_width) +</span><br><span class="line">    scale_x_continuous(limits = c(<span class="number">0.5</span>, <span class="number">6.5</span>)) + </span><br><span class="line">    labs(title = str_c(<span class="string">'投掷骰子'</span>, size, <span class="string">'次'</span>),</span><br><span class="line">         subtitle = str_c(<span class="string">'点估计标准差 = '</span>, stan_dev),</span><br><span class="line">         x = <span class="string">'均值'</span>,</span><br><span class="line">         y = <span class="string">'频数'</span>) </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>前一步返回了均值的 data frame，我们可以用其画出直方图，展示分布情况。<br>同时我在这一步计算了这组分布的标准差。</p><h3 id="函数：汇总"><a href="#函数：汇总" class="headerlink" title="函数：汇总"></a>函数：汇总</h3><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">simulate_and_draw &lt;- <span class="keyword">function</span>(size, n = <span class="number">10000</span>, bin_width) {</span><br><span class="line">  simulate_df(size, n) %&gt;%</span><br><span class="line">    draw_plot(size, bin_width)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>把 <code>simulate_df</code> 和 <code>draw_plot</code> 两个函数结合，生成一个新的函数<code>simulate_and_draw</code>。<br>准备工作结束。</p><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>我们依次计算并画出掷骰子1次、5次、10次、20次、50次和100次的模拟结果（模拟10000次实验）：</p><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p1 &lt;- simulate_and_draw(size = <span class="number">1</span>, bin_width = <span class="number">0.2</span>)</span><br><span class="line">p2 &lt;-  simulate_and_draw(size = <span class="number">5</span>, bin_width = <span class="number">0.2</span>)</span><br><span class="line">p3 &lt;- simulate_and_draw(size = <span class="number">10</span>,  bin_width = <span class="number">0.2</span>)</span><br><span class="line">p4 &lt;- simulate_and_draw(size = <span class="number">20</span>,  bin_width = <span class="number">0.15</span>)</span><br><span class="line">p5 &lt;- simulate_and_draw(size = <span class="number">50</span>,  bin_width = <span class="number">0.1</span>)</span><br><span class="line">p6 &lt;- simulate_and_draw(size = <span class="number">200</span>,  bin_width = <span class="number">0.03</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合6个图片</span></span><br><span class="line">ggarrange(p1, p2, p3, p4, p5, p6,</span><br><span class="line">          nrow = <span class="number">3</span>, ncol = <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="模拟结果"><a href="#模拟结果" class="headerlink" title="模拟结果"></a>模拟结果</h2><p>如下图：</p><p><img src="/blog/2020/01/22/simu-clt-1/plot_all.png" class="" title="plot_all"></p><p>可以清晰地看到：</p><ul><li>分布的均值越来越集中在3.5</li><li>分布的标准差越来越小</li></ul><p>类似的模拟，不只是掷骰子所属的离散均匀分布能做，其他分布也能做。如果我是老师，就会在这里布置一门作业：在总体分布符合泊松分布的情形下模拟中心极限定理。</p><p>以上就是中心极限定理的直观展示了。有了中心极限定理，对均值做统计推断才成为可能。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中心极限定理是统计学里最重要的定理，可能没有之一。&lt;/p&gt;
&lt;p&gt;按照中心极限定理，在样本量足够大的时候，任何分布的样本均值，都会接近正态分布。&lt;/p&gt;
&lt;p&gt;不管原先的分布是二项分布、泊松分布或任何千奇百怪的分布，如果我们对这个分布做抽样，只要样本量够大，作为随机变量的样本均值会呈现正态分布。&lt;/p&gt;
&lt;p&gt;下图是个形象的说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/2020/01/22/simu-clt-1/clt.png&quot; class=&quot;&quot; title=&quot;clt&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个定理在数学上有严谨的证明。数学证明太抽象，我们可以用 simulation 更好地展示这个定理。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计理论" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>ggplot 系列之：ggTimeSeries</title>
    <link href="http://yoursite.com/2020/01/21/gg-daily-heatmap/"/>
    <id>http://yoursite.com/2020/01/21/gg-daily-heatmap/</id>
    <published>2020-01-21T22:33:41.000Z</published>
    <updated>2020-01-23T18:34:35.879Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/21/gg-daily-heatmap/daily_heatmap.png" class="" title="heatmap"><p>今天看到一个有趣的 R pakcage：<a href="https://github.com/AtherEnergy/ggTimeSeries" target="_blank" rel="noopener">ggTimeSeries</a> 能够对时间序列数据做出有趣的图片。</p><p><a id="more"></a></p><h2 id="日期热点图"><a href="#日期热点图" class="headerlink" title="日期热点图"></a>日期热点图</h2><p>我最喜欢的是下面这个日期热点图，它能够展示连续变量在一年里每天的数据情况，月份在 x 轴，工作日在 y 轴，数据大小用填充色表示。</p><p>我随便找了个每日温度数据，做出了最上面那个图，做图代码如下：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本图</span></span><br><span class="line">p0 &lt;- df %&gt;%</span><br><span class="line">  ggplot_calendar_heatmap(<span class="string">'date'</span>,<span class="string">'meantemp'</span>, dayBorderColour = <span class="string">'#cccccc'</span>, monthBorderColour = <span class="string">'#777777'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加工</span></span><br><span class="line">p0 +</span><br><span class="line">  scale_fill_continuous(low = <span class="string">'green'</span>, high = <span class="string">'red'</span>) + </span><br><span class="line">  facet_wrap(~Year, ncol = <span class="number">1</span>) +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>,</span><br><span class="line">       y = <span class="literal">NULL</span>,</span><br><span class="line">       fill = <span class="literal">NULL</span>,</span><br><span class="line">       title = <span class="string">'每日平均气温'</span>) +</span><br><span class="line">  theme_minimal() +</span><br><span class="line">  theme(text=element_text(family=<span class="string">"Songti TC Regular"</span>)) </span><br></pre></td></tr></tbody></table></figure><p>这个展示方式很适合用来展示有工作日趋势和季度趋势的时间序列数据，比如每日销售、网站访问量。</p><p>寒假和暑假经常是游戏流量的高峰，这个信息就能在这个图片上一目了然。</p><p>工作日的游戏流量低于周末，也很适合在这个图表上展示。</p><h2 id="waterfall-图"><a href="#waterfall-图" class="headerlink" title="waterfall 图"></a>waterfall 图</h2><p>这个 package 里还有一个我喜欢的图，waterfall 图：</p><img src="/blog/2020/01/21/gg-daily-heatmap/gg_waterfall.png" class="" title="heatmap"><p>Waterfall 图用箭头标注了数据的每日变化，展示每天都有波动的数据很合适，比如股票价格等。</p><p>上图的做图代码：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本图</span></span><br><span class="line">df %&gt;%</span><br><span class="line">  ggplot_waterfall(<span class="string">'date'</span>,<span class="string">'meantemp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加工</span></span><br><span class="line">p0 +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>,</span><br><span class="line">       y = <span class="literal">NULL</span>,</span><br><span class="line">       color = <span class="string">'变化'</span>,</span><br><span class="line">       title = <span class="string">'每日平均气温'</span>) +</span><br><span class="line">  theme_classic(<span class="number">16</span>) +</span><br><span class="line">  theme(text=element_text(family=<span class="string">"Songti TC Regular"</span>),</span><br><span class="line">        plot.title = element_text(hjust = <span class="number">0.5</span>)) </span><br><span class="line"></span><br><span class="line">  theme(text=element_text(family=<span class="string">"Songti TC Regular"</span>)) </span><br></pre></td></tr></tbody></table></figure><p>这个 package 里还有其他几个可视化方法，个人觉得不太实用，有兴趣的同学可以去看看。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/21/gg-daily-heatmap/daily_heatmap.png&quot; class=&quot;&quot; title=&quot;heatmap&quot;&gt;
&lt;p&gt;今天看到一个有趣的 R pakcage：&lt;a href=&quot;https://github.com/AtherEnergy/ggTimeSeries&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ggTimeSeries&lt;/a&gt; 能够对时间序列数据做出有趣的图片。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>ggplot 系列之：别用漏斗图</title>
    <link href="http://yoursite.com/2020/01/21/gg-funnel/"/>
    <id>http://yoursite.com/2020/01/21/gg-funnel/</id>
    <published>2020-01-21T22:33:24.000Z</published>
    <updated>2020-01-23T18:34:35.879Z</updated>
    
    <content type="html"><![CDATA[<p>分析用户的转化路径时，经常需要使用漏斗图。但是，漏斗图并不是多好的数据可视化方案。</p><p>漏斗图的问题跟饼图有点相似：用面积表示数量多少，而人类视觉对面积的敏感度不够。</p><p>下面这张图是我从网上找到的漏斗图，我会用同样的数据做一个<strong>柱状图</strong>版本。</p><img src="/blog/2020/01/21/gg-funnel/funnel.png" class="" title="funnel"><p><a id="more"></a></p><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>原图展示了销售的四个步骤各自有多少人。</p><p>我们先准备一份数据：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(</span><br><span class="line">  stage = c(<span class="string">'Prospects'</span>, <span class="string">'Price Quotes'</span>, <span class="string">'Negotiations'</span>, <span class="string">'Closed Sales'</span>),</span><br><span class="line">  people = c(<span class="number">12000</span>, <span class="number">6800</span>, <span class="number">3000</span>, <span class="number">850</span>)</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><h2 id="做图"><a href="#做图" class="headerlink" title="做图"></a>做图</h2><p>漏斗图有个值得借鉴的设计思路：从上到下展示数据的阶段性变化。我们想在柱状图上借用这个设计。</p><h3 id="基本版"><a href="#基本版" class="headerlink" title="基本版"></a>基本版</h3><p>先画一个基本版</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ggplot(df, aes(x = stage, y = people)) + </span><br><span class="line">  geom_bar(stat = <span class="string">'identity'</span>, width = <span class="number">0.7</span>) +</span><br><span class="line">  geom_text(aes(label = people), hjust= -<span class="number">0.1</span>) +</span><br><span class="line">  scale_y_continuous(limits = c(<span class="number">0</span>, <span class="number">13000</span>)) +</span><br><span class="line">  labs(title = <span class="string">'销售漏斗图'</span>,</span><br><span class="line">       y = <span class="string">'人数'</span>,</span><br><span class="line">       x= <span class="literal">NULL</span>) +</span><br><span class="line">  coord_flip() +</span><br><span class="line">  theme_classic(<span class="number">16</span>) </span><br></pre></td></tr></tbody></table></figure><p>几个要点：</p><ul><li>使用 <code>coord_flip</code> 可以把柱状图变成横向</li><li>使用<code>geom_text</code>标注人数</li><li>使用<code>theme_classic</code> 主题，减少画面中的元素。</li></ul><p>结果如图：</p><img src="/blog/2020/01/21/gg-funnel/plot_bar_1.png" class="" title="bar_1"><h3 id="加入百分比"><a href="#加入百分比" class="headerlink" title="加入百分比"></a>加入百分比</h3><p>有的漏斗图会显示每个步骤还剩下多少比例的人数。我也想借用这个思路。</p><p>先加工数据：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_2 &lt;- df %&gt;%</span><br><span class="line">  mutate(pct = str_c(round(people / max(people) * <span class="number">100</span>), <span class="string">'%'</span>))</span><br></pre></td></tr></tbody></table></figure><p>我新建了一列，计算各个阶段相对于最开始人数的百分比。</p><p>然后做图：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ggplot(df_2, aes(x = stage, y = people)) + </span><br><span class="line">  geom_bar(stat = <span class="string">'identity'</span>, width = <span class="number">0.7</span>) +</span><br><span class="line">  geom_text(aes(label = people), hjust= <span class="number">1.1</span>, color = <span class="string">'white'</span>) +</span><br><span class="line">  geom_text(aes(y = max(people) * <span class="number">1.05</span>, label = pct), hjust= <span class="number">0</span>) +</span><br><span class="line">  scale_y_continuous(limits = c(<span class="number">0</span>, <span class="number">13000</span>)) +</span><br><span class="line">  labs(title = <span class="string">'销售漏斗图'</span>,</span><br><span class="line">       y = <span class="string">'人数'</span>,</span><br><span class="line">       x= <span class="literal">NULL</span>) +</span><br><span class="line">  coord_flip() +</span><br><span class="line">  theme_classic(<span class="number">16</span>)</span><br></pre></td></tr></tbody></table></figure><p>跟之前相比有两个变化：</p><ul><li>人数移到柱子内部，调整为白色</li><li>新增一个 <code>geom_text</code>，用于展示百分比</li></ul><p>结果如下：</p><img src="/blog/2020/01/21/gg-funnel/plot_bar_2.png" class="" title="bar_2"><h3 id="视觉调整"><a href="#视觉调整" class="headerlink" title="视觉调整"></a>视觉调整</h3><p>仔细看漏斗图，我发现漏斗图还有一个好处：图片内的元素很少，让人感觉舒服。</p><p>参考漏斗图，我们修改自己的柱状图设计。</p><p>代码：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># p1 是上一个图片</span></span><br><span class="line">p1 + theme(axis.title.x=element_blank(),</span><br><span class="line">           axis.text.x=element_blank(),</span><br><span class="line">           axis.ticks =element_blank(),</span><br><span class="line">           axis.line = element_blank(),</span><br><span class="line">           plot.title = element_text(hjust = <span class="number">0.3</span>)) +</span><br><span class="line">  scale_y_continuous(limits = c(<span class="number">0</span>, <span class="number">14500</span>), expand = c(<span class="number">0</span>,<span class="number">0</span>))</span><br></pre></td></tr></tbody></table></figure><p>要点：</p><ul><li>隐藏 x 轴和 y 轴的线、刻度</li><li>图片的标题相对居中</li><li>减少柱子和 y 轴之间的 padding</li></ul><p>结果如下：</p><img src="/blog/2020/01/21/gg-funnel/plot_bar_3.png" class="" title="bar_3"><p>能够修改的地方还有很多，比如柱子是不是太短太粗，颜色是不是可以优化，百分比的展示是不是可以更明确。这里就不再细究了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://peltiertech.com/bad-graphics-funnel-chart/" target="_blank" rel="noopener">Bad Graphics – Funnel Chart</a></li><li><a href="https://crmchartguy.com/2015/10/26/funnel-charts-in-dynamics-crm/" target="_blank" rel="noopener">Funnel Charts Suck and You Shouldn’t Use Them</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分析用户的转化路径时，经常需要使用漏斗图。但是，漏斗图并不是多好的数据可视化方案。&lt;/p&gt;
&lt;p&gt;漏斗图的问题跟饼图有点相似：用面积表示数量多少，而人类视觉对面积的敏感度不够。&lt;/p&gt;
&lt;p&gt;下面这张图是我从网上找到的漏斗图，我会用同样的数据做一个&lt;strong&gt;柱状图&lt;/strong&gt;版本。&lt;/p&gt;
&lt;img src=&quot;/blog/2020/01/21/gg-funnel/funnel.png&quot; class=&quot;&quot; title=&quot;funnel&quot;&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>ggplot系列之：theme</title>
    <link href="http://yoursite.com/2020/01/21/ggplot-theme/"/>
    <id>http://yoursite.com/2020/01/21/ggplot-theme/</id>
    <published>2020-01-21T14:21:31.000Z</published>
    <updated>2020-01-23T18:34:35.883Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/21/ggplot-theme/plot_all.png" class="" title="带数字的柱状图"><p>$\alpha$</p><p>人靠衣装，图靠 theme 装。好看的数据可视化，会一眼抓住人眼球，让你的报告更有说服力。</p><p>ggplot 生态提供了丰富的 theme 选择，如果你对已有的 theme 不满意，还可以自己创造 theme。</p><p>这篇文章介绍几个不错的 theme。</p><p><a id="more"></a></p><h2 id="数据和图片"><a href="#数据和图片" class="headerlink" title="数据和图片"></a>数据和图片</h2><p>先用 <a href="https://www.rdocumentation.org/packages/gapminder/versions/0.3.0" target="_blank" rel="noopener">Gapminder 数据</a>做一个基础图。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- gapminder %&gt;%</span><br><span class="line">  filter(year == <span class="number">2007</span>)</span><br></pre></td></tr></tbody></table></figure><p>Gapminder 里有1950年代到2007年各国的预期寿命、人口、人均 GDP 等数据。</p><p>我们只看2007年的样本，前几列数据如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">country</th><th style="text-align:center">continent</th><th style="text-align:center">year</th><th style="text-align:center">lifeExp</th><th style="text-align:center">pop</th><th style="text-align:center">gdpPercap</th></tr></thead><tbody><tr><td style="text-align:center">Afghanistan</td><td style="text-align:center">Asia</td><td style="text-align:center">2007</td><td style="text-align:center">43.828</td><td style="text-align:center">31889923</td><td style="text-align:center">974.5803</td></tr><tr><td style="text-align:center">Albania</td><td style="text-align:center">Europe</td><td style="text-align:center">2007</td><td style="text-align:center">76.423</td><td style="text-align:center">3600523</td><td style="text-align:center">5937.0295</td></tr><tr><td style="text-align:center">Algeria</td><td style="text-align:center">Africa</td><td style="text-align:center">2007</td><td style="text-align:center">72.301</td><td style="text-align:center">33333216</td><td style="text-align:center">6223.3675</td></tr><tr><td style="text-align:center">Angola</td><td style="text-align:center">Africa</td><td style="text-align:center">2007</td><td style="text-align:center">42.731</td><td style="text-align:center">12420476</td><td style="text-align:center">4797.2313</td></tr><tr><td style="text-align:center">Argentina</td><td style="text-align:center">Americas</td><td style="text-align:center">2007</td><td style="text-align:center">75.320</td><td style="text-align:center">40301927</td><td style="text-align:center">12779.3796</td></tr><tr><td style="text-align:center">Australia</td><td style="text-align:center">Oceania</td><td style="text-align:center">2007</td><td style="text-align:center">81.235</td><td style="text-align:center">20434176</td><td style="text-align:center">34435.3674</td></tr></tbody></table></div><p>我比较感兴趣的是人均 GDP 和预期寿命的相关性。所以，我会画一个人均 GDP 和预期寿命的散点图。除此之外，这里还有人口数据和国家所属的大洲，为了展示更多信息，我们可以用点的大小表示人口，用颜色表示所属的大洲。</p><p>做图代码如下：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p0 &lt;- ggplot(data = df, </span><br><span class="line">             aes(x = gdpPercap, </span><br><span class="line">                 y = lifeExp, </span><br><span class="line">                 size = pop,</span><br><span class="line">                 color = continent)) + </span><br><span class="line">  geom_point() +</span><br><span class="line">  scale_x_continuous(trans = <span class="string">'log'</span>,</span><br><span class="line">                     labels = round) +</span><br><span class="line">  labs(title = <span class="string">'人均gdp vs. 预期寿命'</span>,</span><br><span class="line">       x = <span class="string">'log(人均 GDP)'</span>,</span><br><span class="line">       y = <span class="string">'预期寿命'</span>,</span><br><span class="line">       color = <span class="string">'大洲'</span>,</span><br><span class="line">       size = <span class="string">'人口'</span>,</span><br><span class="line">       caption = <span class="string">"数据来源: gapminder"</span>)</span><br></pre></td></tr></tbody></table></figure><p>我怀疑人均 GDP 用 log 形式更能展示线性关系，所以这里对人均 GDP 数据做 log 处理。</p><h2 id="ggplot-的内置-theme"><a href="#ggplot-的内置-theme" class="headerlink" title="ggplot 的内置 theme"></a>ggplot 的内置 theme</h2><p>ggplot 内置了至少8个 theme，我选出了几个自己比较喜欢的。</p><h3 id="默认-theme-gray"><a href="#默认-theme-gray" class="headerlink" title="默认: theme gray"></a>默认: theme gray</h3><p>ggplot 的默认 theme 是 theme_gray：</p><img src="/blog/2020/01/21/ggplot-theme/plot_1.png" class="" title="theme_gray"><p>这个 theme 已经可以应付大部分场合了。</p><h3 id="theme-dark"><a href="#theme-dark" class="headerlink" title="theme dark"></a>theme dark</h3><p>既然有 gray，当然就有 dark。theme_dark 会把底色变黑，适用于在黑暗的环境做报告。</p><img src="/blog/2020/01/21/ggplot-theme/plot_2.png" class="" title="theme_dark"><h3 id="theme-minimal"><a href="#theme-minimal" class="headerlink" title="theme minimal"></a>theme minimal</h3><p>theme_minimal 是一个贯彻简单原则的 theme。</p><img src="/blog/2020/01/21/ggplot-theme/plot_3.png" class="" title="theme_minimal"><h3 id="theme-classic"><a href="#theme-classic" class="headerlink" title="theme classic"></a>theme classic</h3><p>theme_classic 是我的最爱，这应该是数据可视化最经典的主题。</p><img src="/blog/2020/01/21/ggplot-theme/plot_4.png" class="" title="theme_classic"><h2 id="package：ggthemes"><a href="#package：ggthemes" class="headerlink" title="package：ggthemes"></a>package：ggthemes</h2><p>ggthemes 是一个包含了十数个主题的 package，这里介绍其中的几个。</p><h3 id="theme-few"><a href="#theme-few" class="headerlink" title="theme few"></a>theme few</h3><p><code>theme_few</code> 也是个简单原则的主题。</p><img src="/blog/2020/01/21/ggplot-theme/plot_5.png" class="" title="theme_few"><h3 id="theme-economist"><a href="#theme-economist" class="headerlink" title="theme economist"></a>theme economist</h3><p><code>theme_economist</code> 是个参考《经济学人》风格设计的主题。</p><img src="/blog/2020/01/21/ggplot-theme/plot_6.png" class="" title="theme_economist"><h3 id="theme-gdocs"><a href="#theme-gdocs" class="headerlink" title="theme gdocs"></a>theme gdocs</h3><p><code>theme_gdocs</code> 是个参考 google docs 风格设计的主题。</p><img src="/blog/2020/01/21/ggplot-theme/plot_7.png" class="" title="theme_gdocs"><h3 id="theme-538"><a href="#theme-538" class="headerlink" title="theme 538"></a>theme 538</h3><p><code>theme_fivethirtyeight</code> 是个参考数据网站 <a href="https://fivethirtyeight.com/" target="_blank" rel="noopener">fivethirtyeight</a> 设计的主题。</p><img src="/blog/2020/01/21/ggplot-theme/plot_8.png" class="" title="theme_fivethirtyeight"><h3 id="theme-excel"><a href="#theme-excel" class="headerlink" title="theme_excel"></a>theme_excel</h3><p>package 作者出于搞笑目的做了一个经典 excel 主题。</p><img src="/blog/2020/01/21/ggplot-theme/plot_9.png" class="" title="theme_excel"><p>作者在 <a href="https://cran.r-project.org/web/packages/ggthemes/ggthemes.pdf" target="_blank" rel="noopener">ggthemes 的文档</a>里写道：</p><blockquote><p>Theme to replicate the ugly monstrosity that was the old gray-background Excel chart. Please never<br>use this. </p></blockquote><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61b.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61b.png?v8">😛</span></p><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>如果想要微调某个主题，需要用到 ggplot 的 <code>theme</code> 方法。</p><p>比如我们想修改默认主题：</p><ul><li>标题和副标题剧中</li><li>标题改为红色、加粗</li><li>副标题改为深绿色p</li></ul><p>我们可以这样做：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># p1 是最开始画的图</span></span><br><span class="line">p1 + theme(plot.title = element_text(color = <span class="string">'red'</span>,  hjust = <span class="number">0.5</span>, size = <span class="number">20</span>),</span><br><span class="line">           plot.subtitle = element_text(color = <span class="string">'darkgreen'</span>, hjust = <span class="number">0.5</span>))</span><br></pre></td></tr></tbody></table></figure><p>结果如下：</p><img src="/blog/2020/01/21/ggplot-theme/plot_10.png" class="" title="theme_edit"><p>这只是个说明性的例子，ggplot 提供了非常丰富的图片修改可能，图片上的任何“元素”都可以使用某个命令修改。</p><h2 id="bonus-theme-xkcd"><a href="#bonus-theme-xkcd" class="headerlink" title="bonus: theme_xkcd"></a>bonus: theme_xkcd</h2><p>最近刷到一个有意思的主题：xkcd。需要安装 package xkcd。<br>这是个卡通风格的主题，需要字体 xkcd，不支持中文。</p><p>用 <code>theme_xkcd()</code> 做图如下：</p><img src="/blog/2020/01/21/ggplot-theme/plot_xkcd.png" class="" title="theme_xkcd"><p>太可爱了 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8">😆</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/21/ggplot-theme/plot_all.png&quot; class=&quot;&quot; title=&quot;带数字的柱状图&quot;&gt;
&lt;p&gt;$\alpha$&lt;/p&gt;
&lt;p&gt;人靠衣装，图靠 theme 装。好看的数据可视化，会一眼抓住人眼球，让你的报告更有说服力。&lt;/p&gt;
&lt;p&gt;ggplot 生态提供了丰富的 theme 选择，如果你对已有的 theme 不满意，还可以自己创造 theme。&lt;/p&gt;
&lt;p&gt;这篇文章介绍几个不错的 theme。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>ggplot 系列之：折线图</title>
    <link href="http://yoursite.com/2020/01/21/ggplot-line/"/>
    <id>http://yoursite.com/2020/01/21/ggplot-line/</id>
    <published>2020-01-21T12:35:36.000Z</published>
    <updated>2020-01-23T18:34:35.879Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/21/ggplot-line/plot_example.png" class="" title="折线图"><p>折线图，经常用来展示时间序列数据。</p><p><a id="more"></a></p><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>这里使用 R 自带的 <a href="https://stat.ethz.ch/R-manual/R-devel/library/datasets/html/UKLungDeaths.html" target="_blank" rel="noopener">UKLungDeaths</a> 数据，记录了英国1974到1979年每个月因为肺病死亡的人数。</p><p>源数据是 ts 格式，需要现转换成 ggplot 需要的 data.frame 格式，使用 <a href="https://cran.r-project.org/web/packages/tsbox/vignettes/tsbox.html" target="_blank" rel="noopener">tsbox 包</a>。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于基础做图</span></span><br><span class="line">df &lt;- ts_df(ts_c(ldeaths))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于分组做图</span></span><br><span class="line">df_2 &lt;- ts_df(ts_c(fdeaths, mdeaths))</span><br><span class="line">names(df_2)[<span class="number">1</span>] &lt;- <span class="string">'gender'</span></span><br><span class="line">df_2 &lt;- df_2 %&gt;%</span><br><span class="line">  mutate(gender = ifelse(gender == <span class="string">'fdeaths'</span>, <span class="string">'female'</span>, <span class="string">'male'</span>))</span><br></pre></td></tr></tbody></table></figure><p>这里准备了两个 data.frame。第一个 df 是每月因为肺病死亡的总人数，第二个 df 是分性别的死亡人数。</p><p>第1组数据的前几行:</p><div class="table-container"><table><thead><tr><th style="text-align:center">time</th><th style="text-align:center">value</th></tr></thead><tbody><tr><td style="text-align:center">1974-01-01</td><td style="text-align:center">3035</td></tr><tr><td style="text-align:center">1974-02-01</td><td style="text-align:center">2552</td></tr><tr><td style="text-align:center">1974-03-01</td><td style="text-align:center">2704</td></tr><tr><td style="text-align:center">1974-04-01</td><td style="text-align:center">2554</td></tr><tr><td style="text-align:center">1974-05-01</td><td style="text-align:center">2014</td></tr><tr><td style="text-align:center">1974-06-01</td><td style="text-align:center">1655</td></tr></tbody></table></div><p>第2组数据的前几行：</p><div class="table-container"><table><thead><tr><th style="text-align:center">time</th><th style="text-align:center">value</th><th style="text-align:center">gender</th></tr></thead><tbody><tr><td style="text-align:center">1974-01-01</td><td style="text-align:center">901</td><td style="text-align:center">female</td></tr><tr><td style="text-align:center">1974-02-01</td><td style="text-align:center">689</td><td style="text-align:center">female</td></tr><tr><td style="text-align:center">1974-03-01</td><td style="text-align:center">827</td><td style="text-align:center">female</td></tr><tr><td style="text-align:center">1974-04-01</td><td style="text-align:center">677</td><td style="text-align:center">female</td></tr><tr><td style="text-align:center">1974-05-01</td><td style="text-align:center">522</td><td style="text-align:center">female</td></tr><tr><td style="text-align:center">1974-06-01</td><td style="text-align:center">406</td><td style="text-align:center">female</td></tr></tbody></table></div><p>第2组数据多了一个表示性别的变量<code>gender</code>。</p><h2 id="基本折线图"><a href="#基本折线图" class="headerlink" title="基本折线图"></a>基本折线图</h2><p>先画一个每月总死亡人数的图：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df %&gt;%</span><br><span class="line">  ggplot(aes(x = time, y = value)) + </span><br><span class="line">  geom_line() +</span><br><span class="line">  scale_x_date(date_breaks = <span class="string">'2 years'</span>,</span><br><span class="line">               date_labels = <span class="string">"%Y-%m"</span>) +</span><br><span class="line">  labs(title = <span class="string">'1974-1979年英国死于肺病的人数/每月'</span>,</span><br><span class="line">       x = <span class="string">'月份'</span>,</span><br><span class="line">       y = <span class="string">'死亡人数'</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>geom_line</code> 是画折线图的函数。</p><p>这里还出现了一个常用的方法<code>scale_x_date</code>，处理时间格式时很方便。我用 <code>date_breaks = '2 years'</code> 表示 x 轴的标签每隔两年显示，然后用<code>date_labels = '%Y-%m'</code>将显示的格式设定为”xxxx年-xx月”。</p><p>做图结果如下：<br><img src="/blog/2020/01/21/ggplot-line/plot_0.png" class="" title="折线图"></p><h2 id="分组折线图"><a href="#分组折线图" class="headerlink" title="分组折线图"></a>分组折线图</h2><p>有时我们需要对不同的组别画折线：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df_2 %&gt;%</span><br><span class="line">  ggplot(aes(x = time, y = value, color = gender)) + </span><br><span class="line">  geom_line() +</span><br><span class="line">  scale_x_date(date_breaks = <span class="string">'2 years'</span>,</span><br><span class="line">               date_labels = <span class="string">"%Y-%m"</span>) +</span><br><span class="line">  labs(title = <span class="string">'1974-1979年英国死于肺病的人数/每月'</span>,</span><br><span class="line">       x = <span class="string">'月份'</span>,</span><br><span class="line">       y = <span class="string">'死亡人数'</span>,</span><br><span class="line">       color = <span class="string">'性别'</span>)</span><br></pre></td></tr></tbody></table></figure><p>这里的关键是第2行的<code>color = gender</code>。</p><p>做图结果如下：<br><img src="/blog/2020/01/21/ggplot-line/plot_1.png" class="" title="折线图"></p><h2 id="折线图-点"><a href="#折线图-点" class="headerlink" title="折线图 + 点"></a>折线图 + 点</h2><p>有时我们想要同时展示折线和点：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df_2 %&gt;%</span><br><span class="line">  ggplot(aes(x = time, y = value, color = gender)) + </span><br><span class="line">  geom_line() +</span><br><span class="line">  geom_point() + </span><br><span class="line">  scale_x_date(date_breaks = <span class="string">'2 years'</span>,</span><br><span class="line">               date_labels = <span class="string">"%Y-%m"</span>) +</span><br><span class="line">  labs(title = <span class="string">'1974-1979年英国死于肺病的人数/每月'</span>,</span><br><span class="line">       x = <span class="string">'月份'</span>,</span><br><span class="line">       y = <span class="string">'死亡人数'</span>,</span><br><span class="line">       color = <span class="string">'性别'</span>)</span><br></pre></td></tr></tbody></table></figure><p>加上 <code>geom_point</code> 即可。</p><p>做图结果如下：<br><img src="/blog/2020/01/21/ggplot-line/plot_2.png" class="" title="折线图"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/21/ggplot-line/plot_example.png&quot; class=&quot;&quot; title=&quot;折线图&quot;&gt;
&lt;p&gt;折线图，经常用来展示时间序列数据。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>ggplot系列之：柱状图</title>
    <link href="http://yoursite.com/2020/01/20/ggplot-barplot/"/>
    <id>http://yoursite.com/2020/01/20/ggplot-barplot/</id>
    <published>2020-01-20T12:25:12.000Z</published>
    <updated>2020-01-23T18:34:35.879Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/20/ggplot-barplot/plot_2.png" class="" title="带数字的柱状图"><p>柱状图，个人认为最实用的可视化图形。这里总结如何在 ggplot2 里使用柱状图。</p><p><a id="more"></a></p><h2 id="默认柱状图"><a href="#默认柱状图" class="headerlink" title="默认柱状图"></a>默认柱状图</h2><p>先生成一份简单的数据：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df &lt;- data.frame(</span><br><span class="line">  user_num = c(<span class="number">3000</span>, <span class="number">5000</span>, <span class="number">7000</span>),</span><br><span class="line">  version = factor(c(<span class="string">'version 1'</span>, <span class="string">'version 2'</span>, <span class="string">'version 3'</span>))</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>我们生成了某 app 不同版本下的用户数据，我们需要展示这个信息。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ggplot(data=df, aes(x=version, y = user_num)) +</span><br><span class="line">  geom_bar(stat=<span class="string">"identity"</span>, width = <span class="number">0.5</span>) +</span><br><span class="line">  labs(title = <span class="string">'各个版本的用户数量'</span>,</span><br><span class="line">       x = <span class="string">'版本'</span>,</span><br><span class="line">       y = <span class="string">'用户数'</span>)</span><br></pre></td></tr></tbody></table></figure><p>最重要的代码是第7行的<code>geom_bar</code>，其中<code>stat="identity"</code>指直接用 data.frame 里的数字作为 y 轴的值。<code>width</code> 是柱子的宽度。</p><p>结果如下：</p><img src="/blog/2020/01/20/ggplot-barplot/plot_0.png" class="" title="初级柱状图"><h2 id="进阶版：分组"><a href="#进阶版：分组" class="headerlink" title="进阶版：分组"></a>进阶版：分组</h2><p>app 的用户数据可以按照各个维度做拆分，最常用的一个维度是性别。我们把用户数拆分为不同性别。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df_2 &lt;- data.frame(</span><br><span class="line">  user_num = c(<span class="number">1600</span>, <span class="number">1400</span>, <span class="number">3000</span>, <span class="number">2000</span>, <span class="number">4000</span>, <span class="number">3000</span>),</span><br><span class="line">  version = factor(c(<span class="string">'version 1'</span>, <span class="string">'version 1'</span>, <span class="string">'version 2'</span>,  <span class="string">'version 2'</span>, <span class="string">'version 3'</span>, <span class="string">'version 3'</span>)),</span><br><span class="line">  gender = factor(c(<span class="string">'male'</span>, <span class="string">'female'</span>, <span class="string">'male'</span>, <span class="string">'female'</span>, <span class="string">'male'</span>, <span class="string">'female'</span>))</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>然后我们展示分组柱状图。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ggplot(data=df_2, aes(x=version, y = user_num, fill = gender)) +</span><br><span class="line">  geom_bar(stat=<span class="string">"identity"</span>, width = <span class="number">0.5</span>, position = <span class="string">'dodge'</span>) +</span><br><span class="line">  scale_fill_brewer(palette=<span class="string">"Set2"</span>) +</span><br><span class="line">  labs(title = <span class="string">'各个版本的用户数量'</span>,</span><br><span class="line">       x = <span class="string">'版本'</span>,</span><br><span class="line">       y = <span class="string">'用户数'</span>,</span><br><span class="line">       fill = <span class="string">'性别'</span>) </span><br></pre></td></tr></tbody></table></figure><p>我在第一行用了<code>fill = gender</code>，实现了对不同组填色。<br>然后在第二行用了<code>position = 'dodge'</code>，实现了对把不同组的柱子并排展示。如果不使用这个参数，柱子会叠加在一起展示。<br>为了替换默认颜色，我在第三行用了<code>scale_fill_brewer(palette="Set2")</code>，这里的 <code>Set2</code>是调色板名称。</p><p>结果如下：</p><img src="/blog/2020/01/20/ggplot-barplot/plot_1.png" class="" title="分组柱状图"><h2 id="在柱子上显示数量"><a href="#在柱子上显示数量" class="headerlink" title="在柱子上显示数量"></a>在柱子上显示数量</h2><p>有时为了更清晰地展示信息，我们需要在柱子上展示数字。</p><p>这时需要用到 <code>geom_text()</code>:</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ggplot(data=df_2, aes(x=version, y = user_num, fill = gender)) +</span><br><span class="line">  geom_bar(stat=<span class="string">"identity"</span>, width = <span class="number">0.8</span>, position = <span class="string">'dodge'</span>) +</span><br><span class="line">  geom_text(aes(label = user_num), position = position_dodge(<span class="number">0.8</span>), vjust = -<span class="number">0.2</span>) +</span><br><span class="line">  scale_fill_brewer(palette=<span class="string">"Set2"</span>) +</span><br><span class="line">  labs(title = <span class="string">'各个版本的用户数量'</span>,</span><br><span class="line">       x = <span class="string">'版本'</span>,</span><br><span class="line">       y = <span class="string">'用户数'</span>,</span><br><span class="line">       fill = <span class="string">'性别'</span>) </span><br></pre></td></tr></tbody></table></figure><p>第3行就是 <code>geom_text()</code> 命令，我们令文字内容等于<code>user_num</code>。</p><p>结果如下：</p><img src="/blog/2020/01/20/ggplot-barplot/plot_2.png" class="" title="带数字的柱状图"><p>更多柱状图控制，可以参考 ggplot2 的文档。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/20/ggplot-barplot/plot_2.png&quot; class=&quot;&quot; title=&quot;带数字的柱状图&quot;&gt;
&lt;p&gt;柱状图，个人认为最实用的可视化图形。这里总结如何在 ggplot2 里使用柱状图。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>ggplot 系列之：饼图</title>
    <link href="http://yoursite.com/2020/01/20/ggplot-pie-chart/"/>
    <id>http://yoursite.com/2020/01/20/ggplot-pie-chart/</id>
    <published>2020-01-20T05:20:15.000Z</published>
    <updated>2020-01-23T18:34:35.883Z</updated>
    
    <content type="html"><![CDATA[<p>说到数据可视化，就逃不了饼图。我还记得在学校里做 presentation 的时候，饼图大概是最常见的图片类型。</p><p>这篇文章介绍怎么用 ggplot 做饼图。</p><p><a id="more"></a></p><h2 id="别用饼图"><a href="#别用饼图" class="headerlink" title="别用饼图"></a>别用饼图</h2><p>其实，饼图是糟糕的数据可视化方法，<strong>别用饼图</strong>。</p><p>原因：饼图用面积表示数量的大小，但视觉对面积的感知能力很弱，使用饼图会导致较低的信息传递效率。</p><p>先看下面这个饼图：</p><img src="/blog/2020/01/20/ggplot-pie-chart/pie_1.png" class="" title="pie one"><p>上面这个图让人有至少两个困惑：</p><ul><li>第2和第4位是不是一样多呢？</li><li>第1位到底比第2位多多少呢？</li></ul><p>一个更好的可视化，是使用柱状图：</p><img src="/blog/2020/01/20/ggplot-pie-chart/bar_1.png" class="" title="bar one"><p>柱状图符合人类进化的结果：眼睛对长度的敏锐度远远高于面积。</p><h2 id="Less-is-More"><a href="#Less-is-More" class="headerlink" title="Less is More"></a>Less is More</h2><p>有的时候，我们可能想通过饼图强调某一个分类的占比最大。其实这里也可以用柱状图。</p><p>先看下图：<br><img src="/blog/2020/01/20/ggplot-pie-chart/pie_2.png" class="" title="pie two"></p><p>使用饼图已经足够给人困扰了，使用3D形式简直就是在犯罪。</p><p>看看Joey Cherdarchuk的优化成果：<br><img src="/blog/2020/01/20/ggplot-pie-chart/bar_2.png" class="" title="bar two"></p><p>清晰，简洁，美观，舒服。</p><p><a href="https://www.darkhorseanalytics.com/blog/salvaging-the-pie" target="_blank" rel="noopener">Joey Cherdarchuk 的原文</a>一步步把前面那个丑陋的饼图简化成了后面的样子，非常震撼。</p><h2 id="如何用-ggplot-做饼图"><a href="#如何用-ggplot-做饼图" class="headerlink" title="如何用 ggplot 做饼图"></a>如何用 ggplot 做饼图</h2><p>回答最开始提出的问题，如何用 ggplot 做饼图呢？答案：<strong>别做饼图，改用柱状图</strong>。</p><p>如果你真的非饼图不画，ggplot 可能不是个好工具。饼图的缺点基本已经是统计学届的共识，所以 ggplot 完全没有提供制作饼图的 <code>geom_pie</code>。</p><p>当然，ggplot 灵活的语法还是可以画出饼图的，可以先用<code>geom_bar</code>，然后做一个坐标变换<code>coord_polar</code>。具体代码可以<a href="http://www.sthda.com/english/wiki/ggplot2-pie-chart-quick-start-guide-r-software-and-data-visualization" target="_blank" rel="noopener">参考这里</a>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到数据可视化，就逃不了饼图。我还记得在学校里做 presentation 的时候，饼图大概是最常见的图片类型。&lt;/p&gt;
&lt;p&gt;这篇文章介绍怎么用 ggplot 做饼图。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>Python OOP 之 Property</title>
    <link href="http://yoursite.com/2020/01/20/python-property/"/>
    <id>http://yoursite.com/2020/01/20/python-property/</id>
    <published>2020-01-20T01:54:12.000Z</published>
    <updated>2020-01-23T18:34:35.887Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习 Python OOP 编程的一个 interface：property。</p><p>OOP 编程有两个常用的概念：getter 和 setter。Property 装饰器是 Python 实现 getter 和 setter 的方式。</p><p>这篇文章用一个例子说明如何使用 property。</p><p><a id="more"></a></p><h2 id="业务代码-v1"><a href="#业务代码-v1" class="headerlink" title="业务代码 v1"></a>业务代码 v1</h2><p>背景：初出茅庐的你，在为公司写一个记录员工信息的系统。</p><p>第1版系统里需要记录员工的姓名和收入。</p><p>员工可以用一个 class 表示，每个 instance 都包含员工的姓名和收入。</p><p>初步掌握 OOP 编程的你，很快完成了第1版代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, income)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.income = income</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'Person <span class="subst">{self.name}</span> with income <span class="subst">{self.income}</span>'</span></span><br><span class="line"></span><br><span class="line">Tom = Person(name = <span class="string">'Tom'</span>,</span><br><span class="line">             income = <span class="number">3000</span>)</span><br><span class="line">print(Tom) <span class="comment"># Person Tom with income 3000</span></span><br><span class="line">Tom.income = <span class="number">5000</span></span><br><span class="line">print(Tom.income)  <span class="comment"># 5000</span></span><br></pre></td></tr></tbody></table></figure><p>然后老板提出了一个需求：我们是社会主义国家的企业，为了体现社会主义的先进性，员工工资只能增加，不能减少，你要把这个特点写到系统里。</p><p>这个神奇的需求当然很容易实现，不需要修改 <code>Person</code> 这个对象的代码，只需要在客户端用 POST 方法修改工资时做一个条件判断，这个需求大概只需要3分钟完成。</p><p>可是，你仔细思考了老板的话，如果只是在 Restful API 上做检查，岂不只是“表面文章”，社会主义的先进性，难道不是应该体现在 object 层面吗？</p><p>于是，你决定实现一个功能：修改 income 时，如果 income 不增加，会报错。</p><h2 id="测试逻辑"><a href="#测试逻辑" class="headerlink" title="测试逻辑"></a>测试逻辑</h2><p>除了实现老板的需求外，你还有另一个追求：你希望 <code>Person</code> 对象的 API 不会改变，也就是说，新版本的 <code>Person</code> 对象会实现对低版本的兼容。</p><p>完成新的<code>Person</code>后，你要做两个测试。</p><p>第1个测试：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tom = Person(name = <span class="string">'Tom'</span>,</span><br><span class="line">             income = <span class="number">3000</span>)</span><br><span class="line">print(Tom) <span class="comment"># Person Tom with income 3000</span></span><br><span class="line">Tom.income = <span class="number">5000</span></span><br><span class="line">print(Tom.income)  <span class="comment"># 5000</span></span><br></pre></td></tr></tbody></table></figure><p>上面这段代码的运行结果，要跟第1个版本一样。</p><p>第2个测试：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tom = Person(name = <span class="string">'Tom'</span>,</span><br><span class="line">             income = <span class="number">3000</span>)</span><br><span class="line">Tom.income = <span class="number">1000</span></span><br></pre></td></tr></tbody></table></figure><p>在运行到<code>Tom.income = 1000</code>时，会报错。</p><h2 id="业务代码-v2"><a href="#业务代码-v2" class="headerlink" title="业务代码 v2"></a>业务代码 v2</h2><p>然后，你开始研究怎么实现新的需求。聪明的你很快发现，Property 是实现上述需求的好方法。</p><p>新版本代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, income)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self._income = income  <span class="comment">#第4行</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  @property  #第6行</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">income</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._income</span><br><span class="line">  </span><br><span class="line"><span class="meta">  @income.setter  #第10行</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">income</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> value &lt; self.income :</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">"收入不能减少"</span>)</span><br><span class="line">    self._income = value</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'Person <span class="subst">{self.name}</span> with incom <span class="subst">{self.income}</span>'</span></span><br></pre></td></tr></tbody></table></figure><p>我们依次查看这段代码里的新东西。</p><h3 id="第4行：self-income-income"><a href="#第4行：self-income-income" class="headerlink" title="第4行：self._income = income"></a>第4行：<code>self._income = income</code></h3><p>这里用 _ 表示 private variable。</p><p>Python 其实没有真正的 private variable。下面这段代码会正常返回 <code>_income</code>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, income)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self._income = income </span><br><span class="line"></span><br><span class="line">Tom = Person(name=<span class="string">'Tom'</span>, income = <span class="number">3000</span>)</span><br><span class="line">print(Tom._income) <span class="comment"># 打印出 3000</span></span><br></pre></td></tr></tbody></table></figure><p>使用 _ 表示 private variable，其实是一种约定俗成。Python 有非常多的约定俗成，比如 class 里的<code>self</code>，其实也可以用其他字段代替。</p><h3 id="第6行：-property"><a href="#第6行：-property" class="headerlink" title="第6行：@property"></a>第6行：<code>@property</code></h3><p><code>@property</code> 装饰器把 income 变成了一个 <strong>getter</strong>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ....省略 class 的代码</span></span><br><span class="line"></span><br><span class="line">Tom = Person(name=<span class="string">'Tom'</span>, income = <span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">print(Tom.income) <span class="comment"># 打印出 3000</span></span><br></pre></td></tr></tbody></table></figure><p>此时我们不需要使用<code>Tom._income</code>，只需要像第1版一样用<code>Tom.income</code>就能获取 <code>_income</code>的内容。</p><p>如果没有<code>@property</code>装饰器，<code>income</code>就变成了一个<strong>方法</strong>，只能用<code>Tom.income()</code>的方式调用。</p><h3 id="第10行：-income-setter"><a href="#第10行：-income-setter" class="headerlink" title="第10行：@income.setter"></a>第10行：<code>@income.setter</code></h3><p>这是 setter 装饰器，把下面的函数变成了 income 的 setter。</p><p>setter 这个名称很直观，我们会在满足条件后设置 income 的值。</p><p>在之后的函数里，我们检查了新的值是否小于原先的 income，如果不满足条件，我们就 raise 一个错误。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一顿操作后，第2版的业务代码使用 property 实现了老板的需求和 API 的兼容。非常完美。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.geeksforgeeks.org/python-property-function/" target="_blank" rel="noopener">Geeksforgeeks: Python | property() function</a></li><li><a href="https://www.programiz.com/python-programming/property" target="_blank" rel="noopener">Programiz : Python @property</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天学习 Python OOP 编程的一个 interface：property。&lt;/p&gt;
&lt;p&gt;OOP 编程有两个常用的概念：getter 和 setter。Property 装饰器是 Python 实现 getter 和 setter 的方式。&lt;/p&gt;
&lt;p&gt;这篇文章用一个例子说明如何使用 property。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://yoursite.com/categories/Coding/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>理解 JavaScript 的 this</title>
    <link href="http://yoursite.com/2020/01/19/js-this/"/>
    <id>http://yoursite.com/2020/01/19/js-this/</id>
    <published>2020-01-19T16:53:05.000Z</published>
    <updated>2020-01-23T18:34:35.883Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = {</span><br><span class="line">  name: <span class="string">'Harry Potter'</span>,</span><br><span class="line">  myMethod: <span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">myObject.myMethod() <span class="comment">// undefined</span></span><br></pre></td></tr></tbody></table></figure><p>上面这段代码为什么会返回<code>undefined</code>呢？因为万恶的<code>this</code>。</p><img src="/blog/2020/01/19/js-this/this.jpeg" class="" title="wtf is this"><p>MDN 对 <strong>this</strong> 的定义是：代码运行的环境。这句话给我的最大感觉是：what the <em>**</em> is this?</p><p>这里总结下 <strong>this</strong> 的几个用法。</p><p><a id="more"></a></p><h2 id="Default-Binding"><a href="#Default-Binding" class="headerlink" title="Default Binding"></a>Default Binding</h2><p>在 Chrome 浏览器打开 inspector 的 console，输入如下代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.count)</span><br><span class="line">}</span><br><span class="line">Func()</span><br></pre></td></tr></tbody></table></figure><p>console 会显示<code>5</code>。</p><p>因为我们的代码在环境下运行，this 默认绑定到了全局环境。</p><p>在<code>use strict</code>模式下，默认绑定不会发生。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="string">`use strict`</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.count)</span><br><span class="line">}</span><br><span class="line">Func()</span><br></pre></td></tr></tbody></table></figure><p>此时 Chrome 会报错。</p><h2 id="Implicit-Binding"><a href="#Implicit-Binding" class="headerlink" title="Implicit Binding"></a>Implicit Binding</h2><p>在 object 里创建函数时，运行函数时的<code>this</code>就是这个对象。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anObj = {</span><br><span class="line">  name: <span class="string">'Harry Potter'</span>,</span><br><span class="line">  callName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">anObj.callName()</span><br></pre></td></tr></tbody></table></figure><p>此时屏幕会打印 Harry Potter。</p><h2 id="Explicit-Binding"><a href="#Explicit-Binding" class="headerlink" title="Explicit Binding"></a>Explicit Binding</h2><p>如果不想在 object 创建函数，我们可以手动把函数的<code>this</code>绑定到对象上。</p><p>可以使用<code>bind</code>、<code>call</code>或<code>apply</code>。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anObj = {</span><br><span class="line">  name: <span class="string">'Harry Potter'</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">callName.call(anObj) <span class="comment">// Harry Potter</span></span><br><span class="line">callName.apply(anObj) <span class="comment">// Harry Potter</span></span><br><span class="line"></span><br><span class="line">newCallname = callName.bind(anObj)</span><br><span class="line">newCallname() <span class="comment">// Harry Potte</span></span><br></pre></td></tr></tbody></table></figure><p><code>call</code> 和 <code>apply</code> 可以直接以 object 作为 argument。<br><code>bind</code> 需要指向一个新的变量。</p><h2 id="new-Binding"><a href="#new-Binding" class="headerlink" title="new Binding"></a><code>new</code> Binding</h2><p>创建 class 的 instance 时，<code>this</code> 会指向这个 instance</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>{</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) {</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  showCoord() {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">p1.showCoord()  <span class="comment">// 1, 2</span></span><br><span class="line"></span><br><span class="line">p2 = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">p2.showCoord()  <span class="comment">// 3, 4</span></span><br></pre></td></tr></tbody></table></figure><p>每个 instance 都会有自己的 context。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数的<code>this</code>跟普通函数不一样，箭头函数会继承 parent scope 的<code>this</code>。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Ron Weasley'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObject = {</span><br><span class="line">  name: <span class="string">'Harry Potter'</span>,</span><br><span class="line">  myMethod: <span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">myObject.myMethod() <span class="comment">// Ron Weasley</span></span><br></pre></td></tr></tbody></table></figure><p>在上面这段代码里，我们用箭头函数定义了 myMethod，结果屏幕打印的是 global context 里的 <code>name</code>，因为 <code>myObject</code> 位于 global context。</p><p>如果是在<code>use strict</code>下，上面这段代码会打印<code>undifined</code>。</p><p>所以，谨慎在箭头函数里使用<code>this</code>，非常容易出错啊。</p><p>既然不能使用箭头函数，上面这段的代码要怎么写才更简洁呢？用 ES6 的函数写写法：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = {</span><br><span class="line">  name: <span class="string">'Harry Potter'</span>,</span><br><span class="line">  myMethod() {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">myObject.myMethod() <span class="comment">// Harry Potter</span></span><br></pre></td></tr></tbody></table></figure><p>搞清楚上面这些用法后，<code>this</code> 就没那么奇怪了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; myObject = {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  name: &lt;span class=&quot;string&quot;&gt;&#39;Harry Potter&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  myMethod: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myObject.myMethod() &lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这段代码为什么会返回&lt;code&gt;undefined&lt;/code&gt;呢？因为万恶的&lt;code&gt;this&lt;/code&gt;。&lt;/p&gt;
&lt;img src=&quot;/blog/2020/01/19/js-this/this.jpeg&quot; class=&quot;&quot; title=&quot;wtf is this&quot;&gt;
&lt;p&gt;MDN 对 &lt;strong&gt;this&lt;/strong&gt; 的定义是：代码运行的环境。这句话给我的最大感觉是：what the &lt;em&gt;**&lt;/em&gt; is this?&lt;/p&gt;
&lt;p&gt;这里总结下 &lt;strong&gt;this&lt;/strong&gt; 的几个用法。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://yoursite.com/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>为什么数据团队应该采用 reproducible research</title>
    <link href="http://yoursite.com/2020/01/19/reproducible-research/"/>
    <id>http://yoursite.com/2020/01/19/reproducible-research/</id>
    <published>2020-01-19T10:07:01.000Z</published>
    <updated>2020-01-23T18:34:35.887Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/19/reproducible-research/plot.jpg" class="" title="plot"><p>Reproducible research （可重复研究）是学术界的一个潮流。它的意思是，所有研究都应该是可以“复制”的。如果你给我一个研究报告，你不能只给我看结果，你还要给我看到<strong>整个分析过程</strong>，而且我能够在自己的电脑上<strong>复制</strong>出同样的结果。</p><p>经历过几个公司的数据相关业务后，我深深地感觉到：这个规范不只应该用在科学研究里，它也应该用在商业公司的数据团队里。</p><p><a id="more"></a></p><h2 id="传统的分析报告"><a href="#传统的分析报告" class="headerlink" title="传统的分析报告"></a>传统的分析报告</h2><p>为了简化讨论，我们假设数据已经自动搜集并存储在数据仓库中。我们先不讨论研究团队需要自己搜集数据的情况。</p><p>产品经理想了解一个问题：“我们为提升用户留存设计了一个新功能，这个新功能已经上线了1个月，它是否有效果呢？”</p><p>某分析师做了如下操作：</p><ol><li>从数据库提取数据，或从数据后台“下载”数据</li><li>把数据导入 excel 中，开始清洗数据</li><li>做某些假设检验、或模型分析</li><li>把分析结果展示在 excel 中，或另外写一份 word 报告</li></ol><p>在某些公司里，上面的做法已经“足够”了。但是，经历过学术训练的人会有如下问题：</p><ul><li>怎么判断报告作者使用了“正确”的数据源？例子：提取数据的时候日期搞错了。</li><li>怎么判断作者正确清洗了数据？例子：float 变 int。</li><li>怎么判断作者做了需要做的检验？例子：使用 lm 模型却没检查假设是否能被满足。</li><li>怎么判断作者没有为了推销自己的结论而“调整”数据？例子：选择性展示数据。</li><li>……</li></ul><p>上面这些问题可以总结为：<strong>怎么知道分析师没有犯错，无论是有意的错误还是无意的错误</strong>。</p><p>按照传统的方法，“找分析报告的 bug”是个成本很高的活儿，我们几乎只能被动接受分析师给的结果。</p><p>这意味着，我们没有办法系统性地保证数据分析的质量。一个小公司也许可以容忍这样的错误可能，但对严重依赖数据做出决策、并且需要做出大量决策的公司，这不是最优解。</p><h2 id="一个可复制的分析报告"><a href="#一个可复制的分析报告" class="headerlink" title="一个可复制的分析报告"></a>一个可复制的分析报告</h2><p>用可复制的分析报告，之前的研究问题会用下面的方法做。</p><h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><p>要求：数据的获取必须调用 API 或者写 SQL 语句。</p><p>作用：</p><ul><li>当我拿到你的分析，我能复制这段代码，然后调出完全一样的数据</li><li>如果我怀疑数据提取过程有问题，我可以检查代码，判断是不是取数据的代码写错了</li></ul><p>禁止行为：在后台“下载”数据。没人知道你在下载前做了哪些操作。</p><h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>要求：</p><ul><li>清洗数据必须使用代码完成。</li><li>整个数据清洗流程，都用注释清晰的标注。</li></ul><p>作用：其他人能检查整个分析流程，判断是否有某些地方出错。</p><p>禁止行为：在 excel 或其他工具上用<strong>鼠标点选</strong>完成数据清洗。鼠标点选也是不可复制的，不只别人复制不了，分析师自己都很难复制（也许第一次分析时点错了某个地方却不自知）。</p><h3 id="数据分析过程"><a href="#数据分析过程" class="headerlink" title="数据分析过程"></a>数据分析过程</h3><p>要求：</p><ul><li>需要给出使用某个分析模型的原因</li><li>需要说明参数选择的过程</li><li>需要用代码展示完整的分析流程</li></ul><p>作用：</p><ul><li>数据分析包含一定的理论知识，也包含很多相对主观的判断，记录这些判断过程，有助于其他人理解</li><li>方便检查代码正确情况</li></ul><p>禁止行为：不能把数据分析的过程当成“黑箱子”，过程和结果同样重要。</p><h3 id="报告形式"><a href="#报告形式" class="headerlink" title="报告形式"></a>报告形式</h3><p>要求：</p><ul><li>核心分析内容和分析结论在报告主干部分</li><li>从数据获取到分析部分的代码，都在备注部分，或者放在另一个文件里</li></ul><p>作用：</p><ul><li>报告使用者只需要阅读主要部分</li><li>报告<strong>审阅者</strong>可以在备注部分查找可复制研究的过程</li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>目前似乎只有2个选择：</p><ul><li>R：使用 Rmarkdown </li><li>Python：使用 Notebook</li></ul><p>其他工具满足不了“可复制”的需求。</p><h2 id="“可复制研究”的意义"><a href="#“可复制研究”的意义" class="headerlink" title="“可复制研究”的意义"></a>“可复制研究”的意义</h2><p>本质上，“可复制研究” 把数据分析从黑箱子变成了可以审阅的文本，发现分析错误变得相对便宜。</p><p>它让每个人的工作都变得 accountable。每一行代码、每一个分析决策，都被暴露在光天化日之下，东郭先生就无处藏身了。想象一下，写了你名字的报告上竟然有低级的数据清洗错误，这是件多么丢人的事情。</p><p>整体上，“可复制研究”会提高整个数据团队的分析质量。</p><p>我还没有机会在这样的团队工作，但过去的经历让我知道“普通”的数据分析团队可以糟糕到什么程度。看到某些分析师的报告，会让你怀疑他们是否上过统计学入门课，我一直为使用这些报告的决策者捏把汗。</p><p>可复制研究也对团队成员的能力有巨大的要求：</p><ul><li>必须会 R 或 Python，会还不够，还必须能写出 readable code</li><li>表达能力要足够强</li><li>有一定的统计基础，能够做到引用文献</li></ul><p>所谓“可复制研究”，除了是一种理念，还是一套工作流 workflow。就像 readable code 能整体上提高团队的开发质量，reproducible report 能整体上提高团队的数据分析质量。</p><p>使用可复制研究还有一个好处，“知识”变得可以沉淀，不再只是某些分析师脑子里的经验。后来者可以通过前人的报告学习分析思路、复用代码。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/19/reproducible-research/plot.jpg&quot; class=&quot;&quot; title=&quot;plot&quot;&gt;
&lt;p&gt;Reproducible research （可重复研究）是学术界的一个潮流。它的意思是，所有研究都应该是可以“复制”的。如果你给我一个研究报告，你不能只给我看结果，你还要给我看到&lt;strong&gt;整个分析过程&lt;/strong&gt;，而且我能够在自己的电脑上&lt;strong&gt;复制&lt;/strong&gt;出同样的结果。&lt;/p&gt;
&lt;p&gt;经历过几个公司的数据相关业务后，我深深地感觉到：这个规范不只应该用在科学研究里，它也应该用在商业公司的数据团队里。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据科学" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 其实很像 Python</title>
    <link href="http://yoursite.com/2020/01/18/js-python/"/>
    <id>http://yoursite.com/2020/01/18/js-python/</id>
    <published>2020-01-18T12:21:29.000Z</published>
    <updated>2020-01-23T18:34:35.883Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/18/js-python/js-py.jpg" class="" title="js-python"><p>在我刚入门 JavaScript 的时候，感觉 JavaScript 是个莫名其妙的语言。在那之前，我真正称得上了解的语言只有 python。写 python 是一种享受，相比之下，写 JavaScript 的体验很“怪异”。</p><p>后来我才直到，JavaScript 是一个在很短时间内创造的语言，是为了在浏览器上运行。我所学习的 JavaScript，还是20多年前的版本。拿老版本的 JavaScript 和今天的 python3 去比较，是挺不合理的。</p><p>在了解到最新的 JS 功能后，JavaScript 突然变得“可爱”了，甚至在某些地方很像 python。</p><p><a id="more"></a></p><h2 id="多行-string"><a href="#多行-string" class="headerlink" title="多行 string"></a>多行 string</h2><p>问题：如何给 string 换行呢？</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poem = <span class="string">"""Programming is fun</span></span><br><span class="line"><span class="string">Except for syntax errors</span></span><br><span class="line"><span class="string">Missing curly brace""</span></span><br></pre></td></tr></tbody></table></figure><p>老版本的 JavaScript 不支持，但现在支持了：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> poem = <span class="string">`Programming is fun</span></span><br><span class="line"><span class="string">Except for syntax errors</span></span><br><span class="line"><span class="string">Missing curly brace`</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="Expression-Interpolation"><a href="#Expression-Interpolation" class="headerlink" title="Expression Interpolation"></a>Expression Interpolation</h2><p>问题：如何方便地在 string 中使用变量呢？</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">print(<span class="string">f'Fifteen is <span class="subst">{a + b}</span> and not <span class="subst">{<span class="number">2</span> * a + b}</span>.'</span>)</span><br></pre></td></tr></tbody></table></figure><p>上面这个功能很实用，让代码的可读性提高了几个档次。JavaScript 也有类似的写法：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Fifteen is <span class="subst">${a + b}</span> and not <span class="subst">${<span class="number">2</span> * a + b}</span>.`</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="Destructuring"><a href="#Destructuring" class="headerlink" title="Destructuring"></a>Destructuring</h2><p>问题：如何同时 assign 几个变量的值呢？</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x, y, z = numbers</span><br></pre></td></tr></tbody></table></figure><p>Destructuring 在某些场合有用，ES2017 里有了类似的设计：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> [x, y, z] = numbers</span><br></pre></td></tr></tbody></table></figure><h2 id="Spread-Operator"><a href="#Spread-Operator" class="headerlink" title="Spread Operator"></a>Spread Operator</h2><p>问题：如何 assign 数组里的一个变量，并忽略其他变量呢？</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">first, *remaining = numbers</span><br></pre></td></tr></tbody></table></figure><p>下面是 JavaScript 的写法：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> [first, ...remaining] = numbers</span><br></pre></td></tr></tbody></table></figure><h2 id="Rest-Operator"><a href="#Rest-Operator" class="headerlink" title="Rest Operator"></a>Rest Operator</h2><p>问题：如何给函数任意多个 argument 呢？</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myFun</span><span class="params">(*argv)</span>:</span>  </span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> argv:  </span><br><span class="line">        <span class="keyword">print</span> (arg)</span><br><span class="line"></span><br><span class="line">myFun(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br></pre></td></tr></tbody></table></figure><p>在 python 里这个规则叫 <em>wargs。在 JavaScript 里，使用 <code>...</code>，这三个点叫 <em>*rest operator</em></em></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">product</span>(<span class="params">...args</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> arg</span><br><span class="line">  <span class="keyword">for</span> (arg <span class="keyword">of</span> args) {</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">product(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>问题：如何把一个数组里的数字全部开方</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">list(map(<span class="keyword">lambda</span> x: x * <span class="number">2</span>, numbers))</span><br><span class="line"><span class="comment"># or [x * 2 for x in numbers]</span></span><br></pre></td></tr></tbody></table></figure><p>JavaScript 里使用<strong>箭头函数</strong>：=&gt;</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">numbers.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><p>相比 lambda，箭头函数甚至更加 elegant。</p><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>问题：如何创建一个 class</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"({x}, {y})"</span>.format(x=self.x, y=self.y)</span><br></pre></td></tr></tbody></table></figure><p>在 ES2017 之前，JavaScript 的做法：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>{</span><br><span class="line">  <span class="keyword">this</span>.x = x</span><br><span class="line">  <span class="keyword">this</span>.y = y</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>第一次看到上面这段代码时我非常费解，这是什么鬼<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8">😰</span>？现在有新的写法了：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>{</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) {</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  toString() {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>习惯 python 的开发者可以无缝理解了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8">😆</span>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在 Hacker News 上看到过一句话：</p><blockquote><p>我招人的时候从来不问对方会什么编程语言，因为只要你会一门语言，掌握其他语言都很容易。作为一个工程师，真正重要的不是你会什么语言或框架，而是……</p></blockquote><p>这句话我只记得前半句，现在有点理解为什么编程语言不重要了。不过重要的到底是什么呢？虽然我不是软件工程师，不过还是对这个答案很好奇。</p><p>如果我需要招一个软件工程师，我会希望他/她有什么特质？</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/18/js-python/js-py.jpg&quot; class=&quot;&quot; title=&quot;js-python&quot;&gt;
&lt;p&gt;在我刚入门 JavaScript 的时候，感觉 JavaScript 是个莫名其妙的语言。在那之前，我真正称得上了解的语言只有 python。写 python 是一种享受，相比之下，写 JavaScript 的体验很“怪异”。&lt;/p&gt;
&lt;p&gt;后来我才直到，JavaScript 是一个在很短时间内创造的语言，是为了在浏览器上运行。我所学习的 JavaScript，还是20多年前的版本。拿老版本的 JavaScript 和今天的 python3 去比较，是挺不合理的。&lt;/p&gt;
&lt;p&gt;在了解到最新的 JS 功能后，JavaScript 突然变得“可爱”了，甚至在某些地方很像 python。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://yoursite.com/categories/Coding/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 vs. 统计学</title>
    <link href="http://yoursite.com/2020/01/18/statistics-ml/"/>
    <id>http://yoursite.com/2020/01/18/statistics-ml/</id>
    <published>2020-01-18T07:47:56.000Z</published>
    <updated>2020-01-23T18:34:35.887Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/18/statistics-ml/statistic-ml.jpeg" class="" title="线性回归"><p>机器学习和统计学不是一回事，可是机器学习里和统计学里又有很多交集，比如线性回归。两者都使用了相同的理论框架，但强调的东西完全不一样。</p><p>在具体的公司业务场景中，我们需要明确，自己需要的到底是统计学，还是机器学习。两者会对分析场景有不同的需求。</p><p>这篇文章总结两个学科的需求。</p><p><a id="more"></a></p><h2 id="统计学"><a href="#统计学" class="headerlink" title="统计学"></a>统计学</h2><p>统计学至少有两个典型的使用场景：</p><ul><li>使用样本估计总体</li><li>建立解释性模型</li></ul><h3 id="样本估计总体"><a href="#样本估计总体" class="headerlink" title="样本估计总体"></a>样本估计总体</h3><p>问卷调查是公司了解用户的重要手段。我最喜欢的例子是乐高。2004年时，乐高亏损严重。乐高的美国分公司老大跟《星球大战》的版权方谈妥了合作意向，于是飞到丹麦总部跟公司提出这个方案。乐高公司的高层对这个提议非常“震怒”，因为这违背了乐高一直以来“反对暴力”的理念：乐高的产品里一定不会有暴力元素，更别说要出一个名字里带“war”的产品系列了。</p><p>提出这个方案的美国老大动用了一个杀手锏：要不我们对家长做个问卷调查，看看家长们是否愿意为孩子们购买星战题材的乐高。问卷调查的结果说服了保守的乐高高层。《星球大战》系列开启了乐高的新时代，乐高开始频繁与全球大IP合作，各大 IP 为乐高带来了持续十几年的高速增长。</p><p>这里的问卷调查，其实就是统计学的重要应用：问卷调查的样本数据是整体市场数据的有效代表吗？把这个问题更抽象地表达：我只有 x 个样本，我是否能用这 x 个样本去有效的估计总体。</p><p>商业调查可以通过花钱解决样本数量问题，毕竟一份问卷也没多贵，但在医学药物实验里，一个样本就没那么便宜了。一轮药物实验经常只有几十个样本。用这几十个样本去估计总体，难度要大得多。</p><p>在互联网公司，最经常使用的统计学的场景是 A/B 测试，这里的核心问题是：A/B 测试的样本数据，是有效的总体代表吗？换句话说，我们可以通过这几千个样本，判断 A 版本比 B 版本更好吗？</p><h3 id="建立解释性模型"><a href="#建立解释性模型" class="headerlink" title="建立解释性模型"></a>建立解释性模型</h3><p>社会科学的论文需要利用统计学证明自己想描述的理论关系。</p><p>比如：</p><ul><li>收入的决定因素是什么？</li><li>是否存在收入上的性别/种族歧视？</li><li>R&amp;D投入和市场投入对公司长期盈利能力的影响分别有多大？</li><li>……</li></ul><p>所有这些问题，都需要建立一个模型去描述现象，然后通过数据验证这个模型的准确性。这里既存在样本代表性的问题（样本估计总体），还有模型解释力的问题。</p><p>比如在线性回归里，我们关注 R-square，一个好的模型，应该有比较好的 R-square。同时，这个模型应该是“可解释”的。相比机器学习，统计学的模型不能是个“黑箱子”。机器学习可以接受模型的“不可解释”，统计学则要求模型 make sense。</p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>机器学习与统计学有两个大的区别：</p><ul><li>大样本</li><li>以预测为目的</li></ul><h3 id="大样本"><a href="#大样本" class="headerlink" title="大样本"></a>大样本</h3><p>统计学里有100个样本可能就是很大了，一个 excel 表格就能轻松装下。机器学习利用了互联网时代的数据爆发，有海量的数据可供使用。实际上，机器学习已经存在了几十年，但因为没有足够“喂养”模样的数据和算力，一直没能发展，直到互联网时代。</p><p>统计学需要考虑“样本少”的问题，机器学习不只不用担心样本量，有时甚至能用“总体”做计算。</p><p>在大数据的前提下，很多统计学需要担心的问题不存在了。比如小样本下不适合使用某些 test。</p><h3 id="以预测为目的"><a href="#以预测为目的" class="headerlink" title="以预测为目的"></a>以预测为目的</h3><p>机器学习的最核心特征，是以预测为目的，预测准确度越高越好，过程并不重要。</p><p>机器学习<strong>不关心</strong>模型的解释效力。注意，这里说的是”不关心“。有的模型，比如线性回归，允许人对模型过程做解释，但另外一些模型，比如神经网络，很难解释。</p><p>在应用层面，机器学习非常的“务实”：别跟我扯理论，show me the accuracy。</p><p>同样是线性回归，即使用同样的数据集，我们也可能因为目标而不同而有各自的侧重。想象我们是一家连锁蛋糕公司，旗下有100家店铺。我们搜集了过去几年这些店铺的人流量、营业收入、商圈竞争对手数量等信息。我们可以：</p><ul><li>研究哪些因素最影响营业收入。</li><li>预测这些店铺未来的收入。</li></ul><p>上面两个任务都是可以用线性回归来做，但前者会偏重统计学，需要解释力，后者会偏重机器学习，需要预测力。</p><h2 id="如何选择技能点"><a href="#如何选择技能点" class="headerlink" title="如何选择技能点"></a>如何选择技能点</h2><p>单纯的统计学使用者，可以选择忽略机器学习。统计学使用者包括：</p><ul><li>社会科学领域的学者</li><li>咨询公司的数据分析师</li><li>大公司的用户调查团队</li><li>医药学研究者</li><li>…</li></ul><p>数据工作者成千上万，真正有机会用到机器学习解决问题的并不多。</p><p>但是，在互联网公司工作的数据工作者，或者希望在互联网公司做数据工作的人，大概率有机会使用机器学习，这个时候了解机器学习就会非常必要了。从学科脉络来看，机器学习的部分理论基础就是统计学，所以搞机器学习的人，是逃不过学习统计学的。所以，如果你想再互联网公司做数据工作，统计学和机器学习都是要有所了解的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/18/statistics-ml/statistic-ml.jpeg&quot; class=&quot;&quot; title=&quot;线性回归&quot;&gt;
&lt;p&gt;机器学习和统计学不是一回事，可是机器学习里和统计学里又有很多交集，比如线性回归。两者都使用了相同的理论框架，但强调的东西完全不一样。&lt;/p&gt;
&lt;p&gt;在具体的公司业务场景中，我们需要明确，自己需要的到底是统计学，还是机器学习。两者会对分析场景有不同的需求。&lt;/p&gt;
&lt;p&gt;这篇文章总结两个学科的需求。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据科学" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python 的 Generator</title>
    <link href="http://yoursite.com/2020/01/17/python-generator/"/>
    <id>http://yoursite.com/2020/01/17/python-generator/</id>
    <published>2020-01-17T13:52:13.000Z</published>
    <updated>2020-01-23T18:34:35.887Z</updated>
    
    <content type="html"><![CDATA[<p>问题：x 是一个由数字组成的 list，我们想求出每个元素的平方。</p><p>一个解决方法是：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_numbers</span><span class="params">(nums)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        result.append(i * i)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">my_nums = square_numbers([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">print(my_nums) <span class="comment"># [1, 4, 9, 16]</span></span><br></pre></td></tr></tbody></table></figure><p>这是个正确的答案，但不完美。我们可以使用 generator 写出更简洁的答案：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_numbers</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">yield</span>(i * i)</span><br><span class="line"></span><br><span class="line">my_nums = square_numbers([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">print(list(my_nums))</span><br></pre></td></tr></tbody></table></figure><p><a id="more"></a></p><h2 id="generator-函数"><a href="#generator-函数" class="headerlink" title="generator 函数"></a>generator 函数</h2><p>普通的函数使用 <code>return</code> 返回结果，<strong>generator 函数</strong>使用 <code>yield</code> 返回结果。</p><p>generator 函数可以使用 <code>next()</code> 获取下一个返回值。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dumb_generator</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">a = dumb_generator()</span><br><span class="line"></span><br><span class="line">print(next(a)) <span class="comment"># 1</span></span><br><span class="line">print(next(a)) <span class="comment"># 2</span></span><br><span class="line">print(next(a)) <span class="comment"># 3</span></span><br><span class="line">print(next(a)) <span class="comment"># 报错：StopIteration</span></span><br></pre></td></tr></tbody></table></figure><p>上面这段代码会在运行<code>next(a)</code>依次返回1、2、3，然后报错。</p><p>我们可以直接把 generator 函数的返回对象用在 for loop 里：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dumb_generator</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">a = dumb_generator()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">  print(i)</span><br></pre></td></tr></tbody></table></figure><p>for loop 在完成循环后会自动停止，不会报错。</p><h2 id="generator-comprehension"><a href="#generator-comprehension" class="headerlink" title="generator comprehension"></a>generator comprehension</h2><p>文章最开始的问题，其实可以用 list comprehension 快速解决：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_nums = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br></pre></td></tr></tbody></table></figure><p>generator 也可以用 comprehension 的形式快速生成：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_nums = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) <span class="comment"># 这是一个 generator</span></span><br></pre></td></tr></tbody></table></figure><h2 id="为什么使用-generator"><a href="#为什么使用-generator" class="headerlink" title="为什么使用 generator"></a>为什么使用 generator</h2><p>除了方便之外，generator 还有什么好处呢？最大的好处是，节约内存。</p><p>假设生成从1到100万的 list，这个 list 会被存在内存里，占据大量空间。<br>如果生成从1到100万的 generator，内存占用量几乎可以忽略不计。</p><p>另外，generator 还可以用来表达数学上的无穷数列，比如 <a href="https://en.wikipedia.org/wiki/Fibonacci_number" target="_blank" rel="noopener">Finabocci 数列</a>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fib():</span><br><span class="line">  print(i)</span><br><span class="line">  <span class="keyword">if</span> i &gt; <span class="number">1000</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></tbody></table></figure><p>上面的代码会打印出从0开始的 Finabocchi 数列，直到数列大于1000（第18个数字就会大于1000）。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题：x 是一个由数字组成的 list，我们想求出每个元素的平方。&lt;/p&gt;
&lt;p&gt;一个解决方法是：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;square_numbers&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nums)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; nums:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result.append(i * i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;my_nums = square_numbers([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(my_nums) &lt;span class=&quot;comment&quot;&gt;# [1, 4, 9, 16]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是个正确的答案，但不完美。我们可以使用 generator 写出更简洁的答案：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;square_numbers&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nums)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; nums:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;(i * i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;my_nums = square_numbers([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(list(my_nums))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://yoursite.com/categories/Coding/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>决策树模型里的 Entropy</title>
    <link href="http://yoursite.com/2020/01/17/decision-tree-entropy/"/>
    <id>http://yoursite.com/2020/01/17/decision-tree-entropy/</id>
    <published>2020-01-17T07:06:33.000Z</published>
    <updated>2020-01-23T18:34:35.879Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/17/decision-tree-entropy/decision-tree.png" class="" title="决策树"><p>决策树模型是机器学习的重要模型。决策树里有个概念，叫 entropy，模型的最优化函数基于 entropy 做出。</p><p>用一个诗意的说法，entropy 描述了世界的混乱程度。Split 能帮助降低混乱程度。</p><p>这篇文章用具体例子说明，split 如何降低 entropy。</p><p><a id="more"></a></p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>给定数据集中有 C 个分组，entropy 的公式如下：</p><img src="/blog/2020/01/17/decision-tree-entropy/entropy.png" class="" title="entropy公式"><p>公式中的 pi 是第 c 类元素的出现概率。</p><h2 id="不可知与可知"><a href="#不可知与可知" class="headerlink" title="不可知与可知"></a>不可知与可知</h2><p>想象一个世界上只有“好人”，那么好人的概率是1。因为 log_2(1) = 0，此时的 entropy = 0。</p><p>想象另一个世界，只有坏人，那么好人的概率是0，这时 entropy = -1 * 0 * log_2(1) = 0。</p><p>上面两种情况，如果以 entropy 来描述，都是“可知”的，不存在任何混乱，这是个稳定的世界。</p><p>想象第3个世界：好人和坏人各占一半，那么 entropy = (0.5 * log_2(0.5)) + (0.5 * log_2(0.5)) = 1。</p><p>这是个极端“混乱”的世界，路上随便碰到一个人，你完全不知道他是好人还是坏人。在这里，不确定性达到最大值。</p><h2 id="引入解释变量"><a href="#引入解释变量" class="headerlink" title="引入解释变量"></a>引入解释变量</h2><p>我们还在第3个世界里，作为数据工作者，我们无法忍受这种混乱，于是我们决定建立一个模型，找到识别坏人和好人的方法。</p><p>我们去警察局获取了100个人的档案，其中有50个好人、50个坏人。档案里还有另一个数据：是否染发。</p><p>根据上面的档案数据，我们绘制表格如下：</p><img src="/blog/2020/01/17/decision-tree-entropy/table.png" class="" title="好人坏人以及染发"><p>我们似乎可以用染发与否判断一个人是好人还是坏人。</p><p>如果使用上面的判断方式，我们的 entropy 会减少多少呢？</p><p>E(染发) =  10/45 * log_2(10/45) + 35/45 * log_2(35/45) = 0.76<br>E(不染发) =  40/55 * log_2(40/55) + 15/55 * log_2(15/55) = 0.85</p><p>然后按照频率加权平均，得到以染发预测好人的 entropy：<br>E(是否好人｜是否染发) = 45/100 * 0.76  + 55/100 * 0.85 = 0.81</p><p>现在我们看到一个染发者，就判断他是坏人，然后躲得远远的。我们会有一定的错判率（大概29%），但这已经比之前无法判断的情况有了进步，这个世界没有那么混乱了。怎么衡量混乱程度的减少呢？我们用原先的 entropy 减去基于某个因素做判断的 entropy，得到这个因素的 <strong>information gain</strong>：</p><p>IG= = E(是否好人) - E(是否好人|是否染发) = 1 - 0.81 = 0.19</p><p>引入染发这个 split，我们获得了 0.19 的进步。</p><p>如果我们有更多变量，我们就可以依次计算每个变量的 IG，并选择 IG 效果最好的变量作为解释变量。当我们依次选择出了若干个解释变量，所谓的决策树<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f332.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f332.png?v8">🌲</span>就出现了。</p><h2 id="一个引申"><a href="#一个引申" class="headerlink" title="一个引申"></a>一个引申</h2><p>如果公司对 A 方案有5成把握，在 entropy 函数里，混乱程度是最严重的。另外一个方案 B，公司只有2成把握，这时的 entropy 值比较低。</p><p>这是一个有意思的发现：我们希望 entropy 越低越好。站在公司角度，B 方案是个可以快速拒绝的方案：我们清楚地知道它大概率失败（假设两个方案的预期回报相等）。真正造成混乱后果，往往是 A 方案这样模棱两可的方案。</p><p>再看一个（半搞笑的）场景，假设有两个同事：</p><ul><li>A 员工的判断准确度是50%</li><li>B 员工的判断准确度是20%</li></ul><p>我会更希望自己的手下是哪个呢？按照 entropy 公式，B 员工的 entropy 值更低。此时我们选择 B 员工：我们只要做出跟 B 员工的判断相反的选择，就大概率正确了。而 A 员工呢，价值还不如一枚硬币，毕竟通过抛硬币做选择也能达到50%的准确度。</p><p>现实生活里有没有类似 B 员工的人呢？可能没有这样的人，但在某一类问题上，有人开能会习惯性犯错。</p><p>我曾经有个同事喜欢追求完美，总是没有办法按期完成任务，ta 经常会说“我觉得这个版本还不够好/我还没准备好，要不再等一等”。如果选择延期，结果往往更糟糕。在按期交付问题上，ta 的判断力就像只有20%的准确度 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span>。当我意识到这点后，每次 ta 提出“可以延期“时，我总会立刻做出判断：不能延期了，必须交付。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/17/decision-tree-entropy/decision-tree.png&quot; class=&quot;&quot; title=&quot;决策树&quot;&gt;
&lt;p&gt;决策树模型是机器学习的重要模型。决策树里有个概念，叫 entropy，模型的最优化函数基于 entropy 做出。&lt;/p&gt;
&lt;p&gt;用一个诗意的说法，entropy 描述了世界的混乱程度。Split 能帮助降低混乱程度。&lt;/p&gt;
&lt;p&gt;这篇文章用具体例子说明，split 如何降低 entropy。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计理论" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>线性回归的假设</title>
    <link href="http://yoursite.com/2020/01/16/lm-assumptions/"/>
    <id>http://yoursite.com/2020/01/16/lm-assumptions/</id>
    <published>2020-01-16T12:56:06.000Z</published>
    <updated>2020-01-23T18:34:35.883Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/16/lm-assumptions/assumption.png" class="" title="假设"><p>数据可以骗人，这个道理大家都知道。我印象最深的经历是：同事给了一个基于 linear regression 的研究报告，但报告完全没有对线性回归的假设做<strong>任何诊断</strong>。不做假设检验的分析报告在大学作业里会被判断为不及格。</p><p>但这份报告在业务部门中传阅，成为了产品的决策依据。这是一个上市公司，报告分析的产品也是公司的现金牛产品。</p><p>糟糕的数据分析，最好的结果是浪费了大家的时间，最坏的结果是指导决策者做出错误的决策。</p><p>这篇文章小结一下 linear regression 的几个核心假设，就当是大学知识的一次复习。</p><p><a id="more"></a></p><h2 id="LM的假设"><a href="#LM的假设" class="headerlink" title="LM的假设"></a>LM的假设</h2><ol><li>线性关系</li><li>自变量之间不具有多重共线性</li><li>扰动项符合正态分布</li><li>同方差</li><li>没有自相关：这种情况在非时间序列里很少见，所以我们不讨论了</li></ol><h2 id="1-线性关系"><a href="#1-线性关系" class="headerlink" title="1. 线性关系"></a>1. 线性关系</h2><p>第一个假设最直接：自变量和因变量之间是线性关系。</p><p>反例：<code>y = a + b * x ^ 3</code>，这里的 y 和 x 就不是线性关系。</p><p>做一元回归时，散点图可以揭示自变量与因变量之间的关系。</p><p>如果是多元回归，可以使用 R 的 <code>lm</code> 对象自带的 <code>plot</code> 函数。函数返回的第1个图片：<strong>Residuals vs Fitted</strong> 能够用来检查线性假设。</p><p>我们模拟数据并示例如下：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">size &lt;- <span class="number">30</span></span><br><span class="line">x &lt;- rnorm(size, <span class="number">15</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">y1 &lt;- <span class="number">3</span> + <span class="number">5</span> * x + rnorm(size, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">y2 &lt;- <span class="number">3</span> + <span class="number">5</span> * x^<span class="number">3</span> + rnorm(size, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">fit_1 &lt;- lm(y1 ~ x)</span><br><span class="line">fit_2 &lt;- lm(y2 ~ x)</span><br><span class="line"></span><br><span class="line">p1 &lt;- autoplot(fit_1)</span><br><span class="line">p2 &lt;- autoplot(fit_2)</span><br><span class="line"></span><br><span class="line">p1_1 &lt;- p1[[<span class="number">1</span>]] + ggtitle(<span class="string">'满足线性假设'</span>) + theme(plot.title = element_text(size = <span class="number">18</span>))</span><br><span class="line">p2_1 &lt;- p2[[<span class="number">1</span>]] + ggtitle(<span class="string">'不满足线假设'</span>) + theme(plot.title = element_text(size = <span class="number">18</span>))</span><br><span class="line"></span><br><span class="line">ggarrange(p1_1, p2_1 + rremove(<span class="string">'y.title'</span>), ncol = <span class="number">2</span>, nrow = <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><p>我使用了 ggfortify 包处理 lm 的图片，并用 ggpubr 包把两个模型的图片并列在一起。</p><p>图片如下：</p><img src="/blog/2020/01/16/lm-assumptions/plot_1.png" class="" title="线性假设"><p>当模型满足线性假设时，fitted value 和 residuals 的关系接近一条直线（如左图），右图则明显不是直线。</p><h2 id="2-多重共线性"><a href="#2-多重共线性" class="headerlink" title="2. 多重共线性"></a>2. 多重共线性</h2><p>要求：自变量之间没有<strong>过于强</strong>的线性关系。</p><p>有一些线性关系是没问题的。在研究现实问题时，我们很难找到完全没线性关系的自变量。</p><p>比如研究收入的影响因素，我们会考虑智商和学历。智商越高，自然收入越高；学历越高，当然收入也越高。可是，学历也同时跟智商有线性关系。这会是个问题吗?</p><p>只要这两个变量不是完全的线性关系，我们就不用担心。这两个因素当然不是完全线性关系，除了智商之外，家庭条件、考生的所处省份、个人兴趣等因素也跟学历有巨大关系。</p><p>我们可以查看所有自变量之间的相关性。ggplot 生态里有个非常好用的 <code>ggcorrplot</code> 包：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggcorrplot)</span><br><span class="line">data(mtcars)</span><br><span class="line">corr &lt;- round(cor(mtcars), <span class="number">1</span>)</span><br><span class="line">ggcorrplot(corr, hc.order = <span class="literal">TRUE</span>, type = <span class="string">"lower"</span>,</span><br><span class="line">           outline.col = <span class="string">"white"</span>,</span><br><span class="line">           ggtheme = ggplot2::theme_gray,</span><br><span class="line">           colors = c(<span class="string">"#6D9EC1"</span>, <span class="string">"white"</span>, <span class="string">"#E46726"</span>)) </span><br></pre></td></tr></tbody></table></figure><p>结果如下图：</p><img src="/blog/2020/01/16/lm-assumptions/plot_2.png" class="" title="多重共线性"><p>如果想更严格地描述多重共线性问题，可以参考一个叫 <a href="https://en.wikipedia.org/wiki/Variance_inflation_factor" target="_blank" rel="noopener">variance inflation factor</a> 的指标。</p><h2 id="3-扰动项符合正态分布"><a href="#3-扰动项符合正态分布" class="headerlink" title="3. 扰动项符合正态分布"></a>3. 扰动项符合正态分布</h2><p>扰动项 error term 是一个理论概念：没有被观察到的影响因素，都算在扰动项里。扰动项无法直接衡量，所以我们用残差 residuals 来代替。残差是真实值和拟合值之间的差。</p><p>一般使用 Normal QQ 图来检查扰动项是否符合正态分布。</p><p>我们先 simulate 两组数据，然后对比它们的 QQ 图：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">size &lt;- <span class="number">100</span></span><br><span class="line">x &lt;- rnorm(size, <span class="number">15</span>, <span class="number">10</span>)</span><br><span class="line">err &lt;- rnorm(size, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">  </span><br><span class="line">y1 &lt;- <span class="number">3</span> + <span class="number">5</span> * x + err</span><br><span class="line">y2 &lt;- <span class="number">3</span> + <span class="number">5</span> * x + err ^ <span class="number">3</span></span><br><span class="line"></span><br><span class="line">fit_1 &lt;- lm(y1 ~ x)</span><br><span class="line">fit_2 &lt;- lm(y2 ~ x)</span><br><span class="line"></span><br><span class="line">p1 &lt;- autoplot(fit_1)</span><br><span class="line">p2 &lt;- autoplot(fit_2)</span><br><span class="line"></span><br><span class="line">p1_2 &lt;- p1[[<span class="number">2</span>]] + ggtitle(<span class="string">'扰动项正态分布'</span>) + theme(plot.title = element_text(size = <span class="number">18</span>))</span><br><span class="line">p2_2 &lt;- p2[[<span class="number">2</span>]] + ggtitle(<span class="string">'非正态分布'</span>) + theme(plot.title = element_text(size = <span class="number">18</span>))</span><br><span class="line"></span><br><span class="line">ggarrange(p1_2, p2_2 + rremove(<span class="string">'y.title'</span>),</span><br><span class="line">           ncol = <span class="number">2</span>, nrow = <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><p>我们让第1个模型的扰动项完美符合正态分布，让第2个模型第扰动项严重偏离正态分布。<br>得到的 QQ 图如下：</p><img src="/blog/2020/01/16/lm-assumptions/plot_3.png" class="" title="扰动项符合正态分布"><p>在完美假设的情况下，所有的点几乎跟图中直线重合。右图中的点则严重偏离了图中直线。</p><h2 id="4-同方差"><a href="#4-同方差" class="headerlink" title="4. 同方差"></a>4. 同方差</h2><p>同方差假设的内容是：对不同的自变量值，扰动项的方差是相同的。如果违反了这个假设，就叫“异方差”。</p><p>典型的的异方差场景：研究收入和学历的关系，我们可以大概预料到，学历越高的人，收入的反差越大（有的人混得非常好，有的人混得一般）。</p><p>这是线性回归里非常重要的假设，我们可以用 <code>ncvTest()</code> 检测异方差。也可以在做出模型后做可视化检查，即使用 scale-location 图。</p><p>跟之前的思路一样，我在下面的代码里模拟一个正常模型和一个异方差模型。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">123</span>)</span><br><span class="line">size &lt;- <span class="number">100</span></span><br><span class="line">x &lt;- rnorm(size, <span class="number">15</span>, <span class="number">10</span>)</span><br><span class="line">err_1 &lt;- rnorm(size, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">err_2 &lt;- (x -<span class="number">1</span>)* rnorm(size, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">y1 &lt;- <span class="number">3</span> + <span class="number">5</span> * x + err_1</span><br><span class="line">y2 &lt;- <span class="number">3</span> + <span class="number">5</span> * x + err_2</span><br><span class="line"></span><br><span class="line">fit_1 &lt;- lm(y1 ~ x)</span><br><span class="line">fit_2 &lt;- lm(y2 ~ x)</span><br></pre></td></tr></tbody></table></figure><p>这里我们查看 scale-location 图，下图中同方差的情况是一条比较直的线，异方差则比较斜。</p><img src="/blog/2020/01/16/lm-assumptions/plot_4.png" class="" title="scale-location"><p>另一个更符合直接的参考图，是 x 和对应残差的散点图。<br>参考下图：下图的异方差现象很明显，残差随着x的变大而变大。</p><img src="/blog/2020/01/16/lm-assumptions/plot_5.png" class="" title="x和残差的散点图"><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>线性回归模型的前提是模型满足假设，这是科学研究的规范，在公司里生成研究报告时，也应该做相应的检查。</p><p>在 R 语言里查看这几个假设很简单，只需要在 <code>fit = lm(y ~ x)</code>使用<code>plot(fit)</code>函数。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/16/lm-assumptions/assumption.png&quot; class=&quot;&quot; title=&quot;假设&quot;&gt;
&lt;p&gt;数据可以骗人，这个道理大家都知道。我印象最深的经历是：同事给了一个基于 linear regression 的研究报告，但报告完全没有对线性回归的假设做&lt;strong&gt;任何诊断&lt;/strong&gt;。不做假设检验的分析报告在大学作业里会被判断为不及格。&lt;/p&gt;
&lt;p&gt;但这份报告在业务部门中传阅，成为了产品的决策依据。这是一个上市公司，报告分析的产品也是公司的现金牛产品。&lt;/p&gt;
&lt;p&gt;糟糕的数据分析，最好的结果是浪费了大家的时间，最坏的结果是指导决策者做出错误的决策。&lt;/p&gt;
&lt;p&gt;这篇文章小结一下 linear regression 的几个核心假设，就当是大学知识的一次复习。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计理论" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
</feed>
