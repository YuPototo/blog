<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>商业与数据</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-11T08:59:56.103Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yu Qin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ggplot系列之：boxplot</title>
    <link href="http://yoursite.com/2019/04/15/2019-04-15-ggplot%E7%B3%BB%E5%88%973/"/>
    <id>http://yoursite.com/2019/04/15/2019-04-15-ggplot%E7%B3%BB%E5%88%973/</id>
    <published>2019-04-15T01:07:33.000Z</published>
    <updated>2020-01-11T08:59:56.103Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2019/04/15/2019-04-15-ggplot%E7%B3%BB%E5%88%973/plot_2.png" class="" title="各大俱乐部的工资结构"><p>数据可视化的常见场景之一是：展示一个 categorical variable 和一个 numeric variable 的关系。</p><p>这时我们可以使用 boxplot。</p><p>这里使用了 <a href="https://www.kaggle.com/karangadiya/fifa19/data" target="_blank" rel="noopener">FIFA 的球员数据集</a>。</p><a id="more"></a><h2 id="大球队的工资状况如何？"><a href="#大球队的工资状况如何？" class="headerlink" title="大球队的工资状况如何？"></a>大球队的工资状况如何？</h2><p>我们想展示几个大球队的工资状况，涉及两个变量：</p><ul><li>球队：categorical variable</li><li>每个球员的工资：numerical variable</li></ul><p>我们先提取几个大俱乐部的数据，并把周薪修改为万欧：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要俱乐部</span></span><br><span class="line">clubs &lt;- c(<span class="string">'Real Madrid'</span>, <span class="string">'FC Barcelona'</span>, </span><br><span class="line">           <span class="string">'Manchester United'</span>, <span class="string">'Manchester City'</span>, <span class="string">'Liverpool'</span>, <span class="string">'Chelsea'</span>, <span class="string">'Arsenal'</span>,</span><br><span class="line">           <span class="string">'Borussia Dortmund'</span>, <span class="string">'FC Bayern München'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wage_to_number &lt;- <span class="keyword">function</span>(wage) {</span><br><span class="line">  <span class="comment"># 把周薪转换成万欧</span></span><br><span class="line">  number_in_string &lt;- str_extract(wage, <span class="string">'\\d+'</span>)</span><br><span class="line">  number_in_1000 &lt;- as.numeric(number_in_string)</span><br><span class="line">  number_in_1000 * <span class="number">1000</span> / <span class="number">10000</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sub_dat &lt;- dat %&gt;%</span><br><span class="line">  filter(Club %<span class="keyword">in</span>% clubs) %&gt;%</span><br><span class="line">  mutate(Wage = wage_to_number(Wage))</span><br></pre></td></tr></tbody></table></figure><p>下面制作 boxplot：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ggplot(sub_dat) +</span><br><span class="line">  geom_boxplot(aes(x = Club, y = Wage)) +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>,</span><br><span class="line">       y = <span class="string">'工资（周薪：万欧）'</span>,</span><br><span class="line">       title = <span class="string">'各大俱乐部的工资结构'</span>) +</span><br><span class="line">  coord_flip() </span><br></pre></td></tr></tbody></table></figure><p>结果如图：</p><img src="/blog/2019/04/15/2019-04-15-ggplot%E7%B3%BB%E5%88%973/plot_0.png" class="" title="各大俱乐部的工资结构"><p>从这个图可以看到：</p><ul><li>西超双雄、曼城和尤文图斯的工资中位数最高</li><li>多特蒙德的工资水平最低，确实是这几个队里经济实力最低的</li><li>利物浦、切尔西、阿森纳、拜仁在维持相对均衡的收入的同时，还允许超级巨星有高收入</li><li>巴塞罗那有一个收入最高的家伙，不用想，当然是梅西啦</li></ul><h2 id="我们想标注出几个离群值"><a href="#我们想标注出几个离群值" class="headerlink" title="我们想标注出几个离群值"></a>我们想标注出几个离群值</h2><p>有几个球队有收入远远高于队友的球员，我们想看看他们究竟是谁（虽然猜也能猜到了 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8">😊</span>)，并把他们的名字标注在图片上。</p><p>先清理数据：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">outliner_club &lt;- c(<span class="string">'FC Barcelona'</span>, <span class="string">'Liverpool'</span>, <span class="string">'Chelsea'</span>, <span class="string">'Arsenal'</span>, <span class="string">'FC Bayern München'</span>)</span><br><span class="line">outliner_player &lt;- sub_dat %&gt;% </span><br><span class="line">  filter(Club %<span class="keyword">in</span>% outliner_club) %&gt;%</span><br><span class="line">  group_by(Club) %&gt;%</span><br><span class="line">  filter(Wage == max(Wage))</span><br></pre></td></tr></tbody></table></figure><p>我们提取出了几个有离群值的俱乐部收入最高的球员。</p><p>然后，我们在图片上添加 label：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ggplot(sub_dat, aes(x = Club, y = Wage)) +</span><br><span class="line">  geom_boxplot() +</span><br><span class="line">  geom_label(data = outliner_player,</span><br><span class="line">             aes(label = Name),</span><br><span class="line">             nudge_x = <span class="number">0.25</span>,</span><br><span class="line">             nudge_y = <span class="number">0.25</span>, </span><br><span class="line">             label.size = <span class="number">0.1</span>) +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>,</span><br><span class="line">       y = <span class="string">'工资（周薪：万欧）'</span>,</span><br><span class="line">       title = <span class="string">'各大俱乐部的工资结构'</span>) +</span><br><span class="line">  coord_flip() </span><br></pre></td></tr></tbody></table></figure><p>结果如下：</p><img src="/blog/2019/04/15/2019-04-15-ggplot%E7%B3%BB%E5%88%973/plot_1.png" class="" title="各大俱乐部的工资结构+离群值"><p>各个全队的异常高收入球员如下：</p><ul><li>巴萨：梅西</li><li>切尔西：C罗</li><li>拜仁：J罗</li><li>利物浦：萨拉赫</li><li>切尔西：阿扎尔</li><li>阿森纳：奥巴梅杨</li></ul><p>有意思的是，利物浦的最高薪球员萨拉赫，薪资水平在皇马也只属于前1/4，在巴萨甚至不到梅西的一半。可见西超双雄的购买力了。</p><h2 id="给曼联上色"><a href="#给曼联上色" class="headerlink" title="给曼联上色"></a>给曼联上色</h2><p>作为一个曼联球迷，我想给曼联的 box 涂上曼联红色，然后给死敌利物浦涂上他们死敌埃弗顿的蓝色 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8">😃</span>，我该怎么办呢？</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sub_dat &lt;- sub_dat %&gt;%</span><br><span class="line">  mutate(isManU = case_when(</span><br><span class="line">    Club == <span class="string">'Manchester United'</span> ~ <span class="string">'ManU'</span>,</span><br><span class="line">    Club == <span class="string">'Liverpool'</span> ~ <span class="string">'Liv'</span>,</span><br><span class="line">    <span class="literal">TRUE</span> ~ <span class="string">'rest'</span></span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">ggplot(sub_dat) +</span><br><span class="line">  geom_boxplot(aes(x = Club, y = Wage, fill=isManU)) +</span><br><span class="line">  scale_fill_manual(breaks = c(<span class="string">"Liv"</span>, <span class="string">"ManU"</span>, <span class="string">"rest"</span>), </span><br><span class="line">                    values=c(<span class="string">"#003399"</span>, <span class="string">"#DA291C"</span>, <span class="string">"white"</span>)) +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>,</span><br><span class="line">       y = <span class="string">'工资（周薪：万欧）'</span>,</span><br><span class="line">       title = <span class="string">'各大俱乐部的工资结构'</span>) +</span><br><span class="line">  coord_flip()  +</span><br><span class="line">  theme(legend.position = <span class="string">"none"</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果如下图：</p><img src="/blog/2019/04/15/2019-04-15-ggplot%E7%B3%BB%E5%88%973/plot_2.png" class="" title="各大俱乐部的工资结构"><p>希望利物浦球迷看到了不要打我 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f4a3.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a3.png?v8">💣</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2019/04/15/2019-04-15-ggplot%E7%B3%BB%E5%88%973/plot_2.png&quot; class=&quot;&quot; title=&quot;各大俱乐部的工资结构&quot;&gt;

&lt;p&gt;数据可视化的常见场景之一是：展示一个 categorical variable 和一个 numeric variable 的关系。&lt;/p&gt;
&lt;p&gt;这时我们可以使用 boxplot。&lt;/p&gt;
&lt;p&gt;这里使用了 &lt;a href=&quot;https://www.kaggle.com/karangadiya/fifa19/data&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FIFA 的球员数据集&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据科学：用 R 还是 Python?</title>
    <link href="http://yoursite.com/2019/04/05/2019-04-05-RorPython/"/>
    <id>http://yoursite.com/2019/04/05/2019-04-05-RorPython/</id>
    <published>2019-04-05T08:05:05.000Z</published>
    <updated>2020-01-11T08:59:56.103Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2019/04/05/2019-04-05-RorPython/RorPython.png" class="" title="R or Python"><p>数据科学届最常见的一个争论是：R 和 Python，哪个更好呢？</p><p>我不太喜欢这个问题，因为“好”的标准实在太多，不同场景有不同的标准。就拿这个话题来说，数据初学者为了了解统计学，最合适的肯定是 R；做人工智能的团队为了使用 Tensorflow 等开源工具，最合适的肯定是 python。</p><p>所以在讨论这个话题之前，我先限定好场景：一个大公司内需要进行庞大业务分析的数据团队。在这个场景内，应该使用哪个工具呢？</p><p>我的方案是：R 和 python 都使用，但使用的地方有差异。</p><a id="more"></a><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>python 明显强过 R 的地方有三点：</p><ul><li>生态：python 的各种 library 实在是太强大了</li><li>机器学习和人工只能</li><li>python 是更“优雅”的语言</li></ul><p>先说生态。如果我想做 http 访问，我会使用 python 的 requests 包。如果我想写爬虫，我会使用 python 的 scrapy 包。如果我想连接 SQL 数据库，我会使用 SQLAlchemy 包…..所有计算机工作，几乎都能在 python 上找到对应的工具。而且，这些工具大概率比 R 语言的 library 要强大。毕竟，给 R 语言写工具的，一般是统计学家，给 python 写工具的，一般是 coder，后者的工具开发能力、文档的可读性都强于前者。</p><p>再说机器学习和人工智能，python 是这个领域的默认工具，tensorflow、pytorch 等开源方案都优先支持 python。</p><p>Python 创建之初，就是在设计一个“简单易用”的语言（这里的“简单易用”要打一个双引号，因为牺牲了其他的东西，但这对数据分析影响不大）。写 python 代码是一种享受。阅读写得好的 python 代码也是一种享受。</p><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><p>R 比 python 强大的地方也有两点：</p><ul><li>R是专门为统计学设计的语言</li><li>强大的统计生态</li></ul><p>R 是专门为统计学设计的语言，python 是更底层的语言，所以做统计分析时，python 需要使用 pandas 等 package，而 R 可以快速上手，直接开始分析。想要使用 python 做数据分析，其实需要学习两个东西：python 和 pandas。</p><p>python 有强大的整体生态，R 则有强大的统计生态。至少在我写这篇文章时，统计学届的默认分析语言基本是 R 语言。世界上最新的统计方法，都能在 R 语言中找到。</p><p>另外，R 语言的数据清洗工具、数据可视化工具和数据报告工具都强过 python（当然，这是个人观点）。</p><ul><li>数据清洗：Hadly Wickham 大神的 tidyverse 系列简直是人类智慧的结晶，这套工具集把数据清洗变成了一种享受。</li><li>数据可视化：还是 Hadly Wickham 大神的 ggplot 工具，帮助我们重新重构了数据可视化的思考模式。</li><li>数据报告工具：这要感谢中国的 Yihui 大神，他的 knitr、rmarkdown 等工具，让数据报告的产出变得更轻松、简答且科学规范。</li></ul><h2 id="python-和-R-结合"><a href="#python-和-R-结合" class="headerlink" title="python 和 R 结合"></a>python 和 R 结合</h2><p>说完了两者的优点，现在来说说如何结合两者。</p><p>我使用 python 的场合：</p><ul><li>与数据库的沟通（代替 SQL 语句），因为 SQLAlchemy 的 API 写得非常好</li><li>Restful API 访问，使用 requests 包</li><li>非结构化数据的获取和清洗</li><li>机器学习</li></ul><p>我使用 R 的场合：</p><ul><li>规范性数据的清洗</li><li>统计学假设检验</li><li>统计学建模</li><li>数据可视化和数据报告</li></ul><p>上面的使用场景应该是最能发挥两者优势的。不过按照 python 生态的发展速度，也许很快 python 就会在统计学、可视化和报告产出上超过 R 语言。如果到了那一天，也许只使用 python 就够了。</p><h2 id="如果一定要二选一呢"><a href="#如果一定要二选一呢" class="headerlink" title="如果一定要二选一呢"></a>如果一定要二选一呢</h2><p>如果必须要2选1呢？这个时候当然要使用 python 了，原因：</p><ul><li>python 的底层生态实在是太棒了，使用过一次之后很难再愿意去用 R 的方案</li><li>python 一直在高速发展，R 的优秀工具会很快被 python 复制</li></ul><p>当然，学习 python 和 R 都挺容易的，如果只是做数据分析的话，会 python 的人一定可以在两周内掌握 R，反之也成立。</p><p>小孩子才做选择题，成年人全都要。</p><img src="/blog/2019/04/05/2019-04-05-RorPython/all.jpg" class="" title="我全都要"><p>那么，excel 呢？都2019年了，严谨的数据分析团队还是不要把 excel 用来做分析工具了。我唯一能想到的 excel 应用场景，是用来“展示”报告。因为，有的决策者希望看到 excel，而不是一个 Word 文档。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2019/04/05/2019-04-05-RorPython/RorPython.png&quot; class=&quot;&quot; title=&quot;R or Python&quot;&gt;


&lt;p&gt;数据科学届最常见的一个争论是：R 和 Python，哪个更好呢？&lt;/p&gt;
&lt;p&gt;我不太喜欢这个问题，因为“好”的标准实在太多，不同场景有不同的标准。就拿这个话题来说，数据初学者为了了解统计学，最合适的肯定是 R；做人工智能的团队为了使用 Tensorflow 等开源工具，最合适的肯定是 python。&lt;/p&gt;
&lt;p&gt;所以在讨论这个话题之前，我先限定好场景：一个大公司内需要进行庞大业务分析的数据团队。在这个场景内，应该使用哪个工具呢？&lt;/p&gt;
&lt;p&gt;我的方案是：R 和 python 都使用，但使用的地方有差异。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据团队的三个角色：数据科学家、数据分析师、数据工程师</title>
    <link href="http://yoursite.com/2018/05/06/2018-05-07-%E6%95%B0%E6%8D%AE%E5%9B%A2%E9%98%9F/"/>
    <id>http://yoursite.com/2018/05/06/2018-05-07-%E6%95%B0%E6%8D%AE%E5%9B%A2%E9%98%9F/</id>
    <published>2018-05-06T18:39:41.000Z</published>
    <updated>2020-01-11T08:59:56.103Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2018/05/06/2018-05-07-%E6%95%B0%E6%8D%AE%E5%9B%A2%E9%98%9F/data.png" class="" title="三者的区别"><p>一般来说，一个完整的数据团队应该由3个角色构成：</p><ul><li>数据分析师 data analyst</li><li>数据工程师 data engineer</li><li>数据科学家 data scientist</li></ul><p>这篇文章总结三个角色的区别，并说明何种情况下团队里应该有这些角色。</p><a id="more"></a><h2 id="三个角色"><a href="#三个角色" class="headerlink" title="三个角色"></a>三个角色</h2><p>三个角色的工作有时会有一定程度的交集，这里只讨论三个角色的最重要差异。</p><ul><li>数据分析师： 需要了解业务，使用<strong>常规的数据分析方法</strong>为日常商业决策提供依据</li><li>数据工程师：创造和维护数据基础设施</li><li>数据科学家：掌握机器学习算法，擅长数学、统计学和编程，可以处理大数据分析需求</li></ul><h3 id="数据分析师"><a href="#数据分析师" class="headerlink" title="数据分析师"></a>数据分析师</h3><p>数据分析师是最常见的角色，已经存在了很多年。早期的数据分析师只需要掌握 Excel 的使用，生成日常数据报表，做一定的数据可视化。一般情况下，数据分析师还需要懂业务，并通过数据对商业决策提供建议。</p><p>稍微进阶的数据分析师，还会懂一些 inferential statistics，使用线性回归等方法做归因和预测。</p><p>随着大家的学习能力越来越强，数据分析已经变成了一个基本技能。在这个环境下，数据分析师的核心价值是什么呢？我认为是“懂业务”。</p><p>数据分析师需要非常了解自己业务的情况，拿游戏来举例，数据分析师应该了解自己所分析的游戏、了解游戏行业的数据特点。SLG 游戏和 ARPG 游戏就是两个完全不同的游戏类型，如果某个核心指标相同（比如7日ROI），数据分析师需要针对两种游戏做不同的判断。同时，数据分析师应该深度体验自己的游戏，并能结合游戏体验提出值得研究的问题。</p><p>因为“懂业务”同时也“懂数据”，数据分析师应该是最能影响项目决策的人。</p><p>数据分析师的常见学科背景：商科、经济学、统计学。</p><h3 id="数据工程师"><a href="#数据工程师" class="headerlink" title="数据工程师"></a>数据工程师</h3><p>数据工程师其实是“需要做数据相关开发工作”的程序员，比如数据存储、数据计算、数据后台的搭建等等。</p><p>在小一些的公司，数据工程师一般由后端开发人员兼任。大型的公司，会需要专门的数据工程师。</p><p>数据工程师的常见学科背景：计算机。</p><h3 id="数据科学家"><a href="#数据科学家" class="headerlink" title="数据科学家"></a>数据科学家</h3><p>数据科学家是最近几年又硅谷带动起来的新兴岗位。数据科学家最核心的特点是：能用<strong>科学的</strong>方法解决企业的数据分析问题。</p><p>为什么这里提到“科学的”方法呢？有两个原因。</p><p>第1，很多数据分析师的分析工作其实充满了主观判断，毫无科学性可言。举个例子，我在某上市游戏公司的数据部门上班时，发现他们的数据分析报告<strong>从来不会</strong>使用假设检验，重要决策只通过画图寻找相关性后“主观判断”。数据分析其实是个有着严格科学基础的工作，专业的数据科学家会让团队的数据决策更加准确。</p><p>第2，大数据的兴起，让数据分析工作从传统的 excel 就能解决变成必须依赖高强度的编程能力和数学能力。</p><p>数据科学家有如下特点：</p><ul><li>高学历</li><li>强大的数学和统计学能力</li><li>了解机器学习、NLP 等新兴数据分析领域的情况</li><li>强大的（数学）编程水平</li></ul><p>相比于数据分析师，数据科学家可能不是那么懂业务。<br>相比于数据工程师，数据科学家又不是那么懂数据库、API。</p><p></p><h2 id="三个角色的需求"><a href="#三个角色的需求" class="headerlink" title="三个角色的需求"></a>三个角色的需求</h2><p>数据分析师：大中小型团队都需要的角色<br>数据工程师：大型团队需要<br>数据科学家：大型团队需要</p><p>我了解的美国某著名游戏公司的情况：</p><ul><li>每一个项目里都有数据分析师，专门负责这个项目的分析工作和决策支持</li><li>数据工程师和数据科学家，不跟随项目走，在项目需要的时候提供工程支持和理论支持</li></ul><p>工作场景举例：</p><ul><li>数据分析师：日常分析需求、数据分析报告</li><li>数据工程师：分析师想要增加10个埋点，工程师满足这个需求</li><li>数据科学家：审查数据分析师的分析报告是否符合科学规范</li></ul><p>对最顶级的公司，竞争的核心点其实是数据科学家。一个强大的数据科学家团队，可以让数据决策的精准度得到巨大提高。因为，数据科学家可以把结论用概率的形式科学的表示出来。（也许某些数据分析师也可以，但我不敢信他们啊）。</p><p>如果没有数据科学家，很有可能出现两种情况：</p><ul><li>数据分析师给出质量无法保证的数据分析结果</li><li>团队依靠“数据可视化”的图像做出“猜测”</li></ul><p>什么叫“团队依靠图像做出猜测”呢？举个让我印象深刻的例子吧。在游戏公司上班时，项目负责人拉数据之后画两个折线图，发现两者都有向上的趋势，于是推测出两者正相关，进而得出了一个行动依据。在懂数据分析的人看来，这大概跟“夜观天象”的靠谱程度差不多吧。一个数据科学家会在这个问题上给出严谨的数学公式、编程计算和结果报告，这就是数据科学家的价值。</p><p>但是，只有在尊重科学的公司，数据科学家的声音才会被重视。这可能也是硅谷才有这么多数据科学家岗位的原因吧啊。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2018/05/06/2018-05-07-%E6%95%B0%E6%8D%AE%E5%9B%A2%E9%98%9F/data.png&quot; class=&quot;&quot; title=&quot;三者的区别&quot;&gt;

&lt;p&gt;一般来说，一个完整的数据团队应该由3个角色构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据分析师 data analyst&lt;/li&gt;
&lt;li&gt;数据工程师 data engineer&lt;/li&gt;
&lt;li&gt;数据科学家 data scientist&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章总结三个角色的区别，并说明何种情况下团队里应该有这些角色。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>closure: 以 python 和 JavaScript 为例</title>
    <link href="http://yoursite.com/2017/03/04/2017-03-05-closure/"/>
    <id>http://yoursite.com/2017/03/04/2017-03-05-closure/</id>
    <published>2017-03-04T16:17:33.000Z</published>
    <updated>2020-01-11T08:59:56.103Z</updated>
    
    <content type="html"><![CDATA[<p>计算机语言里有个常用的概念，叫 closure（闭包）。这里用 python 和 JavaScript 作为对照例子，解释一下 closure 的含义。</p><p>先看一个问题，下面一段 python 代码，会在 terminal 上打印什么呢？</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">func = outer()</span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><p>上面的代码出现了若干次 a，第1个 a 在“最外面”，第2个 a 在 outer 函数里，第3个 a 出现在 inner 函数里，而 inner 函数又在 outer 函数里。</p><p>上面这段话可以用 scope 的概念重新描述：</p><ul><li>第1个 a 在 global scope 中，整段代码都可以使用</li><li>第2个 a 在 outer 函数的 scope 中</li><li>第3个 a 不是个变量，是对变量的使用，那么它会使用第1个a、还是第2个a、还是报错呢？</li></ul><p>答案：terminal 回打印出 1，也就是说，inner 函数使用了 outer 函数里的 a。</p><p>这里有两个值得深究的地方。我们一个个看。</p><h2 id="1-向上查询"><a href="#1-向上查询" class="headerlink" title="1. 向上查询"></a>1. 向上查询</h2><p>先看下面这段代码。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">  print(a)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure><p>在运行 func 函数时，计算机会现在 func 的 scope 寻找 a 变量，但我们没有定义 a 变量，这时计算机会“向上一层”查询，上一层就是 global scope，我们在上一层定义了 a 并令它为 1，计算机就认为自己找到了 a，于是打印出 a 的内容：1。</p><p>同样一段代码，可以在 JavaScript 中轻松实现：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">myFunc()</span><br></pre></td></tr></tbody></table></figure><p>R 中也有类似的设计：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">my_function &lt;- <span class="keyword">function</span>() {</span><br><span class="line">  print(a)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">my_function()</span><br></pre></td></tr></tbody></table></figure><p>我们运行上面3段代码时，都会得到 1。</p><p>在最开始的代码段里，上一层的 a 在 outer 函数里，是1，此时计算机不再往上寻找 a，所以就打印出了 1。如果我们把 outer 函数里的 <code>a = 1</code> 删掉呢？此时代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">func = outer()</span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure><p>因为找不到计算机在 outer 里找不到 a，它继续往上寻找，在 global scope 里找到了 a，于是打印出了 2。</p><p>这样的设计乍看之下不太友好：如果我们不小心在函数里使用了某个 global scope 的变量，计算机就不会报错，而是会继续运行程序。这岂不是不利于代码的稳定性。</p><p>虽然有这个潜在风险，很多语言还是选择了这个设计，自然是因为这个设计是有价值的。价值在哪儿呢？这就涉及到示例代码中第2个值得深究的地方了。</p><h2 id="2-函数可以返回函数"><a href="#2-函数可以返回函数" class="headerlink" title="2. 函数可以返回函数"></a>2. 函数可以返回函数</h2><p>在 python、R 和 JavaScript 里，函数都可以返回函数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">func = outer()</span><br><span class="line">func()</span><br></pre></td></tr></tbody></table></figure><p>我们的 outer 函数的 return 值是一个 inner 函数。<br>通过 <code>func = outer()</code>，我们让 func 变成了 inner 函数。</p><p>这里值得注意的地方是，我们 return 的明明只是 inner 函数，代码里只有 <code>print(a)</code>这行，为什么这个 inner 函数会记住自己所在的 scope 里有个 a 变量呢？这就是 closure 这个概念了。</p><p>当我们在 outer 函数里返回 inner 函数时，与 inner 函数在同一个 scope 里面的变量也会被“包”进 inner 函数中，变成 inner 函数的 private variable。</p><p>这是一个非常有用的概念。</p><h2 id="closure-的应用"><a href="#closure-的应用" class="headerlink" title="closure 的应用"></a>closure 的应用</h2><p>我最喜欢的 closure 应用场景，是批量生成函数。</p><p>问题场景：我需要生成一组幂函数的值，指数分别为 2、3、4, x 分别是 -10 到 10 之间的整数。</p><p>在我不知道 closure 时，我会想生成一个带有2个参数的函数，然后使用 list comprehension。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power_func</span><span class="params">(x, power)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> x ** power</span><br><span class="line"></span><br><span class="line">[ power_func(i, <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br><span class="line">[ power_func(i, <span class="number">3</span>) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br><span class="line">[ power_func(i, <span class="number">4</span>) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br></pre></td></tr></tbody></table></figure><p>这是一个看上去简单的解答，但并不是一个代码层面更“好”的解答。因为，有可能我们想要在多种场合重复使用某几个幂指数的函数，比如幂指数为2的函数，可能在我们的计算里非常常用，这时最好的做法是生成一个幂指数为2的函数，然后重复使用它。</p><p>这时就需要使用 closure了。如果使用 closure，上面的问题会这样解答：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power_func</span><span class="params">(power)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner_func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** power</span><br><span class="line">  <span class="keyword">return</span> inner_func</span><br><span class="line"></span><br><span class="line">power_two = power_func(<span class="number">2</span>)</span><br><span class="line">power_three = power_func(<span class="number">3</span>)</span><br><span class="line">power_four = power_func(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ power_two(i) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br><span class="line">[ power_three(i) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br><span class="line">[ power_four(i) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br></pre></td></tr></tbody></table></figure><p>这段代码看上去更长，但从“思路”上其实方便，代码的可读性也强了非常多。</p><p>类似的思考方式其实是写代码到一定阶段后必然会碰到的：如何抽象地设计出一个生成函数的函数，让我们的代码可读性更高，更加 DRY（ don’t repeat yourself ）。</p><p>同样一段代码，如果使用 JavaScript，可以这样写：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">powerFunc</span>(<span class="params">power</span>) </span>{</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span>(<span class="params">x</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, power)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> innerFunc</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> powerTwo = powerFunc(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> powerThree = powerFunc(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> powerFour = powerFunc(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numRange = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">21</span>), (x,i) =&gt; i - <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numRange.map(<span class="function"><span class="params">el</span> =&gt;</span> powerTwo(el)))</span><br><span class="line"><span class="built_in">console</span>.log(numRange.map(<span class="function"><span class="params">el</span> =&gt;</span> powerThree(el)))</span><br><span class="line"><span class="built_in">console</span>.log(numRange.map(<span class="function"><span class="params">el</span> =&gt;</span> powerFour(el)))</span><br></pre></td></tr></tbody></table></figure><h2 id="JavaScript-的连续箭头函数"><a href="#JavaScript-的连续箭头函数" class="headerlink" title="JavaScript 的连续箭头函数"></a>JavaScript 的连续箭头函数</h2><p>理解了 closure 的概念后，下面这段 JavaScript 代码就很好理解了：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeAddFunc = <span class="function"><span class="params">adder</span> =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> x + adder</span><br></pre></td></tr></tbody></table></figure><p>这其实就是 closure 的箭头函数写法，这里连续使用了两个箭头函数。完整写法如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAddFunc</span>(<span class="params">adder</span>) </span>{</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span>(<span class="params">x</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> x + adder</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> innerFunc</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以用上面的 makeAddFunc 生成若干自己需要的函数：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addTwo = makeAddFunc(<span class="number">2</span>)</span><br><span class="line">addThree = makeAddFunc(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(addTwo(<span class="number">5</span>)) <span class="comment">// print 7</span></span><br><span class="line"><span class="built_in">console</span>.log(addThree(<span class="number">5</span>)) <span class="comment">// print 8</span></span><br></pre></td></tr></tbody></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>个人经验来说，closure 是一个“分水岭”，区分开新手 coder 和中级 coder。</p><p>如果我们对 closure 足够熟悉，我们会发现某些特定的场合简直是为 closure 天然而生。学会在这些场合使用 closure，会让我们的代码质量上一个台阶。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机语言里有个常用的概念，叫 closure（闭包）。这里用 python 和 JavaScript 作为对照例子，解释一下 closure 的含义。&lt;/p&gt;
&lt;p&gt;先看一个问题，下面一段 python 代码，会在 terminal 上打印什么呢？&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; inner&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func = outer()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ggplot系列之二：mosaic图</title>
    <link href="http://yoursite.com/2017/02/03/2017-02-03-ggplot-mosaic/"/>
    <id>http://yoursite.com/2017/02/03/2017-02-03-ggplot-mosaic/</id>
    <published>2017-02-03T04:46:47.000Z</published>
    <updated>2020-01-11T08:59:56.099Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2017/02/03/2017-02-03-ggplot-mosaic/plot_0.png" class="" title="一个mosaic图"><p><a href="https://yupototo.github.io/blog/2017/01/05/2017-01-05-ggplot%E6%95%A3%E7%82%B9%E5%9B%BE/" target="_blank" rel="noopener">上一篇文章</a>介绍了 ggplot 的散点图。散点图太常见了，这篇文章介绍下不那么常见，但用起来很酷的 mosaic 图。</p><p>mosaic 图在如下场景使用：展示两组 categorical data 的情况。</p><a id="more"></a><h2 id="使用-ggmosaic-包"><a href="#使用-ggmosaic-包" class="headerlink" title="使用 ggmosaic 包"></a>使用 ggmosaic 包</h2><blockquote><p>君子性非异也，善假于物也。</p></blockquote><p>ggplot2 可以用柱状图（geom_bar）的方法生成 mosaic 图，需要对参数做一些调整。</p><p>但聪明的开发者们早已经基于 ggplot 封装了一个包：ggmosaic。我们可以像调用 geom_bar 一样调用 geom_mosaic。</p><p>我们先安装 ggmosaic 包：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install.packages(<span class="string">'ggmosaic'</span>)</span><br></pre></td></tr></tbody></table></figure><p>这里使用的是 ggmosaic 包里的 <a href="https://www.rdocumentation.org/packages/ggmosaic/versions/0.2.0/topics/fly" target="_blank" rel="noopener">fly 数据集</a>。</p><p>Fly 数据集调查了乘飞机的礼貌问题，比如：</p><ul><li>你认为在飞机上把座位往后倾斜礼貌吗</li><li>你会倾斜座椅吗</li><li>你觉得带小宝宝坐飞机礼貌吗</li></ul><p>数据共有 1040 行，共27个变量。</p><h2 id="问题1：态度和行为的关系"><a href="#问题1：态度和行为的关系" class="headerlink" title="问题1：态度和行为的关系"></a>问题1：态度和行为的关系</h2><p>我想了解的问题是：觉得倾斜座椅很粗鲁都人，自己会倾斜座椅吗？换句话说，大家言行合一吗？</p><p>我的猜测是：觉得倾斜椅子粗鲁的人，自己应该也不怎么会倾斜椅子。</p><p>代码如下：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ggplot(data = fly) + </span><br><span class="line">  geom_mosaic(aes(x = product(RudeToRecline), fill=DoYouRecline)) +</span><br><span class="line">  labs(title = <span class="string">'倾斜座椅的态度 vs 行为'</span>,</span><br><span class="line">       x = <span class="string">'你觉得倾斜座椅粗鲁吗'</span>, </span><br><span class="line">       y = <span class="string">'你倾斜座椅吗'</span>,</span><br><span class="line">       fill = <span class="string">'你倾斜座椅吗'</span>)</span><br></pre></td></tr></tbody></table></figure><p>图片如下（为了 x 轴坐标的展示，图片拉长了）：</p><img src="/blog/2017/02/03/2017-02-03-ggplot-mosaic/plot_1.png" class="" title="态度和行为"><p>可以从图中看到，认为座椅倾斜很粗鲁的人，确实也更不会倾斜座椅。符合猜测。</p><h2 id="问题2：有小孩的人是否更能容忍小孩呢"><a href="#问题2：有小孩的人是否更能容忍小孩呢" class="headerlink" title="问题2：有小孩的人是否更能容忍小孩呢"></a>问题2：有小孩的人是否更能容忍小孩呢</h2><p>数据集中有这么两个变量：</p><ul><li>你是否有18岁以下的小孩</li><li>你觉得带小宝宝坐飞机粗鲁吗</li></ul><p>这让我产生了一个猜想：有小孩的人会更能容忍别人带小宝宝。</p><p>为了验证这个假设，我们对上面两个变量做个 mosaic 图。</p><p>代码如下：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ggplot(data = fly) + </span><br><span class="line">  geom_mosaic(aes(x = product(Child18), fill=RudeToBringBaby)) +</span><br><span class="line">  labs(title = <span class="string">'“有小孩"和"觉得带小宝宝乘飞机粗鲁吗"的关系'</span>,</span><br><span class="line">       x = <span class="string">'你有18岁以下的小孩吗'</span>, </span><br><span class="line">       y = <span class="string">'带小宝宝乘飞机粗鲁吗'</span>,</span><br><span class="line">       fill = <span class="string">'带小宝宝乘飞机粗鲁吗'</span>)</span><br></pre></td></tr></tbody></table></figure><p>图片结果如下：</p><img src="/blog/2017/02/03/2017-02-03-ggplot-mosaic/plot_2.png" class="" title="带宝宝乘飞机"><p>可以从图片中看出，有18岁小孩的人，更倾向于认为带宝宝坐飞机是不粗鲁的。</p><h2 id="问题3：年纪越大是否越能忍受小孩呢？"><a href="#问题3：年纪越大是否越能忍受小孩呢？" class="headerlink" title="问题3：年纪越大是否越能忍受小孩呢？"></a>问题3：年纪越大是否越能忍受小孩呢？</h2><p>我想到一个新问题，是否年纪越大的人越能忍受小孩呢？</p><p>这个问题需要两个变量：</p><ul><li>年龄，在这里也是 categorical data （严格得说是 ordinal data，这里的变量都是，但这里不做区分）</li><li>你觉得带小宝宝坐飞机粗鲁吗</li></ul><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ggplot(data = fly) + </span><br><span class="line">  geom_mosaic(aes(x = product(Age), fill=RudeToBringBaby)) +</span><br><span class="line">  labs(title = <span class="string">'"年龄"和“觉得带小宝宝乘飞机粗鲁吗”的关系'</span>,</span><br><span class="line">       x = <span class="string">'你的年龄'</span>, </span><br><span class="line">       y = <span class="string">'带小宝宝乘飞机粗鲁吗'</span>,</span><br><span class="line">       fill = <span class="string">'带小宝宝乘飞机粗鲁吗'</span>)</span><br></pre></td></tr></tbody></table></figure><p>图片结果如下：</p><img src="/blog/2017/02/03/2017-02-03-ggplot-mosaic/plot_3.png" class="" title="年龄和带宝宝乘飞机"><p>可以看出：30岁以下的人会相对不能接受带宝宝乘飞机的行为。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>Mosaic 图适合用在两个 categorical variable 的展示上</li><li>ggmosaic 是个基于 ggplot 的 package，能方便地制作 mosaic 图</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2017/02/03/2017-02-03-ggplot-mosaic/plot_0.png&quot; class=&quot;&quot; title=&quot;一个mosaic图&quot;&gt;

&lt;p&gt;&lt;a href=&quot;https://yupototo.github.io/blog/2017/01/05/2017-01-05-ggplot%E6%95%A3%E7%82%B9%E5%9B%BE/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章&lt;/a&gt;介绍了 ggplot 的散点图。散点图太常见了，这篇文章介绍下不那么常见，但用起来很酷的 mosaic 图。&lt;/p&gt;
&lt;p&gt;mosaic 图在如下场景使用：展示两组 categorical data 的情况。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ggplot系列之一：散点图</title>
    <link href="http://yoursite.com/2017/01/05/2017-01-05-ggplot%E6%95%A3%E7%82%B9%E5%9B%BE/"/>
    <id>http://yoursite.com/2017/01/05/2017-01-05-ggplot%E6%95%A3%E7%82%B9%E5%9B%BE/</id>
    <published>2017-01-05T13:52:50.000Z</published>
    <updated>2020-01-11T08:59:56.095Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2017/01/05/2017-01-05-ggplot%E6%95%A3%E7%82%B9%E5%9B%BE/plot_0.png" class="" title="一个散点图"><p>ggplot2 是 R 语言大神 Hardly Wickham 开发的数据可视化工具。Wickham 为数据可视化抽象出了一套“语法”，掌握这套语法后就可以系统性地生成可视化数据。</p><p>这个系列文章会介绍如何使用 ggplot2 做图。</p><p>本篇介绍最常见的散点图。</p><a id="more"></a><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>每次我拿到数据的第一件事情，就是看看不同变量的散点图长啥样，看到散点图之后，就能对变量之间的关系做一定猜测了。</p><p>我们先准备一份用来画图的数据。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">955</span>)</span><br><span class="line">obs_num &lt;- <span class="number">40</span></span><br><span class="line">dat &lt;- data.frame(cond = rep(c(<span class="string">"A"</span>, <span class="string">"B"</span>), each = obs_num / <span class="number">2</span>),</span><br><span class="line">                  x = <span class="number">1</span>:obs_num + rnorm(obs_num, sd = <span class="number">3</span>),</span><br><span class="line">                  y = <span class="number">1</span>:obs_num + rnorm(obs_num, sd = <span class="number">3</span>))</span><br></pre></td></tr></tbody></table></figure><p>我们的模拟数据有3个变量，x 和 y 是数字，cond 是一个 categorical 变量。</p><h2 id="最简单的散点图"><a href="#最简单的散点图" class="headerlink" title="最简单的散点图"></a>最简单的散点图</h2><p>下面画一个最简单的散点图。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ggplot(dat, aes(x = x, y = y)) + </span><br><span class="line">  geom_point() + </span><br><span class="line">  labs(title = <span class="string">'这是一个最简单的散点图'</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果如下图：<br><img src="plot_1.png" alt="最简单的散点图"></p><h2 id="添加拟合曲线"><a href="#添加拟合曲线" class="headerlink" title="添加拟合曲线"></a>添加拟合曲线</h2><p>有时我们想更清晰地看到数据趋势，ggplot 可以帮我们快速添加一条拟合曲线。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ggplot(dat, aes(x = x, y = y)) + </span><br><span class="line">  geom_point() + </span><br><span class="line">  geom_smooth() +</span><br><span class="line">  labs(title = <span class="string">'带拟合曲线的散点图'</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果如下图：</p><p><img src="plot_2.png" alt="添加拟合曲线的散点图"></p><h2 id="给不同组的点上色"><a href="#给不同组的点上色" class="headerlink" title="给不同组的点上色"></a>给不同组的点上色</h2><p>如果数据中有不同的分组，我们会想在散点图中看到不同组的情况。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ggplot(dat, aes(x = x, y = y, color = cond)) + </span><br><span class="line">  geom_point() + </span><br><span class="line">  labs(title = <span class="string">'需要用颜色分组的散点图'</span>,</span><br><span class="line">       color = <span class="string">'分组'</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果如下图：</p><p><img src="plot_3.png" alt="带颜色的散点图"></p><h2 id="使用-facets"><a href="#使用-facets" class="headerlink" title="使用 facets"></a>使用 facets</h2><p>如果组别太多，上色可能会让人眼花缭乱，这时我们可以使用 facets。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ggplot(dat, aes(x = x, y = y)) + </span><br><span class="line">  geom_point() + </span><br><span class="line">  facet_wrap(~ cond) +</span><br><span class="line">  labs(title = <span class="string">'使用 facets 的散点图'</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果如下图：</p><p><img src="plot_4.png" alt="使用facet的散点图"></p><p>当然，我们也可以把颜色和 cond 结合起来，生成本文最开始那张图片。代码如下：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ggplot(dat, aes(x = x, y = y, color = cond)) + </span><br><span class="line">  geom_point() + </span><br><span class="line">  facet_wrap(~ cond)</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2017/01/05/2017-01-05-ggplot%E6%95%A3%E7%82%B9%E5%9B%BE/plot_0.png&quot; class=&quot;&quot; title=&quot;一个散点图&quot;&gt;

&lt;p&gt;ggplot2 是 R 语言大神 Hardly Wickham 开发的数据可视化工具。Wickham 为数据可视化抽象出了一套“语法”，掌握这套语法后就可以系统性地生成可视化数据。&lt;/p&gt;
&lt;p&gt;这个系列文章会介绍如何使用 ggplot2 做图。&lt;/p&gt;
&lt;p&gt;本篇介绍最常见的散点图。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
