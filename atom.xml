<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>商业与数据</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-20T05:56:50.991Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yu Qin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ggplot 系列之：饼图</title>
    <link href="http://yoursite.com/2020/01/20/ggplot-pie-chart/"/>
    <id>http://yoursite.com/2020/01/20/ggplot-pie-chart/</id>
    <published>2020-01-20T05:20:15.000Z</published>
    <updated>2020-01-20T05:56:50.991Z</updated>
    
    <content type="html"><![CDATA[<p>说到数据可视化，就逃不了饼图。我还记得在学校里做 presentation 的时候，饼图大概是最常见的图片类型。</p><p>这篇文章介绍怎么用 ggplot 做饼图。</p><p><a id="more"></a></p><h2 id="别用饼图"><a href="#别用饼图" class="headerlink" title="别用饼图"></a>别用饼图</h2><p>其实，饼图是糟糕的数据可视化方法，<strong>别用饼图</strong>。</p><p>原因：饼图用面积表示数量的大小，但视觉对面积的感知能力很弱，使用饼图会导致较低的信息传递效率。</p><p>先看下面这个饼图：</p><img src="/blog/2020/01/20/ggplot-pie-chart/pie_1.png" class="" title="pie one"><p>上面这个图让人有至少两个困惑：</p><ul><li>第2和第4位是不是一样多呢？</li><li>第1位到底比第2位多多少呢？</li></ul><p>一个更好的可视化，是使用柱状图：</p><img src="/blog/2020/01/20/ggplot-pie-chart/bar_1.png" class="" title="bar one"><p>柱状图符合人类进化的结果：眼睛对长度的敏锐度远远高于面积。</p><h2 id="Less-is-More"><a href="#Less-is-More" class="headerlink" title="Less is More"></a>Less is More</h2><p>有的时候，我们可能想通过饼图强调某一个分类的占比最大。其实这里也可以用柱状图。</p><p>先看下图：<br><img src="/blog/2020/01/20/ggplot-pie-chart/pie_2.png" class="" title="pie two"></p><p>使用饼图已经足够给人困扰了，使用3D形式简直就是在犯罪。</p><p>看看Joey Cherdarchuk的优化成果：<br><img src="/blog/2020/01/20/ggplot-pie-chart/bar_2.png" class="" title="bar two"></p><p>清晰，简洁，美观，舒服。</p><p><a href="https://www.darkhorseanalytics.com/blog/salvaging-the-pie" target="_blank" rel="noopener">Joey Cherdarchuk 的原文</a>一步步把前面那个丑陋的饼图简化成了后面的样子，非常震撼。</p><h2 id="如何用-ggplot-做饼图"><a href="#如何用-ggplot-做饼图" class="headerlink" title="如何用 ggplot 做饼图"></a>如何用 ggplot 做饼图</h2><p>回答最开始提出的问题，如何用 ggplot 做饼图呢？答案：<strong>别做饼图，改用柱状图</strong>。</p><p>如果你真的非饼图不画，ggplot 可能不是个好工具。饼图的缺点基本已经是统计学届的共识，所以 ggplot 完全没有提供制作饼图的 <code>geom_pie</code>。</p><p>当然，ggplot 灵活的语法还是可以画出饼图的，可以先用<code>geom_bar</code>，然后做一个坐标变换<code>coord_polar</code>。具体代码可以<a href="http://www.sthda.com/english/wiki/ggplot2-pie-chart-quick-start-guide-r-software-and-data-visualization" target="_blank" rel="noopener">参考这里</a>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到数据可视化，就逃不了饼图。我还记得在学校里做 presentation 的时候，饼图大概是最常见的图片类型。&lt;/p&gt;
&lt;p&gt;这篇文章介绍怎么用 ggplot 做饼图。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>Python OOP 之 Property</title>
    <link href="http://yoursite.com/2020/01/20/python-property/"/>
    <id>http://yoursite.com/2020/01/20/python-property/</id>
    <published>2020-01-20T01:54:12.000Z</published>
    <updated>2020-01-20T05:56:50.995Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习 Python OOP 编程的一个 interface：property。</p><p>OOP 编程有两个常用的概念：getter 和 setter。Property 装饰器是 Python 实现 getter 和 setter 的方式。</p><p>这篇文章用一个例子说明如何使用 property。</p><p><a id="more"></a></p><h2 id="业务代码-v1"><a href="#业务代码-v1" class="headerlink" title="业务代码 v1"></a>业务代码 v1</h2><p>背景：初出茅庐的你，在为公司写一个记录员工信息的系统。</p><p>第1版系统里需要记录员工的姓名和收入。</p><p>员工可以用一个 class 表示，每个 instance 都包含员工的姓名和收入。</p><p>初步掌握 OOP 编程的你，很快完成了第1版代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, income)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.income = income</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'Person <span class="subst">{self.name}</span> with income <span class="subst">{self.income}</span>'</span></span><br><span class="line"></span><br><span class="line">Tom = Person(name = <span class="string">'Tom'</span>,</span><br><span class="line">             income = <span class="number">3000</span>)</span><br><span class="line">print(Tom) <span class="comment"># Person Tom with income 3000</span></span><br><span class="line">Tom.income = <span class="number">5000</span></span><br><span class="line">print(Tom.income)  <span class="comment"># 5000</span></span><br></pre></td></tr></tbody></table></figure><p>然后老板提出了一个需求：我们是社会主义国家的企业，为了体现社会主义的先进性，员工工资只能增加，不能减少，你要把这个特点写到系统里。</p><p>这个神奇的需求当然很容易实现，不需要修改 <code>Person</code> 这个对象的代码，只需要在客户端用 POST 方法修改工资时做一个条件判断，这个需求大概只需要3分钟完成。</p><p>可是，你仔细思考了老板的话，如果只是在 Restful API 上做检查，岂不只是“表面文章”，社会主义的先进性，难道不是应该体现在 object 层面吗？</p><p>于是，你决定实现一个功能：修改 income 时，如果 income 不增加，会报错。</p><h2 id="测试逻辑"><a href="#测试逻辑" class="headerlink" title="测试逻辑"></a>测试逻辑</h2><p>除了实现老板的需求外，你还有另一个追求：你希望 <code>Person</code> 对象的 API 不会改变，也就是说，新版本的 <code>Person</code> 对象会实现对低版本的兼容。</p><p>完成新的<code>Person</code>后，你要做两个测试。</p><p>第1个测试：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tom = Person(name = <span class="string">'Tom'</span>,</span><br><span class="line">             income = <span class="number">3000</span>)</span><br><span class="line">print(Tom) <span class="comment"># Person Tom with income 3000</span></span><br><span class="line">Tom.income = <span class="number">5000</span></span><br><span class="line">print(Tom.income)  <span class="comment"># 5000</span></span><br></pre></td></tr></tbody></table></figure><p>上面这段代码的运行结果，要跟第1个版本一样。</p><p>第2个测试：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tom = Person(name = <span class="string">'Tom'</span>,</span><br><span class="line">             income = <span class="number">3000</span>)</span><br><span class="line">Tom.income = <span class="number">1000</span></span><br></pre></td></tr></tbody></table></figure><p>在运行到<code>Tom.income = 1000</code>时，会报错。</p><h2 id="业务代码-v2"><a href="#业务代码-v2" class="headerlink" title="业务代码 v2"></a>业务代码 v2</h2><p>然后，你开始研究怎么实现新的需求。聪明的你很快发现，Property 是实现上述需求的好方法。</p><p>新版本代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, income)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self._income = income  <span class="comment">#第4行</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  @property  #第6行</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">income</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._income</span><br><span class="line">  </span><br><span class="line"><span class="meta">  @income.setter  #第10行</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">income</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> value &lt; self.income :</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">"收入不能减少"</span>)</span><br><span class="line">    self._income = value</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'Person <span class="subst">{self.name}</span> with incom <span class="subst">{self.income}</span>'</span></span><br></pre></td></tr></tbody></table></figure><p>我们依次查看这段代码里的新东西。</p><h3 id="第4行：self-income-income"><a href="#第4行：self-income-income" class="headerlink" title="第4行：self._income = income"></a>第4行：<code>self._income = income</code></h3><p>这里用 _ 表示 private variable。</p><p>Python 其实没有真正的 private variable。下面这段代码会正常返回 <code>_income</code>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, income)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self._income = income </span><br><span class="line"></span><br><span class="line">Tom = Person(name=<span class="string">'Tom'</span>, income = <span class="number">3000</span>)</span><br><span class="line">print(Tom._income) <span class="comment"># 打印出 3000</span></span><br></pre></td></tr></tbody></table></figure><p>使用 _ 表示 private variable，其实是一种约定俗成。Python 有非常多的约定俗成，比如 class 里的<code>self</code>，其实也可以用其他字段代替。</p><h3 id="第6行：-property"><a href="#第6行：-property" class="headerlink" title="第6行：@property"></a>第6行：<code>@property</code></h3><p><code>@property</code> 装饰器把 income 变成了一个 <strong>getter</strong>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ....省略 class 的代码</span></span><br><span class="line"></span><br><span class="line">Tom = Person(name=<span class="string">'Tom'</span>, income = <span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">print(Tom.income) <span class="comment"># 打印出 3000</span></span><br></pre></td></tr></tbody></table></figure><p>此时我们不需要使用<code>Tom._income</code>，只需要像第1版一样用<code>Tom.income</code>就能获取 <code>_income</code>的内容。</p><p>如果没有<code>@property</code>装饰器，<code>income</code>就变成了一个<strong>方法</strong>，只能用<code>Tom.income()</code>的方式调用。</p><h3 id="第10行：-income-setter"><a href="#第10行：-income-setter" class="headerlink" title="第10行：@income.setter"></a>第10行：<code>@income.setter</code></h3><p>这是 setter 装饰器，把下面的函数变成了 income 的 setter。</p><p>setter 这个名称很直观，我们会在满足条件后设置 income 的值。</p><p>在之后的函数里，我们检查了新的值是否小于原先的 income，如果不满足条件，我们就 raise 一个错误。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一顿操作后，第2版的业务代码使用 property 实现了老板的需求和 API 的兼容。非常完美。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.geeksforgeeks.org/python-property-function/" target="_blank" rel="noopener">Geeksforgeeks: Python | property() function</a></li><li><a href="https://www.programiz.com/python-programming/property" target="_blank" rel="noopener">Programiz : Python @property</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天学习 Python OOP 编程的一个 interface：property。&lt;/p&gt;
&lt;p&gt;OOP 编程有两个常用的概念：getter 和 setter。Property 装饰器是 Python 实现 getter 和 setter 的方式。&lt;/p&gt;
&lt;p&gt;这篇文章用一个例子说明如何使用 property。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://yoursite.com/categories/Coding/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>理解 JavaScript 的 this</title>
    <link href="http://yoursite.com/2020/01/19/js-this/"/>
    <id>http://yoursite.com/2020/01/19/js-this/</id>
    <published>2020-01-19T16:53:05.000Z</published>
    <updated>2020-01-20T05:56:50.991Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = {</span><br><span class="line">  name: <span class="string">'Harry Potter'</span>,</span><br><span class="line">  myMethod: <span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">myObject.myMethod() <span class="comment">// undefined</span></span><br></pre></td></tr></tbody></table></figure><p>上面这段代码为什么会返回<code>undefined</code>呢？因为万恶的<code>this</code>。</p><img src="/blog/2020/01/19/js-this/this.jpeg" class="" title="wtf is this"><p>MDN 对 <strong>this</strong> 的定义是：代码运行的环境。这句话给我的最大感觉是：what the <em>**</em> is this?</p><p>这里总结下 <strong>this</strong> 的几个用法。</p><p><a id="more"></a></p><h2 id="Default-Binding"><a href="#Default-Binding" class="headerlink" title="Default Binding"></a>Default Binding</h2><p>在 Chrome 浏览器打开 inspector 的 console，输入如下代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.count)</span><br><span class="line">}</span><br><span class="line">Func()</span><br></pre></td></tr></tbody></table></figure><p>console 会显示<code>5</code>。</p><p>因为我们的代码在环境下运行，this 默认绑定到了全局环境。</p><p>在<code>use strict</code>模式下，默认绑定不会发生。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="string">`use strict`</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.count)</span><br><span class="line">}</span><br><span class="line">Func()</span><br></pre></td></tr></tbody></table></figure><p>此时 Chrome 会报错。</p><h2 id="Implicit-Binding"><a href="#Implicit-Binding" class="headerlink" title="Implicit Binding"></a>Implicit Binding</h2><p>在 object 里创建函数时，运行函数时的<code>this</code>就是这个对象。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anObj = {</span><br><span class="line">  name: <span class="string">'Harry Potter'</span>,</span><br><span class="line">  callName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">anObj.callName()</span><br></pre></td></tr></tbody></table></figure><p>此时屏幕会打印 Harry Potter。</p><h2 id="Explicit-Binding"><a href="#Explicit-Binding" class="headerlink" title="Explicit Binding"></a>Explicit Binding</h2><p>如果不想在 object 创建函数，我们可以手动把函数的<code>this</code>绑定到对象上。</p><p>可以使用<code>bind</code>、<code>call</code>或<code>apply</code>。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anObj = {</span><br><span class="line">  name: <span class="string">'Harry Potter'</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">callName.call(anObj) <span class="comment">// Harry Potter</span></span><br><span class="line">callName.apply(anObj) <span class="comment">// Harry Potter</span></span><br><span class="line"></span><br><span class="line">newCallname = callName.bind(anObj)</span><br><span class="line">newCallname() <span class="comment">// Harry Potte</span></span><br></pre></td></tr></tbody></table></figure><p><code>call</code> 和 <code>apply</code> 可以直接以 object 作为 argument。<br><code>bind</code> 需要指向一个新的变量。</p><h2 id="new-Binding"><a href="#new-Binding" class="headerlink" title="new Binding"></a><code>new</code> Binding</h2><p>创建 class 的 instance 时，<code>this</code> 会指向这个 instance</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>{</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) {</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  showCoord() {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">p1.showCoord()  <span class="comment">// 1, 2</span></span><br><span class="line"></span><br><span class="line">p2 = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">p2.showCoord()  <span class="comment">// 3, 4</span></span><br></pre></td></tr></tbody></table></figure><p>每个 instance 都会有自己的 context。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数的<code>this</code>跟普通函数不一样，箭头函数会继承 parent scope 的<code>this</code>。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Ron Weasley'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObject = {</span><br><span class="line">  name: <span class="string">'Harry Potter'</span>,</span><br><span class="line">  myMethod: <span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">myObject.myMethod() <span class="comment">// Ron Weasley</span></span><br></pre></td></tr></tbody></table></figure><p>在上面这段代码里，我们用箭头函数定义了 myMethod，结果屏幕打印的是 global context 里的 <code>name</code>，因为 <code>myObject</code> 位于 global context。</p><p>如果是在<code>use strict</code>下，上面这段代码会打印<code>undifined</code>。</p><p>所以，谨慎在箭头函数里使用<code>this</code>，非常容易出错啊。</p><p>既然不能使用箭头函数，上面这段的代码要怎么写才更简洁呢？用 ES6 的函数写写法：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = {</span><br><span class="line">  name: <span class="string">'Harry Potter'</span>,</span><br><span class="line">  myMethod() {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">myObject.myMethod() <span class="comment">// Harry Potter</span></span><br></pre></td></tr></tbody></table></figure><p>搞清楚上面这些用法后，<code>this</code> 就没那么奇怪了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; myObject = {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  name: &lt;span class=&quot;string&quot;&gt;&#39;Harry Potter&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  myMethod: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myObject.myMethod() &lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这段代码为什么会返回&lt;code&gt;undefined&lt;/code&gt;呢？因为万恶的&lt;code&gt;this&lt;/code&gt;。&lt;/p&gt;
&lt;img src=&quot;/blog/2020/01/19/js-this/this.jpeg&quot; class=&quot;&quot; title=&quot;wtf is this&quot;&gt;
&lt;p&gt;MDN 对 &lt;strong&gt;this&lt;/strong&gt; 的定义是：代码运行的环境。这句话给我的最大感觉是：what the &lt;em&gt;**&lt;/em&gt; is this?&lt;/p&gt;
&lt;p&gt;这里总结下 &lt;strong&gt;this&lt;/strong&gt; 的几个用法。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://yoursite.com/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>为什么顶级的数据团队应该做 reproducible research</title>
    <link href="http://yoursite.com/2020/01/19/reproducible-research/"/>
    <id>http://yoursite.com/2020/01/19/reproducible-research/</id>
    <published>2020-01-19T10:07:01.000Z</published>
    <updated>2020-01-20T05:56:50.995Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/19/reproducible-research/plot.jpg" class="" title="plot"><p>Reproducible research （可复制研究）是学术界的一个规范。它的意思是，所有研究都应该是可以“复制”的。如果你给我一个研究报告，你不能只给我看结果，你还要给我看到<strong>整个分析过程</strong>，而且我能够在自己的电脑上<strong>复制</strong>出同样的结果。</p><p>经历过几个公司的数据相关业务后，我深深地感觉到：这个规范不只应该用在科学研究里，它应该用在商业公司的数据团队里。</p><p>为什么呢？这篇文章准备论证 reproducible research 的价值。</p><p><a id="more"></a></p><h2 id="传统的分析报告"><a href="#传统的分析报告" class="headerlink" title="传统的分析报告"></a>传统的分析报告</h2><p>为了简化讨论，我们假设数据已经自动搜集并存储在数据仓库中。我们先不讨论研究团队需要自己搜集数据的情况。</p><p>产品经理想了解一个问题：“某个为提升用户留存而设计的新功能是否有效果”。</p><p>某分析师做了如下操作：</p><ul><li>从数据库获取数据，或从数据后台“下载”数据</li><li>把数据导入 excel 中，开始清洗数据</li><li>做某些假设检验、或模型分析</li><li>把分析结果展示在 excel 中，或另外写一份 word 报告</li></ul><p>在这份报告里，阅读者的所有信息都是分析师提供的。作为天生的怀疑论者，我会有如下问题：</p><ul><li>怎么判断报告作者使用了“正确”的数据源？例子：日期搞错了。</li><li>怎么判断作者正确清洗了数据？例子：float 变 int。</li><li>怎么判断作者做了需要做的检验？例子：使用 lm 模型却没检查假设是否能被满足。</li><li>怎么判断作者没有为了推销自己的结论而“调整”数据？例子：对应该标准化的数据没做标准化。</li><li>……</li></ul><p>上面这些问题可以总结为：<strong>怎么知道分析师没有犯错，无论是有意的错误还是无意的错误</strong>。按照传统的方法，“找分析 bug”是个成本很高的活儿。我们几乎只能被动接受分析师给的结果。当然，我们也能对 excel 里的函数和数据做严格检查，但成本实在太高。</p><p>这意味着，我们没有办法系统性地保证数据分析的质量。一个小公司也许可以容忍这样的错误可能，但对严重依赖数据做出决策、并且需要做出大量决策的公司，这不是最优解。</p><h2 id="一个可复制的分析报告"><a href="#一个可复制的分析报告" class="headerlink" title="一个可复制的分析报告"></a>一个可复制的分析报告</h2><p>用可复制的分析报告，上面的研究问题会用下面的方法做。</p><h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><p>要求：数据的获取必须调用 API 或者写 SQL 语句。</p><p>作用：</p><ul><li>当我拿到你的分析，我能复制这段代码，然后调出完全一样的数据</li><li>如果我怀疑原数据有问题，我可以检查代码，判断是不是取数据的代码写错了</li></ul><p>禁止行为：在后台“下载”数据。没人知道你在下载前做了哪些操作。“下载”动作不可复制，而且充满风险。</p><h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>要求：</p><ul><li>清洗数据必须使用代码完成。</li><li>整个数据清洗流程，都用注释清晰的标注。</li></ul><p>作用：其他人能检查整个分析流程，判断是否有某些地方出错。</p><p>禁止行为：在 excel 或其他工具上用鼠标点选完成数据清洗。鼠标点选也是不可复制的，不只别人复制不了，分析师自己都很难复制（也许第一次分析时点错了某个地方却不自知）。</p><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><p>要求：</p><ul><li>需要给出使用某个分析模型的原因</li><li>需要说明参数选择的过程</li><li>需要用代码展示完整的分析流程</li></ul><p>作用：</p><ul><li>数据分析包含一定的理论知识，也包含很多相对主观的判断，记录判断依据方便大家进行讨论</li><li>方便检查代码正确情况</li></ul><p>禁止行为：不能把数据分析的过程当成“黑箱子”，过程和结果同样重要。</p><h3 id="业务建议"><a href="#业务建议" class="headerlink" title="业务建议"></a>业务建议</h3><p>要求：业务建议需要以正确的分析结果作为依据</p><p>禁止行为：不能为了支撑某个结论而去<strong>挑选</strong>证据</p><p>数据分析的大忌，是先有结论，然后分析。</p><h3 id="报告形式"><a href="#报告形式" class="headerlink" title="报告形式"></a>报告形式</h3><p>要求：</p><ul><li>核心分析内容和分析结论在报告主干部分</li><li>从数据获取到分析部分的代码，都在备注部分，或者放在另一个文件里</li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>目前只有2个选择：</p><ul><li>R：使用 Rmarkdown </li><li>Python：使用 Notebook</li></ul><p>其他工具满足不了“可复制”的需求。</p><p>Excel 呢？严谨的数据团队不应该使用 Excel。</p><h2 id="“可复制研究”的意义"><a href="#“可复制研究”的意义" class="headerlink" title="“可复制研究”的意义"></a>“可复制研究”的意义</h2><p>本质上，“可复制研究” 把数据分析从黑箱子变成了可以审阅的文本，发现分析错误变得相对便宜。</p><p>它让每个人的工作都变得 accountable。每一行代码、每一个分析决策，都被暴露在光天化日之下，东郭先生就无处藏身了。想象一下，写了你名字的报告上竟然有低级的数据清洗错误，这是件多么丢人的事情。</p><p>整体上，“可复制研究”会提高整个数据团队的分析质量。</p><p>我还没有机会在这样的团队工作，但过去的经历让我知道“普通”的数据分析团队可以糟糕到什么程度。看到某些分析师的报告，会让你怀疑他们是否上过统计学入门课。我一直为使用这些报告的决策者捏把汗。</p><p>当然，可复制研究也对团队成员的能力有巨大的要求：</p><ul><li>必须会 R 或 Python，会还不够，还必须能写出 readable code （某些号称会 python 的分析师写出来的代码会让阅读者崩溃）</li><li>表达能力要足够强</li><li>有一定的统计基础，能够做到引用文献</li></ul><p>也许只有 FANG 那样的公司才能做到吧(FANG = Facebook + Amazon + Netflix + Google)。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/19/reproducible-research/plot.jpg&quot; class=&quot;&quot; title=&quot;plot&quot;&gt;
&lt;p&gt;Reproducible research （可复制研究）是学术界的一个规范。它的意思是，所有研究都应该是可以“复制”的。如果你给我一个研究报告，你不能只给我看结果，你还要给我看到&lt;strong&gt;整个分析过程&lt;/strong&gt;，而且我能够在自己的电脑上&lt;strong&gt;复制&lt;/strong&gt;出同样的结果。&lt;/p&gt;
&lt;p&gt;经历过几个公司的数据相关业务后，我深深地感觉到：这个规范不只应该用在科学研究里，它应该用在商业公司的数据团队里。&lt;/p&gt;
&lt;p&gt;为什么呢？这篇文章准备论证 reproducible research 的价值。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据科学" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 其实很像 Python</title>
    <link href="http://yoursite.com/2020/01/18/js-python/"/>
    <id>http://yoursite.com/2020/01/18/js-python/</id>
    <published>2020-01-18T12:21:29.000Z</published>
    <updated>2020-01-20T05:56:50.991Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/18/js-python/js-py.jpg" class="" title="js-python"><p>在我刚入门 JavaScript 的时候，感觉 JavaScript 是个莫名其妙的语言。在那之前，我真正称得上了解的语言只有 python。写 python 是一种享受，相比之下，写 JavaScript 的体验很“怪异”。</p><p>后来我才直到，JavaScript 是一个在很短时间内创造的语言，是为了在浏览器上运行。我所学习的 JavaScript，还是20多年前的版本。拿老版本的 JavaScript 和今天的 python3 去比较，是挺不合理的。</p><p>在了解到最新的 JS 功能后，JavaScript 突然变得“可爱”了，甚至在某些地方很像 python。</p><p><a id="more"></a></p><h2 id="多行-string"><a href="#多行-string" class="headerlink" title="多行 string"></a>多行 string</h2><p>问题：如何给 string 换行呢？</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poem = <span class="string">"""Programming is fun</span></span><br><span class="line"><span class="string">Except for syntax errors</span></span><br><span class="line"><span class="string">Missing curly brace""</span></span><br></pre></td></tr></tbody></table></figure><p>老版本的 JavaScript 不支持，但现在支持了：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> poem = <span class="string">`Programming is fun</span></span><br><span class="line"><span class="string">Except for syntax errors</span></span><br><span class="line"><span class="string">Missing curly brace`</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="Expression-Interpolation"><a href="#Expression-Interpolation" class="headerlink" title="Expression Interpolation"></a>Expression Interpolation</h2><p>问题：如何方便地在 string 中使用变量呢？</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">print(<span class="string">f'Fifteen is <span class="subst">{a + b}</span> and not <span class="subst">{<span class="number">2</span> * a + b}</span>.'</span>)</span><br></pre></td></tr></tbody></table></figure><p>上面这个功能很实用，让代码的可读性提高了几个档次。JavaScript 也有类似的写法：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Fifteen is <span class="subst">${a + b}</span> and not <span class="subst">${<span class="number">2</span> * a + b}</span>.`</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="Destructuring"><a href="#Destructuring" class="headerlink" title="Destructuring"></a>Destructuring</h2><p>问题：如何同时 assign 几个变量的值呢？</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">x, y, z = numbers</span><br></pre></td></tr></tbody></table></figure><p>Destructuring 在某些场合有用，ES2017 里有了类似的设计：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> [x, y, z] = numbers</span><br></pre></td></tr></tbody></table></figure><h2 id="Spread-Operator"><a href="#Spread-Operator" class="headerlink" title="Spread Operator"></a>Spread Operator</h2><p>问题：如何 assign 数组里的一个变量，并忽略其他变量呢？</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">first, *remaining = numbers</span><br></pre></td></tr></tbody></table></figure><p>下面是 JavaScript 的写法：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> [first, ...remaining] = numbers</span><br></pre></td></tr></tbody></table></figure><h2 id="Rest-Operator"><a href="#Rest-Operator" class="headerlink" title="Rest Operator"></a>Rest Operator</h2><p>问题：如何给函数任意多个 argument 呢？</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myFun</span><span class="params">(*argv)</span>:</span>  </span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> argv:  </span><br><span class="line">        <span class="keyword">print</span> (arg)</span><br><span class="line"></span><br><span class="line">myFun(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br></pre></td></tr></tbody></table></figure><p>在 python 里这个规则叫 <em>wargs。在 JavaScript 里，使用 <code>...</code>，这三个点叫 <em>*rest operator</em></em></p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">product</span>(<span class="params">...args</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> arg</span><br><span class="line">  <span class="keyword">for</span> (arg <span class="keyword">of</span> args) {</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">product(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>问题：如何把一个数组里的数字全部开方</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">list(map(<span class="keyword">lambda</span> x: x * <span class="number">2</span>, numbers))</span><br><span class="line"><span class="comment"># or [x * 2 for x in numbers]</span></span><br></pre></td></tr></tbody></table></figure><p>JavaScript 里使用<strong>箭头函数</strong>：=&gt;</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">numbers.map(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><p>相比 lambda，箭头函数甚至更加 elegant。</p><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>问题：如何创建一个 class</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"({x}, {y})"</span>.format(x=self.x, y=self.y)</span><br></pre></td></tr></tbody></table></figure><p>在 ES2017 之前，JavaScript 的做法：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>{</span><br><span class="line">  <span class="keyword">this</span>.x = x</span><br><span class="line">  <span class="keyword">this</span>.y = y</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>第一次看到上面这段代码时我非常费解，这是什么鬼<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f630.png?v8">😰</span>？现在有新的写法了：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>{</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) {</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  toString() {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>习惯 python 的开发者可以无缝理解了<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8">😆</span>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在 Hacker News 上看到过一句话：</p><blockquote><p>我招人的时候从来不问对方会什么编程语言，因为只要你会一门语言，掌握其他语言都很容易。作为一个工程师，真正重要的不是你会什么语言或框架，而是……</p></blockquote><p>这句话我只记得前半句，现在有点理解为什么编程语言不重要了。不过重要的到底是什么呢？虽然我不是软件工程师，不过还是对这个答案很好奇。</p><p>如果我需要招一个软件工程师，我会希望他/她有什么特质？</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/18/js-python/js-py.jpg&quot; class=&quot;&quot; title=&quot;js-python&quot;&gt;
&lt;p&gt;在我刚入门 JavaScript 的时候，感觉 JavaScript 是个莫名其妙的语言。在那之前，我真正称得上了解的语言只有 python。写 python 是一种享受，相比之下，写 JavaScript 的体验很“怪异”。&lt;/p&gt;
&lt;p&gt;后来我才直到，JavaScript 是一个在很短时间内创造的语言，是为了在浏览器上运行。我所学习的 JavaScript，还是20多年前的版本。拿老版本的 JavaScript 和今天的 python3 去比较，是挺不合理的。&lt;/p&gt;
&lt;p&gt;在了解到最新的 JS 功能后，JavaScript 突然变得“可爱”了，甚至在某些地方很像 python。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://yoursite.com/categories/Coding/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>机器学习 vs. 统计学</title>
    <link href="http://yoursite.com/2020/01/18/statistics-ml/"/>
    <id>http://yoursite.com/2020/01/18/statistics-ml/</id>
    <published>2020-01-18T07:47:56.000Z</published>
    <updated>2020-01-20T05:56:50.995Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/18/statistics-ml/statistic-ml.jpeg" class="" title="线性回归"><p>机器学习和统计学不是一回事，可是机器学习里和统计学里又有很多交集，比如线性回归。两者都使用了相同的理论框架，但强调的东西完全不一样。</p><p>在具体的公司业务场景中，我们需要明确，自己需要的到底是统计学，还是机器学习。两者会对分析场景有不同的需求。</p><p>这篇文章总结两个学科的需求。</p><p><a id="more"></a></p><h2 id="统计学"><a href="#统计学" class="headerlink" title="统计学"></a>统计学</h2><p>统计学至少有两个典型的使用场景：</p><ul><li>使用样本估计总体</li><li>建立解释性模型</li></ul><h3 id="样本估计总体"><a href="#样本估计总体" class="headerlink" title="样本估计总体"></a>样本估计总体</h3><p>问卷调查是公司了解用户的重要手段。我最喜欢的例子是乐高。2004年时，乐高亏损严重。乐高的美国分公司老大跟《星球大战》的版权方谈妥了合作意向，于是飞到丹麦总部跟公司提出这个方案。乐高公司的高层对这个提议非常“震怒”，因为这违背了乐高一直以来“反对暴力”的理念：乐高的产品里一定不会有暴力元素，更别说要出一个名字里带“war”的产品系列了。</p><p>提出这个方案的美国老大动用了一个杀手锏：要不我们对家长做个问卷调查，看看家长们是否愿意为孩子们购买星战题材的乐高。问卷调查的结果说服了保守的乐高高层。《星球大战》系列开启了乐高的新时代，乐高开始频繁与全球大IP合作，各大 IP 为乐高带来了持续十几年的高速增长。</p><p>这里的问卷调查，其实就是统计学的重要应用：问卷调查的样本数据是整体市场数据的有效代表吗？把这个问题更抽象地表达：我只有 x 个样本，我是否能用这 x 个样本去有效的估计总体。</p><p>商业调查可以通过花钱解决样本数量问题，毕竟一份问卷也没多贵，但在医学药物实验里，一个样本就没那么便宜了。一轮药物实验经常只有几十个样本。用这几十个样本去估计总体，难度要大得多。</p><p>在互联网公司，最经常使用的统计学的场景是 A/B 测试，这里的核心问题是：A/B 测试的样本数据，是有效的总体代表吗？换句话说，我们可以通过这几千个样本，判断 A 版本比 B 版本更好吗？</p><h3 id="建立解释性模型"><a href="#建立解释性模型" class="headerlink" title="建立解释性模型"></a>建立解释性模型</h3><p>社会科学的论文需要利用统计学证明自己想描述的理论关系。</p><p>比如：</p><ul><li>收入的决定因素是什么？</li><li>是否存在收入上的性别/种族歧视？</li><li>R&amp;D投入和市场投入对公司长期盈利能力的影响分别有多大？</li><li>……</li></ul><p>所有这些问题，都需要建立一个模型去描述现象，然后通过数据验证这个模型的准确性。这里既存在样本代表性的问题（样本估计总体），还有模型解释力的问题。</p><p>比如在线性回归里，我们关注 R-square，一个好的模型，应该有比较好的 R-square。同时，这个模型应该是“可解释”的。相比机器学习，统计学的模型不能是个“黑箱子”。机器学习可以接受模型的“不可解释”，统计学则要求模型 make sense。</p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>机器学习与统计学有两个大的区别：</p><ul><li>大样本</li><li>以预测为目的</li></ul><h3 id="大样本"><a href="#大样本" class="headerlink" title="大样本"></a>大样本</h3><p>统计学里有100个样本可能就是很大了，一个 excel 表格就能轻松装下。机器学习利用了互联网时代的数据爆发，有海量的数据可供使用。实际上，机器学习已经存在了几十年，但因为没有足够“喂养”模样的数据和算力，一直没能发展，直到互联网时代。</p><p>统计学需要考虑“样本少”的问题，机器学习不只不用担心样本量，有时甚至能用“总体”做计算。</p><p>在大数据的前提下，很多统计学需要担心的问题不存在了。比如小样本下不适合使用某些 test。</p><h3 id="以预测为目的"><a href="#以预测为目的" class="headerlink" title="以预测为目的"></a>以预测为目的</h3><p>机器学习的最核心特征，是以预测为目的，预测准确度越高越好，过程并不重要。</p><p>机器学习<strong>不关心</strong>模型的解释效力。注意，这里说的是”不关心“。有的模型，比如线性回归，允许人对模型过程做解释，但另外一些模型，比如神经网络，很难解释。</p><p>在应用层面，机器学习非常的“务实”：别跟我扯理论，show me the accuracy。</p><p>同样是线性回归，即使用同样的数据集，我们也可能因为目标而不同而有各自的侧重。想象我们是一家连锁蛋糕公司，旗下有100家店铺。我们搜集了过去几年这些店铺的人流量、营业收入、商圈竞争对手数量等信息。我们可以：</p><ul><li>研究哪些因素最影响营业收入。</li><li>预测这些店铺未来的收入。</li></ul><p>上面两个任务都是可以用线性回归来做，但前者会偏重统计学，需要解释力，后者会偏重机器学习，需要预测力。</p><h2 id="如何选择技能点"><a href="#如何选择技能点" class="headerlink" title="如何选择技能点"></a>如何选择技能点</h2><p>单纯的统计学使用者，可以选择忽略机器学习。统计学使用者包括：</p><ul><li>社会科学领域的学者</li><li>咨询公司的数据分析师</li><li>大公司的用户调查团队</li><li>医药学研究者</li><li>…</li></ul><p>数据工作者成千上万，真正有机会用到机器学习解决问题的并不多。</p><p>但是，在互联网公司工作的数据工作者，或者希望在互联网公司做数据工作的人，大概率有机会使用机器学习，这个时候了解机器学习就会非常必要了。从学科脉络来看，机器学习的部分理论基础就是统计学，所以搞机器学习的人，是逃不过学习统计学的。所以，如果你想再互联网公司做数据工作，统计学和机器学习都是要有所了解的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/18/statistics-ml/statistic-ml.jpeg&quot; class=&quot;&quot; title=&quot;线性回归&quot;&gt;
&lt;p&gt;机器学习和统计学不是一回事，可是机器学习里和统计学里又有很多交集，比如线性回归。两者都使用了相同的理论框架，但强调的东西完全不一样。&lt;/p&gt;
&lt;p&gt;在具体的公司业务场景中，我们需要明确，自己需要的到底是统计学，还是机器学习。两者会对分析场景有不同的需求。&lt;/p&gt;
&lt;p&gt;这篇文章总结两个学科的需求。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据科学" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Python 的 Generator</title>
    <link href="http://yoursite.com/2020/01/17/python-generator/"/>
    <id>http://yoursite.com/2020/01/17/python-generator/</id>
    <published>2020-01-17T13:52:13.000Z</published>
    <updated>2020-01-20T05:56:50.995Z</updated>
    
    <content type="html"><![CDATA[<p>问题：x 是一个由数字组成的 list，我们想求出每个元素的平方。</p><p>一个解决方法是：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_numbers</span><span class="params">(nums)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        result.append(i * i)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">my_nums = square_numbers([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">print(my_nums) <span class="comment"># [1, 4, 9, 16]</span></span><br></pre></td></tr></tbody></table></figure><p>这是个正确的答案，但不完美。我们可以使用 generator 写出更简洁的答案：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square_numbers</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">yield</span>(i * i)</span><br><span class="line"></span><br><span class="line">my_nums = square_numbers([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">print(list(my_nums))</span><br></pre></td></tr></tbody></table></figure><p><a id="more"></a></p><h2 id="generator-函数"><a href="#generator-函数" class="headerlink" title="generator 函数"></a>generator 函数</h2><p>普通的函数使用 <code>return</code> 返回结果，<strong>generator 函数</strong>使用 <code>yield</code> 返回结果。</p><p>generator 函数可以使用 <code>next()</code> 获取下一个返回值。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dumb_generator</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">a = dumb_generator()</span><br><span class="line"></span><br><span class="line">print(next(a)) <span class="comment"># 1</span></span><br><span class="line">print(next(a)) <span class="comment"># 2</span></span><br><span class="line">print(next(a)) <span class="comment"># 3</span></span><br><span class="line">print(next(a)) <span class="comment"># 报错：StopIteration</span></span><br></pre></td></tr></tbody></table></figure><p>上面这段代码会在运行<code>next(a)</code>依次返回1、2、3，然后报错。</p><p>我们可以直接把 generator 函数的返回对象用在 for loop 里：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dumb_generator</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">a = dumb_generator()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">  print(i)</span><br></pre></td></tr></tbody></table></figure><p>for loop 在完成循环后会自动停止，不会报错。</p><h2 id="generator-comprehension"><a href="#generator-comprehension" class="headerlink" title="generator comprehension"></a>generator comprehension</h2><p>文章最开始的问题，其实可以用 list comprehension 快速解决：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_nums = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br></pre></td></tr></tbody></table></figure><p>generator 也可以用 comprehension 的形式快速生成：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_nums = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]) <span class="comment"># 这是一个 generator</span></span><br></pre></td></tr></tbody></table></figure><h2 id="为什么使用-generator"><a href="#为什么使用-generator" class="headerlink" title="为什么使用 generator"></a>为什么使用 generator</h2><p>除了方便之外，generator 还有什么好处呢？最大的好处是，节约内存。</p><p>假设生成从1到100万的 list，这个 list 会被存在内存里，占据大量空间。<br>如果生成从1到100万的 generator，内存占用量几乎可以忽略不计。</p><p>另外，generator 还可以用来表达数学上的无穷数列，比如 <a href="https://en.wikipedia.org/wiki/Fibonacci_number" target="_blank" rel="noopener">Finabocci 数列</a>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fib():</span><br><span class="line">  print(i)</span><br><span class="line">  <span class="keyword">if</span> i &gt; <span class="number">1000</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></tbody></table></figure><p>上面的代码会打印出从0开始的 Finabocchi 数列，直到数列大于1000（第18个数字就会大于1000）。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题：x 是一个由数字组成的 list，我们想求出每个元素的平方。&lt;/p&gt;
&lt;p&gt;一个解决方法是：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;square_numbers&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nums)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; nums:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result.append(i * i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;my_nums = square_numbers([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(my_nums) &lt;span class=&quot;comment&quot;&gt;# [1, 4, 9, 16]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是个正确的答案，但不完美。我们可以使用 generator 写出更简洁的答案：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;square_numbers&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nums)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; nums:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt;(i * i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;my_nums = square_numbers([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(list(my_nums))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://yoursite.com/categories/Coding/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>决策树模型里的 Entropy</title>
    <link href="http://yoursite.com/2020/01/17/decision-tree-entropy/"/>
    <id>http://yoursite.com/2020/01/17/decision-tree-entropy/</id>
    <published>2020-01-17T07:06:33.000Z</published>
    <updated>2020-01-20T05:56:50.991Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/17/decision-tree-entropy/decision-tree.png" class="" title="决策树"><p>决策树模型是机器学习的重要模型。决策树里有个概念，叫 entropy，模型的最优化函数基于 entropy 做出。</p><p>用一个诗意的说法，entropy 描述了世界的混乱程度。Split 能帮助降低混乱程度。</p><p>这篇文章用具体例子说明，split 如何降低 entropy。</p><p><a id="more"></a></p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>给定数据集中有 C 个分组，entropy 的公式如下：</p><img src="/blog/2020/01/17/decision-tree-entropy/entropy.png" class="" title="entropy公式"><p>公式中的 pi 是第 c 类元素的出现概率。</p><h2 id="不可知与可知"><a href="#不可知与可知" class="headerlink" title="不可知与可知"></a>不可知与可知</h2><p>想象一个世界上只有“好人”，那么好人的概率是1。因为 log_2(1) = 0，此时的 entropy = 0。</p><p>想象另一个世界，只有坏人，那么好人的概率是0，这时 entropy = -1 * 0 * log_2(1) = 0。</p><p>上面两种情况，如果以 entropy 来描述，都是“可知”的，不存在任何混乱，这是个稳定的世界。</p><p>想象第3个世界：好人和坏人各占一半，那么 entropy = (0.5 * log_2(0.5)) + (0.5 * log_2(0.5)) = 1。</p><p>这是个极端“混乱”的世界，路上随便碰到一个人，你完全不知道他是好人还是坏人。在这里，不确定性达到最大值。</p><h2 id="引入解释变量"><a href="#引入解释变量" class="headerlink" title="引入解释变量"></a>引入解释变量</h2><p>我们还在第3个世界里，作为数据工作者，我们无法忍受这种混乱，于是我们决定建立一个模型，找到识别坏人和好人的方法。</p><p>我们去警察局获取了100个人的档案，其中有50个好人、50个坏人。档案里还有另一个数据：是否染发。</p><p>根据上面的档案数据，我们绘制表格如下：</p><img src="/blog/2020/01/17/decision-tree-entropy/table.png" class="" title="好人坏人以及染发"><p>我们似乎可以用染发与否判断一个人是好人还是坏人。</p><p>如果使用上面的判断方式，我们的 entropy 会减少多少呢？</p><p>E(染发) =  10/45 * log_2(10/45) + 35/45 * log_2(35/45) = 0.76<br>E(不染发) =  40/55 * log_2(40/55) + 15/55 * log_2(15/55) = 0.85</p><p>然后按照频率加权平均，得到以染发预测好人的 entropy：<br>E(是否好人｜是否染发) = 45/100 * 0.76  + 55/100 * 0.85 = 0.81</p><p>现在我们看到一个染发者，就判断他是坏人，然后躲得远远的。我们会有一定的错判率（大概29%），但这已经比之前无法判断的情况有了进步，这个世界没有那么混乱了。怎么衡量混乱程度的减少呢？我们用原先的 entropy 减去基于某个因素做判断的 entropy，得到这个因素的 <strong>information gain</strong>：</p><p>IG= = E(是否好人) - E(是否好人|是否染发) = 1 - 0.81 = 0.19</p><p>引入染发这个 split，我们获得了 0.19 的进步。</p><p>如果我们有更多变量，我们就可以依次计算每个变量的 IG，并选择 IG 效果最好的变量作为解释变量。当我们依次选择出了若干个解释变量，所谓的决策树<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f332.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f332.png?v8">🌲</span>就出现了。</p><h2 id="一个引申"><a href="#一个引申" class="headerlink" title="一个引申"></a>一个引申</h2><p>如果公司对 A 方案有5成把握，在 entropy 函数里，混乱程度是最严重的。另外一个方案 B，公司只有2成把握，这时的 entropy 值比较低。</p><p>这是一个有意思的发现：我们希望 entropy 越低越好。站在公司角度，B 方案是个可以快速拒绝的方案：我们清楚地知道它大概率失败（假设两个方案的预期回报相等）。真正造成混乱后果，往往是 A 方案这样模棱两可的方案。</p><p>再看一个（半搞笑的）场景，假设有两个同事：</p><ul><li>A 员工的判断准确度是50%</li><li>B 员工的判断准确度是20%</li></ul><p>我会更希望自己的手下是哪个呢？按照 entropy 公式，B 员工的 entropy 值更低。此时我们选择 B 员工：我们只要做出跟 B 员工的判断相反的选择，就大概率正确了。而 A 员工呢，价值还不如一枚硬币，毕竟通过抛硬币做选择也能达到50%的准确度。</p><p>现实生活里有没有类似 B 员工的人呢？可能没有这样的人，但在某一类问题上，有人开能会习惯性犯错。</p><p>我曾经有个同事喜欢追求完美，总是没有办法按期完成任务，ta 经常会说“我觉得这个版本还不够好/我还没准备好，要不再等一等”。如果选择延期，结果往往更糟糕。在按期交付问题上，ta 的判断力就像只有20%的准确度 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span>。当我意识到这点后，每次 ta 提出“可以延期“时，我总会立刻做出判断：不能延期了，必须交付。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/17/decision-tree-entropy/decision-tree.png&quot; class=&quot;&quot; title=&quot;决策树&quot;&gt;
&lt;p&gt;决策树模型是机器学习的重要模型。决策树里有个概念，叫 entropy，模型的最优化函数基于 entropy 做出。&lt;/p&gt;
&lt;p&gt;用一个诗意的说法，entropy 描述了世界的混乱程度。Split 能帮助降低混乱程度。&lt;/p&gt;
&lt;p&gt;这篇文章用具体例子说明，split 如何降低 entropy。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计理论" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>线性回归的假设</title>
    <link href="http://yoursite.com/2020/01/16/lm-assumptions/"/>
    <id>http://yoursite.com/2020/01/16/lm-assumptions/</id>
    <published>2020-01-16T12:56:06.000Z</published>
    <updated>2020-01-20T05:56:50.991Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/16/lm-assumptions/assumption.png" class="" title="假设"><p>数据可以骗人，这个道理大家都知道。我印象最深的经历是：同事给了一个基于 linear regression 的研究报告，但报告完全没有对线性回归的假设做<strong>任何诊断</strong>。不做假设检验的分析报告在大学作业里会被判断为不及格。</p><p>但这份报告在业务部门中传阅，成为了产品的决策依据。这是一个上市公司，报告分析的产品也是公司的现金牛产品。</p><p>糟糕的数据分析，最好的结果是浪费了大家的时间，最坏的结果是指导决策者做出错误的决策。</p><p>这篇文章小结一下 linear regression 的几个核心假设，就当是大学知识的一次复习。</p><p><a id="more"></a></p><h2 id="LM的假设"><a href="#LM的假设" class="headerlink" title="LM的假设"></a>LM的假设</h2><ol><li>线性关系</li><li>自变量之间不具有多重共线性</li><li>扰动项符合正态分布</li><li>同方差</li><li>没有自相关：这种情况在非时间序列里很少见，所以我们不讨论了</li></ol><h2 id="1-线性关系"><a href="#1-线性关系" class="headerlink" title="1. 线性关系"></a>1. 线性关系</h2><p>第一个假设最直接：自变量和因变量之间是线性关系。</p><p>反例：<code>y = a + b * x ^ 3</code>，这里的 y 和 x 就不是线性关系。</p><p>做一元回归时，散点图可以揭示自变量与因变量之间的关系。</p><p>如果是多元回归，可以使用 R 的 <code>lm</code> 对象自带的 <code>plot</code> 函数。函数返回的第1个图片：<strong>Residuals vs Fitted</strong> 能够用来检查线性假设。</p><p>我们模拟数据并示例如下：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">size &lt;- <span class="number">30</span></span><br><span class="line">x &lt;- rnorm(size, <span class="number">15</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">y1 &lt;- <span class="number">3</span> + <span class="number">5</span> * x + rnorm(size, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">y2 &lt;- <span class="number">3</span> + <span class="number">5</span> * x^<span class="number">3</span> + rnorm(size, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">fit_1 &lt;- lm(y1 ~ x)</span><br><span class="line">fit_2 &lt;- lm(y2 ~ x)</span><br><span class="line"></span><br><span class="line">p1 &lt;- autoplot(fit_1)</span><br><span class="line">p2 &lt;- autoplot(fit_2)</span><br><span class="line"></span><br><span class="line">p1_1 &lt;- p1[[<span class="number">1</span>]] + ggtitle(<span class="string">'满足线性假设'</span>) + theme(plot.title = element_text(size = <span class="number">18</span>))</span><br><span class="line">p2_1 &lt;- p2[[<span class="number">1</span>]] + ggtitle(<span class="string">'不满足线假设'</span>) + theme(plot.title = element_text(size = <span class="number">18</span>))</span><br><span class="line"></span><br><span class="line">ggarrange(p1_1, p2_1 + rremove(<span class="string">'y.title'</span>), ncol = <span class="number">2</span>, nrow = <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><p>我使用了 ggfortify 包处理 lm 的图片，并用 ggpubr 包把两个模型的图片并列在一起。</p><p>图片如下：</p><img src="/blog/2020/01/16/lm-assumptions/plot_1.png" class="" title="线性假设"><p>当模型满足线性假设时，fitted value 和 residuals 的关系接近一条直线（如左图），右图则明显不是直线。</p><h2 id="2-多重共线性"><a href="#2-多重共线性" class="headerlink" title="2. 多重共线性"></a>2. 多重共线性</h2><p>要求：自变量之间没有<strong>过于强</strong>的线性关系。</p><p>有一些线性关系是没问题的。在研究现实问题时，我们很难找到完全没线性关系的自变量。</p><p>比如研究收入的影响因素，我们会考虑智商和学历。智商越高，自然收入越高；学历越高，当然收入也越高。可是，学历也同时跟智商有线性关系。这会是个问题吗?</p><p>只要这两个变量不是完全的线性关系，我们就不用担心。这两个因素当然不是完全线性关系，除了智商之外，家庭条件、考生的所处省份、个人兴趣等因素也跟学历有巨大关系。</p><p>我们可以查看所有自变量之间的相关性。ggplot 生态里有个非常好用的 <code>ggcorrplot</code> 包：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggcorrplot)</span><br><span class="line">data(mtcars)</span><br><span class="line">corr &lt;- round(cor(mtcars), <span class="number">1</span>)</span><br><span class="line">ggcorrplot(corr, hc.order = <span class="literal">TRUE</span>, type = <span class="string">"lower"</span>,</span><br><span class="line">           outline.col = <span class="string">"white"</span>,</span><br><span class="line">           ggtheme = ggplot2::theme_gray,</span><br><span class="line">           colors = c(<span class="string">"#6D9EC1"</span>, <span class="string">"white"</span>, <span class="string">"#E46726"</span>)) </span><br></pre></td></tr></tbody></table></figure><p>结果如下图：</p><img src="/blog/2020/01/16/lm-assumptions/plot_2.png" class="" title="多重共线性"><p>如果想更严格地描述多重共线性问题，可以参考一个叫 <a href="https://en.wikipedia.org/wiki/Variance_inflation_factor" target="_blank" rel="noopener">variance inflation factor</a> 的指标。</p><h2 id="3-扰动项符合正态分布"><a href="#3-扰动项符合正态分布" class="headerlink" title="3. 扰动项符合正态分布"></a>3. 扰动项符合正态分布</h2><p>扰动项 error term 是一个理论概念：没有被观察到的影响因素，都算在扰动项里。扰动项无法直接衡量，所以我们用残差 residuals 来代替。残差是真实值和拟合值之间的差。</p><p>一般使用 Normal QQ 图来检查扰动项是否符合正态分布。</p><p>我们先 simulate 两组数据，然后对比它们的 QQ 图：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">size &lt;- <span class="number">100</span></span><br><span class="line">x &lt;- rnorm(size, <span class="number">15</span>, <span class="number">10</span>)</span><br><span class="line">err &lt;- rnorm(size, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">  </span><br><span class="line">y1 &lt;- <span class="number">3</span> + <span class="number">5</span> * x + err</span><br><span class="line">y2 &lt;- <span class="number">3</span> + <span class="number">5</span> * x + err ^ <span class="number">3</span></span><br><span class="line"></span><br><span class="line">fit_1 &lt;- lm(y1 ~ x)</span><br><span class="line">fit_2 &lt;- lm(y2 ~ x)</span><br><span class="line"></span><br><span class="line">p1 &lt;- autoplot(fit_1)</span><br><span class="line">p2 &lt;- autoplot(fit_2)</span><br><span class="line"></span><br><span class="line">p1_2 &lt;- p1[[<span class="number">2</span>]] + ggtitle(<span class="string">'扰动项正态分布'</span>) + theme(plot.title = element_text(size = <span class="number">18</span>))</span><br><span class="line">p2_2 &lt;- p2[[<span class="number">2</span>]] + ggtitle(<span class="string">'非正态分布'</span>) + theme(plot.title = element_text(size = <span class="number">18</span>))</span><br><span class="line"></span><br><span class="line">ggarrange(p1_2, p2_2 + rremove(<span class="string">'y.title'</span>),</span><br><span class="line">           ncol = <span class="number">2</span>, nrow = <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><p>我们让第1个模型的扰动项完美符合正态分布，让第2个模型第扰动项严重偏离正态分布。<br>得到的 QQ 图如下：</p><img src="/blog/2020/01/16/lm-assumptions/plot_3.png" class="" title="扰动项符合正态分布"><p>在完美假设的情况下，所有的点几乎跟图中直线重合。右图中的点则严重偏离了图中直线。</p><h2 id="4-同方差"><a href="#4-同方差" class="headerlink" title="4. 同方差"></a>4. 同方差</h2><p>同方差假设的内容是：对不同的自变量值，扰动项的方差是相同的。如果违反了这个假设，就叫“异方差”。</p><p>典型的的异方差场景：研究收入和学历的关系，我们可以大概预料到，学历越高的人，收入的反差越大（有的人混得非常好，有的人混得一般）。</p><p>这是线性回归里非常重要的假设，我们可以用 <code>ncvTest()</code> 检测异方差。也可以在做出模型后做可视化检查，即使用 scale-location 图。</p><p>跟之前的思路一样，我在下面的代码里模拟一个正常模型和一个异方差模型。</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">123</span>)</span><br><span class="line">size &lt;- <span class="number">100</span></span><br><span class="line">x &lt;- rnorm(size, <span class="number">15</span>, <span class="number">10</span>)</span><br><span class="line">err_1 &lt;- rnorm(size, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">err_2 &lt;- (x -<span class="number">1</span>)* rnorm(size, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">y1 &lt;- <span class="number">3</span> + <span class="number">5</span> * x + err_1</span><br><span class="line">y2 &lt;- <span class="number">3</span> + <span class="number">5</span> * x + err_2</span><br><span class="line"></span><br><span class="line">fit_1 &lt;- lm(y1 ~ x)</span><br><span class="line">fit_2 &lt;- lm(y2 ~ x)</span><br></pre></td></tr></tbody></table></figure><p>这里我们查看 scale-location 图，下图中同方差的情况是一条比较直的线，异方差则比较斜。</p><img src="/blog/2020/01/16/lm-assumptions/plot_4.png" class="" title="scale-location"><p>另一个更符合直接的参考图，是 x 和对应残差的散点图。<br>参考下图：下图的异方差现象很明显，残差随着x的变大而变大。</p><img src="/blog/2020/01/16/lm-assumptions/plot_5.png" class="" title="x和残差的散点图"><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>线性回归模型的前提是模型满足假设，这是科学研究的规范，在公司里生成研究报告时，也应该做相应的检查。</p><p>在 R 语言里查看这几个假设很简单，只需要在 <code>fit = lm(y ~ x)</code>使用<code>plot(fit)</code>函数。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/16/lm-assumptions/assumption.png&quot; class=&quot;&quot; title=&quot;假设&quot;&gt;
&lt;p&gt;数据可以骗人，这个道理大家都知道。我印象最深的经历是：同事给了一个基于 linear regression 的研究报告，但报告完全没有对线性回归的假设做&lt;strong&gt;任何诊断&lt;/strong&gt;。不做假设检验的分析报告在大学作业里会被判断为不及格。&lt;/p&gt;
&lt;p&gt;但这份报告在业务部门中传阅，成为了产品的决策依据。这是一个上市公司，报告分析的产品也是公司的现金牛产品。&lt;/p&gt;
&lt;p&gt;糟糕的数据分析，最好的结果是浪费了大家的时间，最坏的结果是指导决策者做出错误的决策。&lt;/p&gt;
&lt;p&gt;这篇文章小结一下 linear regression 的几个核心假设，就当是大学知识的一次复习。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计理论" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>AB测试的例子：访问时长</title>
    <link href="http://yoursite.com/2020/01/16/ab-test-length/"/>
    <id>http://yoursite.com/2020/01/16/ab-test-length/</id>
    <published>2020-01-16T03:46:52.000Z</published>
    <updated>2020-01-20T05:56:50.991Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇关于AB测试的文章里，我们模拟了一个常见的 ab 测试场景：转化率。这个场景适用于计算百分比数据的场景。</p><p>还有一种场景，数据不是百分比，而是连续数值。例如：</p><ul><li>访问时长</li><li>人均消费</li><li>人均阅读数量</li><li>…</li></ul><p>这个问题场景下，不适合使用 r 的 <code>prop.test</code> 函数。我们可以使用 z-test。</p><p><a id="more"></a></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>我们是一个内容 app，产品部门开发了一个新版本，我们想要测试新版本下的用户访问时长是否会提高。</p><p>我们的原假设和备择假设是：</p><ul><li>H0：新方案的访问时长 &lt;= 老方案的访问时长</li><li>Ha：新方案的访问时长 &gt; 老方案的访问时长</li></ul><p>我们选择单侧检验有2个原因：</p><ul><li>从产品迭代流程考虑，如果没有证据正面新方案比老方案好，我们就不会全面部署新方案，所以我们寻找证据“证伪”老方案</li><li>从统计功效考虑，使用单侧检验能在相同样本下保证更高的统计功效，也就是节约成本了</li></ul><p>因为比较的是两个总体的分布是否有差距，我们使用 two sample t-test。</p><h2 id="参数设定和样本数量估计"><a href="#参数设定和样本数量估计" class="headerlink" title="参数设定和样本数量估计"></a>参数设定和样本数量估计</h2><p>跟之前一样，我们设定 80% 的 power 和 0.05 的 significance level。</p><p>t-test 的样本量估算需要先给定一个 cohen’d。</p><p>d = (m1 - m2 ) /  delta，其中：</p><ul><li>m1 和 m2 分别是两组的均值</li><li>delta 是 common standard deviation</li></ul><p>在开始测试之前，我们只知道 m2 的时长，假设 m2 = 60。理论上我们不可能知道 delta，但我们可以用老方案的样本去估算。一个“便利公式”是 delta = （最大值 - 最小值）/4。假定 delta = 25。</p><p>现在，我们要判断：我们预期新方案的均值有多大的提升呢？假设我们期望新方案会比老方案提高5，也就是从60提高到65。这时我们可以计算 cohen’d = （65 - 60） / 25 = 0.2</p><p>这时我们可以用 R 的 pwr package 估算需要的样本量：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwr.t.test(d = <span class="number">0.2</span>, sig.level = <span class="number">0.05</span>, power = <span class="number">0.8</span>, type = <span class="string">'two.sample'</span>, alternative=<span class="string">'greater'</span>)</span><br></pre></td></tr></tbody></table></figure><p>这个计算告诉我们，每个组需要310个样本。我们着手安排测试。</p><h2 id="检查数据"><a href="#检查数据" class="headerlink" title="检查数据"></a>检查数据</h2><p>一天之后，我们搜集够了650个样本，每组325个样本，我们开始检查数据。</p><p>我们发现两个组的数据如下：</p><ul><li>新方案：平均时长64秒，标准差43秒</li><li>原方案：平均时长60秒，标准差40秒</li></ul><p>看上去新方案更好，但我们能得出新方案更好的结论吗？</p><p>我们可以用 <code>t.test</code> 做检验：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- rnorm(<span class="number">315</span>, <span class="number">64</span>, <span class="number">43</span>)</span><br><span class="line">y &lt;- rnorm(<span class="number">315</span>, <span class="number">60</span> ,<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">t.test(x, y , alternative = <span class="string">'greater'</span>)</span><br></pre></td></tr></tbody></table></figure><p>我在这里模拟了数据，实际上我们可以直接带入两个 list 进 t.test，或者用现成的能输入均值和标准差的函数。</p><p>结果：p值 = 0.21，我们无法拒绝原假设。</p><p>结论：新方案未必比老方案好，我们需要做进一步测试（增加样本量），或保留老方案。</p><p>另一个平行宇宙里，新方案的平均时长还是64秒，标准差是40秒，我们的结论又会变成怎样呢？</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- rnorm(<span class="number">315</span>, <span class="number">64</span>, <span class="number">40</span>)</span><br><span class="line">y &lt;- rnorm(<span class="number">315</span>, <span class="number">60</span> ,<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">t.test(x, y , alternative = <span class="string">'greater'</span>)</span><br></pre></td></tr></tbody></table></figure><p>p值 = 0.04956，小于 0.05。<br>结论：我们拒绝原假设，认为新方案更好。</p><h2 id="AB-测试不只关注均值，还关注分布"><a href="#AB-测试不只关注均值，还关注分布" class="headerlink" title="AB 测试不只关注均值，还关注分布"></a>AB 测试不只关注均值，还关注分布</h2><p>我经常看到不了解统计学的同事用两个均值作为方案优劣的比较依据。上面的例子可以说明：均值差异是不够的。很多时候，我们观察到的均值差异只是随机现象的结果。</p><p>科学的方法还会考虑分布，怎么考虑分布呢？选择一个合适的 test 计算统计显著性。</p><p>不是每个人都懂统计学，但有的人会懂得尊重科学。</p><p>当我们从公司层面追求科学的数据方法论，公司从上到下的决策水平都会提高。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇关于AB测试的文章里，我们模拟了一个常见的 ab 测试场景：转化率。这个场景适用于计算百分比数据的场景。&lt;/p&gt;
&lt;p&gt;还有一种场景，数据不是百分比，而是连续数值。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问时长&lt;/li&gt;
&lt;li&gt;人均消费&lt;/li&gt;
&lt;li&gt;人均阅读数量&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个问题场景下，不适合使用 r 的 &lt;code&gt;prop.test&lt;/code&gt; 函数。我们可以使用 z-test。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="增长黑客" scheme="http://yoursite.com/categories/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>AB测试的例子：转化率</title>
    <link href="http://yoursite.com/2020/01/15/ab-test-ctr/"/>
    <id>http://yoursite.com/2020/01/15/ab-test-ctr/</id>
    <published>2020-01-15T14:26:03.000Z</published>
    <updated>2020-01-20T05:56:50.991Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/15/ab-test-ctr/abtest.jpeg" class="" title="题图"><p>AB 测试是互联网产品优化的科学方法，甚至可能是唯一科学的方法。在这篇文章里，我用 R 语言模拟 AB 测试的流程。</p><p><a id="more"></a></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>假设我们有一个购物 APP，我们重新设计了商品页面，现在我们要回答的问题是：新设计方案对用户的购买率有提高吗？令原方案为 A，新方案为 B。</p><p>我们的原假设和备择假设是：</p><ul><li>原假设：新方案的转化率 &lt;= 老方案的转化率</li><li>备择假设：新方案的转化率 &gt; 老方案的转化率</li></ul><p>因为我们只关心 B 方案是否会比 A 方案好，所以我们使用 one-sided test。原假设是我们想要通过数据去“证伪”的假设，所以原假设是“新方案是没有用处的”，即新方案的转化率低于或等于老方案。</p><p>因为需要判断的是转化率，我们可以使用 <a href="https://www.statisticshowto.datasciencecentral.com/z-test/" target="_blank" rel="noopener">Z-test</a>。</p><h2 id="参数设定和样本数量估计"><a href="#参数设定和样本数量估计" class="headerlink" title="参数设定和样本数量估计"></a>参数设定和样本数量估计</h2><p>在开始搜集数据前，我们需要设定几个参数。</p><ul><li>显著性水平 significance level：我们愿意接受的犯第1类错误的概率是多少？</li><li>统计功效 power：我们希望的统计功效是多少？</li><li>给定当前的转化率（10%），我们希望 B 方案的转化率提高到多少？</li></ul><p>我们依次设定参数如下：</p><ul><li>显著性水平 5%</li><li>统计功效 80%</li><li>转化率提高到 12%</li></ul><p>我们假设样本会平均分配到两个方案中。</p><p>我们使用 <code>pwr</code> packag 来计算需要的样本量</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwr.2p.test(h=ES.h(p1 = <span class="number">0.10</span>, p2 = <span class="number">0.12</span>), </span><br><span class="line">            sig.level = <span class="number">0.05</span>, </span><br><span class="line">            power=<span class="number">0.8</span>, </span><br><span class="line">            alternative = <span class="string">'less'</span>)</span><br></pre></td></tr></tbody></table></figure><p>这个计算告诉我们，每组大概需要 3021 个样本，一共需要大约6100个样本。</p><p>根据 app 流量，我们预计1天的时间可以搜集完所有的数据。于是我们使用现成的工具（或者让工程师开发），并开始测试。</p><h2 id="检查数据"><a href="#检查数据" class="headerlink" title="检查数据"></a>检查数据</h2><p>一天之后，我们搜集够了6100个样本，我们开始检查数据。</p><p>我们发现两个组的数据如下：</p><ul><li>原始方案：3500个样本中，有360个用户发生了转化</li><li>新方案：3500个样本中，有400个用户发生了转化</li></ul><p>看上去是新方案“获胜”了，可是，这个差异在统计学上显著吗？</p><p>我们做一个使用 r 的 <code>prop.test</code> 函数：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prop.test(x = c(<span class="number">360</span>, <span class="number">400</span>), n = c(<span class="number">3500</span>, <span class="number">3500</span>), alternative = <span class="string">'less'</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果：p 值 = 0.067，比预先设定的显著性水平高，我们不能拒绝原假设。</p><p>结论：我们没有理由认为新方案更好。</p><p>想象再另一个平行宇宙，新方案有410个用户发生了转化，我们的 p 值会是多少呢？</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prop.test(x = c(<span class="number">360</span>, <span class="number">410</span>), n = c(<span class="number">3500</span>, <span class="number">3500</span>), alternative = <span class="string">'less'</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果：p 值 = 0.031，我们可以拒绝原假设了。</p><p>结论：新方案的转化率更高。</p><h2 id="为什么是-80-和-5-？"><a href="#为什么是-80-和-5-？" class="headerlink" title="为什么是 80% 和 5%？"></a>为什么是 80% 和 5%？</h2><p>在上面的例子中，我们选择了 80% 的 power 和 5% 的 significane level。为什么呢？Stackoverflow 的数据科学家给了<a href="https://stackoverflow.blog/2017/10/17/power-calculations-p-values-ab-testing-stack-overflow/" target="_blank" rel="noopener">一个非常好的解释</a>。</p><p>如果选择95%的 power 和1%的 significance level，我们的结论准确度会有极大提高，但测试会消耗更多的时间，导致影响商业决策的效率。</p><p>如果我们在刚才的例子追求这样的准确度，我们需要的样本量会翻倍，也就是说，时间成本翻倍。</p><p>如果只看单个测试，翻倍似乎是可以接受的，但一个成熟的互联网产品可能在同时进行几十个优化测试，如果每个测试都追求极端准确性，产品的迭代速度会减少50%。对于“天下武功，唯快不破”的互联网产品，这样的效率损失是绝对不可接受的。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul><li><a href="https://www.invespcro.com/blog/one-tailed-vs-two-tailed-a-b-testing-everything-you-possibly-need-to-know/" target="_blank" rel="noopener">为什么使用单侧检验</a></li><li><a href="https://cran.r-project.org/web/packages/pwr/vignettes/pwr-vignette.html" target="_blank" rel="noopener">pwr package</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/15/ab-test-ctr/abtest.jpeg&quot; class=&quot;&quot; title=&quot;题图&quot;&gt;
&lt;p&gt;AB 测试是互联网产品优化的科学方法，甚至可能是唯一科学的方法。在这篇文章里，我用 R 语言模拟 AB 测试的流程。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="增长黑客" scheme="http://yoursite.com/categories/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>1类错误和2类错误</title>
    <link href="http://yoursite.com/2020/01/15/type-one-error/"/>
    <id>http://yoursite.com/2020/01/15/type-one-error/</id>
    <published>2020-01-15T11:45:10.000Z</published>
    <updated>2020-01-20T05:56:50.995Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/15/type-one-error/plot_0.jpg" class="" title="题图"><p>统计学里有两个基石一样的概念：一类错误和二类错误。这两个概念是统计检验的基础。</p><p><a id="more"></a></p><h2 id="原假设"><a href="#原假设" class="headerlink" title="原假设"></a>原假设</h2><p>在定义这两类错误前，我们需要先复习假设检验。</p><p>在检验检验里，我们定义了<strong>原假设</strong> null hypothesis。原假设是我们希望通过数据去“证伪”的假设，习惯被表述为 H0。</p><p>一个典型的 H0 是：本市的人均收入大于或等于8000元。</p><p>原假设的对立面，是备择假设 alternative hypothesis，习惯被表述为 Ha。</p><p>上面的 H0 对应的 Ha 是：本市的人均收入小于8000元。</p><p>我们对本市市民做了一次问卷调查，搜集了10000份问卷，根据数据调查结果，我们会有两种结论：</p><ul><li>拒绝 H0，即接受 Ha</li><li>无法拒绝 H0</li></ul><p>在上面的表述里，我们没有说“接受 H0”。这是外行最常用错的表达。</p><h2 id="为啥不能说“接受”原假设"><a href="#为啥不能说“接受”原假设" class="headerlink" title="为啥不能说“接受”原假设"></a>为啥不能说“接受”原假设</h2><p>在解答这个问题之前，我们需要先了解假设检验的方法论。</p><p>对每一个研究课题，我们的工作流程是：</p><ol><li>确定 H0 和 Ha</li><li>根据过往的研究和理论，确定要使用的假设检验方法</li><li>选好一个<strong>显著性水平</strong> significance level，比如 alhpa = 0.05</li><li>搜集数据，并计算 p 值</li><li>如果 p 值 &lt; alpha，我们说<strong>拒绝原假设</strong>，否则，我们说<strong>无法拒绝原假设</strong></li></ol><p>是否拒绝原假设，受到我们选择的 significance level 影响。如果 p 值等于 0.06，而我们的 significance level 选了0.05，因为<code>0.06 &gt; 0.1</code>，这个时候我们会“无法拒绝原假设”。而如果 significance level 选了0.1，因为<code>0.06 &lt; 0.1</code>，我们就能够拒绝原假设。</p><p>当我们做假设检验时，我们其实是在研究这个问题：<strong>给定原假设为真，我们有多大的可能观察到自己所搜集的数据，如果这个可能性很小，我们就拒绝原假设</strong>。当我们 p 值 &gt; alpha 时，本质上等价于：<strong>我们所搜集到的数据并没有极端到能说明原假设是错的</strong>。这里的极端程度标准，就是我们选好的 significance level。</p><p>以这个 H0 为例：本市的人均收入大于或等于8000元。 </p><p>我们发现调查1万人的平均收入是7990元，这个数字比8000小，看上去人均收入似乎低于8000了，但要注意，抽样调查存在随机性，这10元的差距很有可能是随机现象导致。换句话说，我们观察到的数据不足以证明原假设是错的。</p><p>但我们是否能接受“人均收入大于或等于8000”的说法呢？显然不能，7990 的调查结果当然支撑不了这个说法。</p><p>如果我们想要证明人均收入大于8000，我们的原假设就应该是：人均收入小于或等于8000（原假设里一定要有等号）。</p><h2 id="第1类错误和第2类错误"><a href="#第1类错误和第2类错误" class="headerlink" title="第1类错误和第2类错误"></a>第1类错误和第2类错误</h2><p>理论部分搞清楚后，我们开始介绍第1类错误和第2类错误。</p><p>第1类错误：原假设为真，但我们拒绝了原假设。这类错误叫<strong>去真</strong>，英文文献里说 false positive。<br>第2类错误：原假设为假，但我们没有拒绝原假设。这类错误叫<strong>存伪</strong>，英文文献里叫 false negative。</p><p>如下图：<br><img src="/blog/2020/01/15/type-one-error/error.png" class="" title="假设检验的错误"></p><p>犯第1类错误的概率，就是之前出现的 significance level。如果我们确定了 alpha = 0.05，那么在100次假设检验中，就会有5次出现第1类错误。</p><p>犯第2类错误的概率，被称为 beta，另一个常用统计学概念 power（统计功效）就等于 1 - beta。犯第2类错误的概率越低，建设检验的 power 就越高。</p><p>在这两类错误中，我们更关心哪一类呢？有的书籍会告诉我们第1类错误更重要，它们会用法庭审判的例子，说审判一个无罪的人有罪（第1类错误）是更大的风险，这其实只是个比喻，不是个好例子。下面我们看两个例子。</p><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><p>我们用统计学使用的最严格的场景做例子：药物效果的判断。新药上市前，要经过一系列严格的医学试验。</p><p>H0：药物 A 对治疗某疾病没有帮助<br>Ha：药物 A 对治疗某疾病有帮助</p><p>相关错误和结果如下：</p><p>第1类错误：药物 A 是没用的，但我们拒绝了原假设，给出了药物 A 是有用的的判断。药物上市，患者购买后没有帮助，患者因为使用 A 药物可能没有使用其他有效的药物，最后可能有负面结果（甚至死亡），进一步研究发现药物 A 是无效的，公司面料患者诉讼，甚至可能破产。</p><p>第2类错误：药物 A 是有用的，但我们没有拒绝原假设。结果：药物无法上市，公司损失了潜在的收入，病人失去了一种潜在的治疗方案。</p><p>两种结果，作为公司管理者的你，你会更希望减少哪一种错误的概率呢？显然是第1种。</p><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>我们做疾病筛查时，H0 和 Ha 分别是：</p><p>H0：病人没有疾病<br>Ha：病人有疾病</p><p>相关错误如下：</p><p>第1类错误：病人是没病的，被诊断为有病。病人痛哭流涕，但在之后的进一步检查中，病人发现自己并没有生病，虚惊一场，进而联想到生命的可贵，于是变成一个好父亲好丈夫。</p><p>第2类错误：病人是有病的，但原假设没有被拒绝，病人不知道自己生病了，于是逍遥快活，错过了治疗时机，然后症状变严重时，才进一步检查，发现得了病。</p><p>在这个例子里，你会更希望减少哪一类错误的概率呢？显然是第2种。在 HIV 检测中，false negative 确实比 false positve 更少见。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>在实际研究中，我们可以降低两类错误的概率：</p><ol><li>第1类错误：通过选择更低的 significant level</li><li>第2类错误：通过扩大样本量或选择单侧检验</li></ol><p>样本量足够大的时候，我们总是能把两类错误的概率降到足够低。但在实际应用中，更大的样本意味着成本：时间成本和金钱成本。</p><p>以 A/B 测试为例，只要样本量足够大，一定发现更好的方案。但产品有自己的迭代计划，每个产品有一系列的 A/B 测试需要做，不可能等每一个测试出现结果。这个时候就必须为了效率牺牲准确性。</p><p>有的领域，准确性非常非常重要，比如治疗癌症的药物研究，那是人命关天的事情，而且每天都在烧钱，真的是字面意义上的烧钱。</p><p>相比之下，互联网产品的容错率还是很高的。业界能够接受的标准一般是：</p><ul><li>5%的犯一类错误的概率</li><li>20%的犯二类错误的概率</li></ul><p>一般的产品按照这个标准去做研究，不会有大问题。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/15/type-one-error/plot_0.jpg&quot; class=&quot;&quot; title=&quot;题图&quot;&gt;
&lt;p&gt;统计学里有两个基石一样的概念：一类错误和二类错误。这两个概念是统计检验的基础。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计理论" scheme="http://yoursite.com/categories/%E7%BB%9F%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>R 语言里常用的分布函数</title>
    <link href="http://yoursite.com/2020/01/13/r-dist-func/"/>
    <id>http://yoursite.com/2020/01/13/r-dist-func/</id>
    <published>2020-01-13T16:59:44.000Z</published>
    <updated>2020-01-20T05:56:50.995Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文小结 R 语言里涉及概率分布的几个函数。</p><p>每个概率分布函数在 R 里都有4个对应的函数，分别以1个字母开头：</p><ul><li>d：表示 density，指概率密度函数 probability density function (pdf)</li><li>p：表示 probability，指累计分布函数 cumulative density function (cdf)</li><li>q: 表示 quantile，是 cdf 的逆函数</li><li>r：表示 random，符合该概率分布的随机数</li></ul><p>如果你像我一样已经不记得概率论的老师长啥样，上个的一些名词应该会让你一头雾水。没关系，我们接下来就用 R 代码一一测试。</p><p><a id="more"></a></p><h2 id="二项分布-Binomial-Distribution"><a href="#二项分布-Binomial-Distribution" class="headerlink" title="二项分布 Binomial Distribution"></a>二项分布 Binomial Distribution</h2><p>我们先以二项分布作为例子。二项分布是一个离散随机变量。</p><p>二项分布描述的问题是：每次试验有两个结果，成功或失败，n 次试验后成功 k 次的概率有多少？</p><p>R 语言里是 binom。</p><h3 id="dbinom"><a href="#dbinom" class="headerlink" title="dbinom"></a>dbinom</h3><p><code>dbinom(x, size, prob)</code> 就是计算概率的公式，其中：</p><ul><li>x：成功次数</li><li>size：总试验次数</li><li>prob：单次试验的成功概率</li></ul><p>比如，扔5次硬币，正面2次的概率可以计算为：</p><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbinom(<span class="number">2</span>, size=<span class="number">5</span>, prob=<span class="number">0.5</span>) </span><br></pre></td></tr></tbody></table></figure><p>结果：0.3125</p><h3 id="pbinom"><a href="#pbinom" class="headerlink" title="pbinom"></a>pbinom</h3><p><code>pbinom(q, size, prob)</code> 是计算累计概率的函数，其中 q 是 quantile。</p><p>例子：扔5次硬币，最多有1次正面的概率是对少？(即0次或1次)</p><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pbinom(<span class="number">1</span>, size=<span class="number">5</span>, prob=<span class="number">0.5</span>) </span><br></pre></td></tr></tbody></table></figure><p>答案：0.1875。</p><p>我们可以用 <code>dbinom(0, 5, 0.5) + dbinom(1, 5, 0.5)</code> 来做验证</p><h3 id="qbinom"><a href="#qbinom" class="headerlink" title="qbinom"></a>qbinom</h3><p><code>qbinom</code> 是 <code>pbinom</code> 的逆函数。我可以计算累计概率为 p 的对应 quntile 是多少。</p><p>使用刚才的0.1875去计算：</p><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qbinom(<span class="number">0.1875</span>, size=<span class="number">5</span>, prob=<span class="number">0.5</span>) </span><br></pre></td></tr></tbody></table></figure><p>我们应该得到 1。</p><h3 id="rbinom"><a href="#rbinom" class="headerlink" title="rbinom"></a>rbinom</h3><p><code>rbinom(n, size, prob)</code> 给出 n 个符合二项分布的随机数。</p><p>我们刚才计算了扔5次硬币时，成功2次的概率是 0.3125。</p><p>现在我们分别生成100、1000和10000个随机数，看看 x = 2 的频率是不是接近这个数字。</p><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">123</span>)</span><br><span class="line">sum(rbinom(<span class="number">100</span>, <span class="number">5</span>, <span class="number">0.5</span>) == <span class="number">2</span>) / <span class="number">100</span>  <span class="comment"># 0.28</span></span><br><span class="line">sum(rbinom(<span class="number">1000</span>, <span class="number">5</span>, <span class="number">0.5</span>) == <span class="number">2</span>) / <span class="number">1000</span>   <span class="comment"># 0.294</span></span><br><span class="line">sum(rbinom(<span class="number">10000</span>, <span class="number">5</span>, <span class="number">0.5</span>) == <span class="number">2</span>) / <span class="number">10000</span>  <span class="comment"># 0.3139</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到，随着随机次数的增加，成功2次的频率越来越接近理论值。</p><h2 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h2><p>正态分布是一个连续随机变量。</p><h3 id="dnorm"><a href="#dnorm" class="headerlink" title="dnorm"></a>dnorm</h3><p>dnorm(x) 计算 x 的对应概率密度函数值。这个函数用处不大。因为连续随机变量在某一点的概率为 0。</p><p>这个函数的唯一用处，大概是方便大家画出概率密度函数图。</p><h3 id="pnorm"><a href="#pnorm" class="headerlink" title="pnorm"></a>pnorm</h3><p><code>pnorm(5)</code> 实际上就是  P(X &lt;= 5)，计算了 X 小于等于5的概率。</p><p>所以，<code>pnorm(0)</code> 的结果是0.5，标准正态分布的一半嘛。</p><p>如果想计算期望等于1，标准差等于2的正太分布在 -3 &lt; x &lt;= 0 的概率呢？</p><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnorm(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>) - pnorm(-<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果：0.2857874</p><h3 id="qnorm"><a href="#qnorm" class="headerlink" title="qnorm"></a>qnorm</h3><p><code>qnorm</code> 是 <code>pnorm</code> 的逆函数。<br>因为 pnorm(0)等于0.5，所以 qnorm(0.5)肯定等于0，不信你试试 :) 。</p><h3 id="rnorm"><a href="#rnorm" class="headerlink" title="rnorm"></a>rnorm</h3><p><code>rnorm</code> 生成一组符合正态分布的随机数。</p><p>我们可以生成1000个数据，然后画图看看效果。</p><figure class="highlight r"><figcaption><span>R代码</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n1000 &lt;- rnorm(<span class="number">1000</span>, mean = <span class="number">70</span>, sd = <span class="number">5</span>)</span><br><span class="line">hist(n1000, breaks = <span class="number">20</span>)</span><br></pre></td></tr></tbody></table></figure><p>确实很符合正态分布。</p><img src="/blog/2020/01/13/r-dist-func/hist.png" class="" title="直方图-例子"><p><code>rnorm</code> 是个好伙伴，在 simulation study 时用得非常多。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文小结 R 语言里涉及概率分布的几个函数。&lt;/p&gt;
&lt;p&gt;每个概率分布函数在 R 里都有4个对应的函数，分别以1个字母开头：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;d：表示 density，指概率密度函数 probability density function (pdf)&lt;/li&gt;
&lt;li&gt;p：表示 probability，指累计分布函数 cumulative density function (cdf)&lt;/li&gt;
&lt;li&gt;q: 表示 quantile，是 cdf 的逆函数&lt;/li&gt;
&lt;li&gt;r：表示 random，符合该概率分布的随机数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你像我一样已经不记得概率论的老师长啥样，上个的一些名词应该会让你一头雾水。没关系，我们接下来就用 R 代码一一测试。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://yoursite.com/categories/Coding/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>增长黑客系列之3：增长的三驾马车</title>
    <link href="http://yoursite.com/2019/05/06/2019-05-07-userGrow-3/"/>
    <id>http://yoursite.com/2019/05/06/2019-05-07-userGrow-3/</id>
    <published>2019-05-06T17:15:47.000Z</published>
    <updated>2020-01-20T05:56:50.991Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2019/05/06/2019-05-07-userGrow-3/plot_0.png" class="" title="growth"><p>我在本系列的前两篇文章里讨论了“裂变模型”，在裂变模型里，目标是“总用户数”。其实真正的增长目标，应该是日活跃用户数，也叫 DAU（Daily Active User）。</p><p>驱动产品的 DAU 的要素可以分为3个：</p><ul><li>新增</li><li>留存/流失</li><li>裂变</li></ul><p>成熟的增长团队，应该从上面3个维度着手来实现增长目标。</p><p><a id="more"></a></p><h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><p>这里的新增一般指<strong>团队消耗精力或金钱获取到用户</strong>，也叫 UA （User Acquisition）。</p><p>最典型的 UA 行为是通过广告网络购买用户，这类广告因为可以衡量投入产出比，所以叫“<strong>效果广告</strong>”。比如我们在浏览朋友圈时看到的游戏广告，就是一个效果广告。</p><p>除此之外，品牌广告也是大公司常用的方法，比如抖音冠名赞助某个综艺节目。</p><p>增长黑客能够发挥作用的地方一般是在效果广告部分。</p><p>最典型的问题场景：公司每个月会花掉1000万的效果广告，如何最大化这1000万的效果呢？</p><p>这个时候我们可以这样考虑问题：</p><ul><li>是不是有投放效果比较差的渠道？如果有的话，我们应该在这些渠道减少投入。反之，有没有好的渠道可以增加投入。</li><li>广告的用户画像是否是当前最优解？有没有更便宜但效果更好的广告定位方案？</li><li>广告的素材有没有可能优化？对应的指标是广告点击率。</li><li>广告的落地页有没有可能优化？对应的指标是落地页的转化率。</li><li>…</li></ul><p>上面的每一个问题，有两种优化思路：</p><ol><li>内部对比。比如对比 A 渠道和 B 渠道，对比 A 定位和 B 定位，然后相应修改投入方案。</li><li>外部 benchmark，即对比市面上产品的数据，这需要可靠的信息源。</li></ol><h2 id="留存-流失"><a href="#留存-流失" class="headerlink" title="留存/流失"></a>留存/流失</h2><p>我们在提到留存时，经常指的是“次日留存”、“3人留存“等指标，这些指标描述了用户在第2天和第3天继续使用产品的比例。这只是一个方便衡量产品的指标，对优化产品的帮助并不十分大。</p><p>真正重要的概念，是流失 churn。</p><p>我们关心这些问题：</p><ul><li>有多少比例的用户在1分钟内流失了？</li><li>有多少比例的用户在进入产品的核心体验环节前就流失了？</li><li>更抽象地，用户在各个产品环节的流失率情况怎样？</li><li>流失的用户有哪些共同特征？</li><li>多少用户在第2天没再回来（通过这个数据也可以算出次日留存率）</li><li>……</li></ul><p>一个好产品，最直观的表现是，用户会留下来。所以，较高的留存率、或较低的流失率，是优秀产品的共同特征。</p><p>产品的团队的最核心工作，就是解决留存问题，换个表述就是，解决“产品问题”。我甚至有一个观点：产品问题其实就是留存问题。</p><p>增长黑客可以在这个环节做什么呢？</p><ul><li>研究每个用户转化环节的流失情况，识别最严重的流失环节</li><li>设计 A/B 测试，对转化环节做优化</li><li>研究流失用户或留存用户的共性，用以知道产品优化</li><li>……</li></ul><h2 id="裂变"><a href="#裂变" class="headerlink" title="裂变"></a>裂变</h2><p>裂变，或病毒传播，是增长黑客的第3个工作重心。</p><p>裂变的价值我们在前两篇文章里已经介绍过，一个病毒因子足够高的产品，会给产品带来指数级别的增长。</p><p>增长黑客要做的事情，就是优化三个裂变相关的指标：</p><ul><li>人均邀请数量：越高越好</li><li>感染率：越高越好</li><li>病毒传播的周期：越低越好</li></ul><p>裂变有至少3种实现方式：</p><ul><li>产品本身有天然的裂变属性：比如微信、Facebook、slack 这样有社交属性的产品</li><li>产品有某个裂变功能：如拼多多的“帮我砍价”，或知识付费产品的“分销”</li><li>通过运营活动实现裂变：比如瑞幸咖啡的“邀请用户，各得一杯”</li></ul><p>根据不同的裂变实现方式，增长黑客会跟产品、运营等不同职能的同事合作。</p><h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><p>增长黑客系列：</p><ol><li><a href="/blog/2019/03/05/2019-03-05-userGrow-1/" title="基础裂变模型">基础裂变模型</a> </li><li><a href="/blog/2019/05/01/2019-05-01-userGrow-2/" title="升级版裂变模型">升级版裂变模型</a> </li><li>增长的三驾马车（本文）</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2019/05/06/2019-05-07-userGrow-3/plot_0.png&quot; class=&quot;&quot; title=&quot;growth&quot;&gt;
&lt;p&gt;我在本系列的前两篇文章里讨论了“裂变模型”，在裂变模型里，目标是“总用户数”。其实真正的增长目标，应该是日活跃用户数，也叫 DAU（Daily Active User）。&lt;/p&gt;
&lt;p&gt;驱动产品的 DAU 的要素可以分为3个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新增&lt;/li&gt;
&lt;li&gt;留存/流失&lt;/li&gt;
&lt;li&gt;裂变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;成熟的增长团队，应该从上面3个维度着手来实现增长目标。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="增长黑客" scheme="http://yoursite.com/categories/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>增长黑客系列之2：升级版裂变模型</title>
    <link href="http://yoursite.com/2019/05/01/2019-05-01-userGrow-2/"/>
    <id>http://yoursite.com/2019/05/01/2019-05-01-userGrow-2/</id>
    <published>2019-05-01T09:39:14.000Z</published>
    <updated>2020-01-20T05:56:50.991Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2019/05/01/2019-05-01-userGrow-2/zombie.jpg" class="" title="僵尸"><a href="/blog/2019/03/05/2019-03-05-userGrow-1/" title="本系列的上一篇文章">本系列的上一篇文章</a> 介绍了一个纯裂变模型。我们在本篇加入一个新的变量：裂变周期的时长。直觉告诉我们，裂变周期越短，裂变强度越大。但是，这个强度究竟有多大呢？我让这个问题再精确一些，假设有2个产品，A 产品裂变周期只有1天，B 产品裂变周期是2天，30天后，A 产品的用户数会是 B 产品的几倍？<a id="more"></a><h2 id="丧尸的世界为什么那么刺激"><a href="#丧尸的世界为什么那么刺激" class="headerlink" title="丧尸的世界为什么那么刺激"></a>丧尸的世界为什么那么刺激</h2><p>在去看枯燥的公式和代码之前，我先谈谈有趣的丧尸。丧尸题材在现代社会的风靡是个有意思的现象，我把这个想象叫做“双重逃避”。</p><p>第一重逃避是现代人对充满压力的生活的逃避：通过丧尸电影和丧尸游戏，人们沉浸到了一个紧张刺激的世界，让我们忘掉日常生活的种种压力。第二重逃避：我们在丧尸游戏和电影里逃避着无处不在的丧尸。所以，为了逃避现实，我们选择在虚拟的世界里逃避丧尸。</p><p>为什么逃避丧尸是个那么刺激的事情呢？一种解答是：丧尸很致命。但这个答案不够完美，因为致命的东西很多，比如哥斯拉和异形就比丧尸致命得多。如果致命程度是某个题材火爆的原因，我们应该看到哥斯拉和异形更流行。</p><p>我觉得真正的原因是：丧尸有非常强的病毒传播能力。从第1只丧尸诞生到丧尸围城，用不了几天时间（额外提问：这现实吗？）。</p><p>我们在上一篇系列文章里提到了两个核心变量：</p><ul><li>邀请数量</li><li>感染率</li></ul><p>在丧尸的世界里， 丧尸是非常热情的“种子用户”，它见到人就会发出“邀请”，而且感染率100%。所以丧尸有非常高的<strong>病毒因子</strong>。</p><p>但这个指标还不足以描述丧尸的可怕（或魅力）。丧尸电影里最刺激的情节是，男主角的朋友/爱人被咬了之后，1分钟内就会变成丧尸，然后会立刻开始进攻其他人类。换句话说，僵尸把人变成僵尸的周期非常快。在增长模型里，这个参数叫做“<strong>周期时长</strong>”。僵尸有非常短的周期时长。</p><p>如果被僵尸咬了之后需要48个小时才会变异，僵尸电影就没那么有意思了。</p><h2 id="新的模型"><a href="#新的模型" class="headerlink" title="新的模型"></a>新的模型</h2><p>在新的模型里，我们开始考虑一个周期的时间长度，这个变量叫做简称为 ct。</p><p>所有变量如下：</p><ul><li>初始用户：custs(0)</li><li>周期时长：ct</li><li>人均邀请数 i</li><li>感染率 Conv%</li></ul><p>我们想要计算的指标是：第 t 天时，总的用户数是多少，这个变量是 custs(t)。</p><p>我们仍然维持上一篇文章的核心假设：只有新用户会发出邀请。</p><p>我从风险投资人 David Skok 的博客里找到了计算第 t 天总用户量的公式：</p><p><img src="formula.png" alt="公式"></p><p>公式里的 K = conv% * i</p><p>根据上面的公式，我们的 R 代码如下：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get_cust_t &lt;- <span class="keyword">function</span>(cust_0, i, conv, ct, t) {</span><br><span class="line">  k_coef &lt;- i * conv</span><br><span class="line">  cust_t &lt;- cust_0 * ( k_coef ^ (t/ct + <span class="number">1</span>) - <span class="number">1</span>) / ( k_coef - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span>(cust_t)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="数据例子"><a href="#数据例子" class="headerlink" title="数据例子"></a>数据例子</h2><p>当 ct = 1 时，一天就能完成一次裂变。我们想研究的问题是，当裂变时长分别等于 1、2、3、4 时，30天后的总用户数会有什么样的差距。</p><p>结果如下图：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:center">第0天</th><th style="text-align:center">第1天</th><th style="text-align:center">第10天</th><th style="text-align:center">第20天</th><th style="text-align:center">第30天</th></tr></thead><tbody><tr><td style="text-align:left">ct = 1</td><td style="text-align:center">10</td><td style="text-align:center">25</td><td style="text-align:center">1710</td><td style="text-align:center">99738</td><td style="text-align:center">5752512</td></tr><tr><td style="text-align:left">ct = 2</td><td style="text-align:center">10</td><td style="text-align:center">17</td><td style="text-align:center">208</td><td style="text-align:center">1710</td><td style="text-align:center">13117</td></tr><tr><td style="text-align:left">ct = 3</td><td style="text-align:center">10</td><td style="text-align:center">14</td><td style="text-align:center">96</td><td style="text-align:center">428</td><td style="text-align:center">1710</td></tr><tr><td style="text-align:left">ct = 4</td><td style="text-align:center">10</td><td style="text-align:center">13</td><td style="text-align:center">63</td><td style="text-align:center">208</td><td style="text-align:center">608</td></tr></tbody></table></div><p>天壤之别。</p><p>如果数字还不够直观的话，我们就看看图片。</p><p>我先画出了 ct = 2、3、4 时的图片：</p><p><img src="plot_0.png" alt="第1张折线图"></p><p>看上去 ct = 2 时的效果是远远强于 ct = 3 和 ct = 4 的。</p><p>如果对比 ct = 1 和 ct = 2 呢？</p><p><img src="plot_1.png" alt="第2张折线图"></p><p>真正意义上的天壤之别。在 ct = 1 的产品面前，排名老二的产品跟不存在一样。</p><p>我们在最开始提了一个问题：假设有2个产品，A 产品裂变周期只有1天，B 产品裂变周期是2天，30天后，A 产品的用户数会是 B 产品的几倍？答案：<strong>438倍</strong>！</p><p>这张图给了我两个想法：</p><ol><li>天下武功，唯快不破。在有病毒裂变能力的领域尤其如此。</li><li>有的时候你以为自己比后面的对手要厉害一截，但在第一名看来，你们都是一样渺小。</li></ol><h2 id="这个模型的实践意义"><a href="#这个模型的实践意义" class="headerlink" title="这个模型的实践意义"></a>这个模型的实践意义</h2><p>上一个模型告诉我们要提高<strong>用户邀请数</strong>， 要提高<strong>邀请成功率</strong>。</p><p>这个模型告诉我们：要缩短<strong>病毒传播的周期时长</strong>。这个话题会在接下来的系列中讨论。</p><p>结束这篇文章前，我们再想想下丧尸题材的常见现象：从第1只僵尸诞生到丧尸围城，只需要几天时间。现在你还会怀疑这个设定是否现实吗？</p><h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><p>增长黑客系列：</p><ol><li><a href="/blog/2019/03/05/2019-03-05-userGrow-1/" title="基础裂变模型">基础裂变模型</a> </li><li>升级版裂变模型（本文）</li><li><a href="/blog/2019/05/06/2019-05-07-userGrow-3/" title="增长的3架马车">增长的3架马车</a> </li></ol><p>参考：</p><ul><li><a href="https://www.forentrepreneurs.com/lessons-learnt-viral-marketing/" target="_blank" rel="noopener">David Skok: Lessons Learned – Viral Marketing</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2019/05/01/2019-05-01-userGrow-2/zombie.jpg&quot; class=&quot;&quot; title=&quot;僵尸&quot;&gt;
&lt;a href=&quot;/blog/2019/03/05/2019-03-05-userGrow-1/&quot; title=&quot;本系列的上一篇文章&quot;&gt;本系列的上一篇文章&lt;/a&gt; 介绍了一个纯裂变模型。

我们在本篇加入一个新的变量：裂变周期的时长。直觉告诉我们，裂变周期越短，裂变强度越大。但是，这个强度究竟有多大呢？

我让这个问题再精确一些，假设有2个产品，A 产品裂变周期只有1天，B 产品裂变周期是2天，30天后，A 产品的用户数会是 B 产品的几倍？


    
    </summary>
    
    
      <category term="增长黑客" scheme="http://yoursite.com/categories/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>ggplot系列之：boxplot</title>
    <link href="http://yoursite.com/2019/04/15/2019-04-15-ggplot%E7%B3%BB%E5%88%973/"/>
    <id>http://yoursite.com/2019/04/15/2019-04-15-ggplot%E7%B3%BB%E5%88%973/</id>
    <published>2019-04-15T01:07:33.000Z</published>
    <updated>2020-01-20T05:56:50.987Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2019/04/15/2019-04-15-ggplot%E7%B3%BB%E5%88%973/plot_2.png" class="" title="各大俱乐部的工资结构"><p>数据可视化的常见场景之一是：展示一个 categorical variable 和一个 numeric variable 的关系。</p><p>这时我们可以使用 boxplot。</p><p>这里使用了 <a href="https://www.kaggle.com/karangadiya/fifa19/data" target="_blank" rel="noopener">FIFA 的球员数据集</a>。</p><a id="more"></a><h2 id="大球队的工资状况如何？"><a href="#大球队的工资状况如何？" class="headerlink" title="大球队的工资状况如何？"></a>大球队的工资状况如何？</h2><p>我们想展示几个大球队的工资状况，涉及两个变量：</p><ul><li>球队：categorical variable</li><li>每个球员的工资：numerical variable</li></ul><p>我们先提取几个大俱乐部的数据，并把周薪修改为万欧：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要的俱乐部</span></span><br><span class="line">clubs &lt;- c(<span class="string">'Real Madrid'</span>, <span class="string">'FC Barcelona'</span>, </span><br><span class="line">           <span class="string">'Manchester United'</span>, <span class="string">'Manchester City'</span>, <span class="string">'Liverpool'</span>, <span class="string">'Chelsea'</span>, <span class="string">'Arsenal'</span>,</span><br><span class="line">           <span class="string">'Borussia Dortmund'</span>, <span class="string">'FC Bayern München'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wage_to_number &lt;- <span class="keyword">function</span>(wage) {</span><br><span class="line">  <span class="comment"># 把周薪转换成万欧</span></span><br><span class="line">  number_in_string &lt;- str_extract(wage, <span class="string">'\\d+'</span>)</span><br><span class="line">  number_in_1000 &lt;- as.numeric(number_in_string)</span><br><span class="line">  number_in_1000 * <span class="number">1000</span> / <span class="number">10000</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sub_dat &lt;- dat %&gt;%</span><br><span class="line">  filter(Club %<span class="keyword">in</span>% clubs) %&gt;%</span><br><span class="line">  mutate(Wage = wage_to_number(Wage))</span><br></pre></td></tr></tbody></table></figure><p>下面制作 boxplot：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ggplot(sub_dat) +</span><br><span class="line">  geom_boxplot(aes(x = Club, y = Wage)) +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>,</span><br><span class="line">       y = <span class="string">'工资（周薪：万欧）'</span>,</span><br><span class="line">       title = <span class="string">'各大俱乐部的工资结构'</span>) +</span><br><span class="line">  coord_flip() </span><br></pre></td></tr></tbody></table></figure><p>结果如图：</p><img src="/blog/2019/04/15/2019-04-15-ggplot%E7%B3%BB%E5%88%973/plot_0.png" class="" title="各大俱乐部的工资结构"><p>从这个图可以看到：</p><ul><li>西超双雄、曼城和尤文图斯的工资中位数最高</li><li>多特蒙德的工资水平最低，确实是这几个队里经济实力最低的</li><li>利物浦、切尔西、阿森纳、拜仁在维持相对均衡的收入的同时，还允许超级巨星有高收入</li><li>巴塞罗那有一个收入最高的家伙，不用想，当然是梅西啦</li></ul><h2 id="我们想标注出几个离群值"><a href="#我们想标注出几个离群值" class="headerlink" title="我们想标注出几个离群值"></a>我们想标注出几个离群值</h2><p>有几个球队有收入远远高于队友的球员，我们想看看他们究竟是谁（虽然猜也能猜到了 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8">😊</span>)，并把他们的名字标注在图片上。</p><p>先清理数据：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">outliner_club &lt;- c(<span class="string">'FC Barcelona'</span>, <span class="string">'Liverpool'</span>, <span class="string">'Chelsea'</span>, <span class="string">'Arsenal'</span>, <span class="string">'FC Bayern München'</span>)</span><br><span class="line">outliner_player &lt;- sub_dat %&gt;% </span><br><span class="line">  filter(Club %<span class="keyword">in</span>% outliner_club) %&gt;%</span><br><span class="line">  group_by(Club) %&gt;%</span><br><span class="line">  filter(Wage == max(Wage))</span><br></pre></td></tr></tbody></table></figure><p>我们提取出了几个有离群值的俱乐部收入最高的球员。</p><p>然后，我们在图片上添加 label：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ggplot(sub_dat, aes(x = Club, y = Wage)) +</span><br><span class="line">  geom_boxplot() +</span><br><span class="line">  geom_label(data = outliner_player,</span><br><span class="line">             aes(label = Name),</span><br><span class="line">             nudge_x = <span class="number">0.25</span>,</span><br><span class="line">             nudge_y = <span class="number">0.25</span>, </span><br><span class="line">             label.size = <span class="number">0.1</span>) +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>,</span><br><span class="line">       y = <span class="string">'工资（周薪：万欧）'</span>,</span><br><span class="line">       title = <span class="string">'各大俱乐部的工资结构'</span>) +</span><br><span class="line">  coord_flip() </span><br></pre></td></tr></tbody></table></figure><p>结果如下：<br><img src="/blog/2019/04/15/2019-04-15-ggplot%E7%B3%BB%E5%88%973/plot_1.png" class="" title="各大俱乐部的工资结构+离群值"></p><p>各个全队的异常高收入球员如下：</p><ul><li>巴萨：梅西</li><li>切尔西：C罗</li><li>拜仁：J罗</li><li>利物浦：萨拉赫</li><li>切尔西：阿扎尔</li><li>阿森纳：奥巴梅杨</li></ul><p>有意思的是，利物浦的最高薪球员萨拉赫，薪资水平在皇马也只属于前1/4，在巴萨甚至不到梅西的一半。可见西超双雄的购买力了。</p><h2 id="给曼联上色"><a href="#给曼联上色" class="headerlink" title="给曼联上色"></a>给曼联上色</h2><p>作为一个曼联球迷，我想给曼联的 box 涂上曼联红色，然后给死敌利物浦涂上他们死敌埃弗顿的蓝色 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8">😃</span>，我该怎么办呢？</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sub_dat &lt;- sub_dat %&gt;%</span><br><span class="line">  mutate(isManU = case_when(</span><br><span class="line">    Club == <span class="string">'Manchester United'</span> ~ <span class="string">'ManU'</span>,</span><br><span class="line">    Club == <span class="string">'Liverpool'</span> ~ <span class="string">'Liv'</span>,</span><br><span class="line">    <span class="literal">TRUE</span> ~ <span class="string">'rest'</span></span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">ggplot(sub_dat) +</span><br><span class="line">  geom_boxplot(aes(x = Club, y = Wage, fill=isManU)) +</span><br><span class="line">  scale_fill_manual(breaks = c(<span class="string">"Liv"</span>, <span class="string">"ManU"</span>, <span class="string">"rest"</span>), </span><br><span class="line">                    values=c(<span class="string">"#003399"</span>, <span class="string">"#DA291C"</span>, <span class="string">"white"</span>)) +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>,</span><br><span class="line">       y = <span class="string">'工资（周薪：万欧）'</span>,</span><br><span class="line">       title = <span class="string">'各大俱乐部的工资结构'</span>) +</span><br><span class="line">  coord_flip()  +</span><br><span class="line">  theme(legend.position = <span class="string">"none"</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果如下图：<br><img src="/blog/2019/04/15/2019-04-15-ggplot%E7%B3%BB%E5%88%973/plot_2.png" class="" title="各大俱乐部的工资结构"></p><p>希望利物浦球迷看到了不要打我 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f4a3.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a3.png?v8">💣</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2019/04/15/2019-04-15-ggplot%E7%B3%BB%E5%88%973/plot_2.png&quot; class=&quot;&quot; title=&quot;各大俱乐部的工资结构&quot;&gt;
&lt;p&gt;数据可视化的常见场景之一是：展示一个 categorical variable 和一个 numeric variable 的关系。&lt;/p&gt;
&lt;p&gt;这时我们可以使用 boxplot。&lt;/p&gt;
&lt;p&gt;这里使用了 &lt;a href=&quot;https://www.kaggle.com/karangadiya/fifa19/data&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FIFA 的球员数据集&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>数据科学：用 R 还是 Python?</title>
    <link href="http://yoursite.com/2019/04/05/2019-04-05-RorPython/"/>
    <id>http://yoursite.com/2019/04/05/2019-04-05-RorPython/</id>
    <published>2019-04-05T08:05:05.000Z</published>
    <updated>2020-01-20T05:56:50.987Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2019/04/05/2019-04-05-RorPython/RorPython.png" class="" title="R or Python"><p>数据科学届最常见的一个争论是：R 和 Python，哪个更好呢？</p><p>我不太喜欢这个问题，因为“好”的标准实在太多，不同场景有不同的标准。就拿这个话题来说，初学者为了了解统计学，最合适的肯定是 R；做人工智能的团队为了使用 Tensorflow 等开源工具，最合适的肯定是 python。</p><p>所以在讨论这个话题之前，我先限定好场景：<strong>一个大公司内需要进行庞大业务分析的数据团队。在这个场景内，应该使用哪个工具呢？</strong></p><p>我的方案是：R 和 python 都使用，但在不同的地方使用。</p><a id="more"></a><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>python 明显强过 R 的地方有三点：</p><ul><li>生态：python 的各种 library 实在是太强大了</li><li>机器学习和人工只能</li><li>python 是更“优雅”的语言</li></ul><p>先说生态。如果我想做 http 访问，我会使用 python 的 requests 包。如果我想写爬虫，我会使用 python 的 scrapy 包。如果我想连接 SQL 数据库，我会使用 SQLAlchemy 包…..所有计算机工作，几乎都能在 python 上找到对应的工具。而且，这些工具大概率比 R 语言的 library 要强大。毕竟，给 R 语言写工具的，一般是统计学家，给 python 写工具的，一般是 coder，后者的工具开发能力、文档的可读性都强于前者。</p><p>再说机器学习和人工智能，python 是这个领域的默认语言，tensorflow、pytorch 等开源方案都优先支持 python。</p><p>Python 创建之初，就是在设计一个“简单易用”的语言（这里的“简单易用”要打一个双引号，因为牺牲了其他的东西，但这对数据分析影响不大）。写 python 代码是一种享受。阅读写得好的 python 代码也是一种享受。</p><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><p>R 比 python 强大的地方也有两点：</p><ul><li>R是专门为统计学设计的语言</li><li>强大的统计生态</li></ul><p>R 是专门为统计学设计的语言，python 是更底层的语言，所以做统计分析时，python 需要使用 pandas 等 package，而 R 可以快速上手，直接开始分析。想要使用 python 做数据分析，其实需要学习两个东西：python 和 pandas。</p><p>python 有强大的整体生态，R 则有强大的统计生态。至少在我写这篇文章时，统计学届的默认分析语言基本是 R 语言。世界上最新的统计方法，都能在 R 语言中找到。</p><p>另外，R 语言的数据清洗工具、数据可视化工具和数据报告工具都强过 python（当然，这是个人观点）。</p><ul><li>数据清洗：Hadly Wickham 大神的 tidyverse 系列简直是人类智慧的结晶，这套工具集把数据清洗变成了一种享受。</li><li>数据可视化：还是 Hadly Wickham 大神，他的 ggplot 工具，帮助我们重新重构了数据可视化的思考模式。</li><li>数据报告工具：这要感谢中国的 Yihui 大神，他的 knitr、rmarkdown 等工具，让数据报告的产出变得更轻松、简单且科学规范。</li></ul><h2 id="python-和-R-结合"><a href="#python-和-R-结合" class="headerlink" title="python 和 R 结合"></a>python 和 R 结合</h2><p>说完了两者的优点，现在来说说如何结合两者。</p><p>我使用 python 的场合：</p><ul><li>与数据库的沟通（代替 SQL 语句），因为 SQLAlchemy 的 API 写得非常好</li><li>Restful API 访问，使用 requests 包</li><li>非结构化数据的获取和清洗</li><li>机器学习</li></ul><p>我使用 R 的场合：</p><ul><li>规范性数据的清洗</li><li>统计学假设检验</li><li>统计学建模</li><li>数据可视化和数据报告</li></ul><p>上面的使用场景应该是最能发挥两者优势的。不过按照 python 生态的发展速度，也许很快 python 就会在统计学、可视化和报告产出上超过 R 语言。如果到了那一天，也许只使用 python 就够了。</p><h2 id="如果必须二选一呢"><a href="#如果必须二选一呢" class="headerlink" title="如果必须二选一呢"></a>如果必须二选一呢</h2><p>如果必须2选1呢？这个时候当然要使用 python 了，原因：</p><ul><li>python 的底层生态实在是太棒了，使用过一次之后很难再愿意去用 R 的方案</li><li>python 一直在高速发展，R 的优秀工具会很快被 python 复制</li></ul><p>当然，学习 python 和 R 都挺容易的，如果只是做数据分析的话，会 python 的人一定可以在两周内掌握 R，反之也成立。</p><p>小孩子才做选择题，成年人全都要。</p><img src="/blog/2019/04/05/2019-04-05-RorPython/all.jpg" class="" title="我全都要"><p>那么，excel 呢？都2019年了，严谨的数据分析团队还是不要把 excel 用来做分析工具了。我唯一能想到的 excel 应用场景，是用来“展示”报告。因为，有的决策者希望看到 excel，而不是一个 Word 文档。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2019/04/05/2019-04-05-RorPython/RorPython.png&quot; class=&quot;&quot; title=&quot;R or Python&quot;&gt;
&lt;p&gt;数据科学届最常见的一个争论是：R 和 Python，哪个更好呢？&lt;/p&gt;
&lt;p&gt;我不太喜欢这个问题，因为“好”的标准实在太多，不同场景有不同的标准。就拿这个话题来说，初学者为了了解统计学，最合适的肯定是 R；做人工智能的团队为了使用 Tensorflow 等开源工具，最合适的肯定是 python。&lt;/p&gt;
&lt;p&gt;所以在讨论这个话题之前，我先限定好场景：&lt;strong&gt;一个大公司内需要进行庞大业务分析的数据团队。在这个场景内，应该使用哪个工具呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的方案是：R 和 python 都使用，但在不同的地方使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据科学" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>增长黑客系列之1：基础裂变模型</title>
    <link href="http://yoursite.com/2019/03/05/2019-03-05-userGrow-1/"/>
    <id>http://yoursite.com/2019/03/05/2019-03-05-userGrow-1/</id>
    <published>2019-03-05T13:15:49.000Z</published>
    <updated>2020-01-20T05:56:50.987Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2019/03/05/2019-03-05-userGrow-1/plot_0.png" class="" title="病毒系数的影响"><p>增长黑客是近几年非常火爆的概念，指利用各种技术手段和产品手段帮助产品实现快速增长的人。其实在这个概念出现之前，增长就已经是一个技术和产品的混合领域了。</p><p>按照增长黑客的理念，用户增长的起点不是从市场营销阶段开始，而是从产品的设计阶段就做了规划。比如，当今的所有产品都会考虑用户的自发推广。</p><p>这个系列文章会建立一套增长黑客的数学模型，帮助我们更好地理解增长。</p><p>我们先从最简单的世界开始。</p><p><strong>在这个“创世篇”里，所有产品都只能在发布时做一次市场营销，之后的新用户都必须来自老用户的推荐。</strong> 这个世界的增长故事会长成什么样呢？</p><p><a id="more"></a></p><h2 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h2><p>我们的模型有几个变量：</p><ul><li>第0期的用户数 C_0：最开始的用户数</li><li>人均邀请数 i：每个<strong>新</strong>用户发出去的邀请人数</li><li>感染率 Conv%：一个百分数，指每次邀请的成功率</li></ul><p>这里有个重要假设：每个周期只有新用户会发出邀请。相比于所有用户会在每个周期都发出邀请，这是个更合理的假设。</p><p>场景：每一个周期，每个新用户会邀请 i 个用户，这些用户有 Conv% 的概率会成功变成我们的用户。问题：到了第 t 期，我们的总用户会有多少个呢？</p><p>进一步计算前，我们就需要提到一个著名的概念<strong>病毒因子</strong>，病毒因子的公式是：<strong>人均邀请数 * 感染率%</strong>。</p><p>比如，如果人均邀请数是 10，感染率是 20%，那么第 t 期的每个新用户在第 t + 1 期会给我们带来 2 个新用户，这时病毒因子是 2。</p><p>理解了这个定义后，我们就能定义一个数学模型了。</p><ul><li>第 t 期的新用户数 = 第 t - 1 期的新用户数 * 病毒系数</li><li>第 t 期的总用户数 = 第 t - 1 期的总用户数 + 第 t 期的新用户数</li></ul><h2 id="R-代码"><a href="#R-代码" class="headerlink" title="R 代码"></a>R 代码</h2><p>我们可以用 R 写一套函数，根据不同参数计算总的裂变结果：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">get_new_customer &lt;- <span class="keyword">function</span>(new_customer_last, i, conv) {</span><br><span class="line">  viral_coef &lt;- i * conv</span><br><span class="line">  <span class="keyword">return</span>(new_customer_last * viral_coef)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">get_cycle_data &lt;- <span class="keyword">function</span>(customer_0, i, conv, t) {</span><br><span class="line">  df &lt;- data.frame(matrix(ncol = <span class="number">3</span>, nrow = t))</span><br><span class="line">  colnames(df) &lt;- c(<span class="string">'cycle'</span>, <span class="string">'new_user'</span>, <span class="string">'total_user'</span>)</span><br><span class="line">  </span><br><span class="line">  customer_total &lt;- customer_0</span><br><span class="line">  new_customer_last &lt;- customer_0</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> ( t_i <span class="keyword">in</span> <span class="number">1</span>:t) {</span><br><span class="line">    customer_new &lt;- get_new_customer(new_customer_last, i, conv)</span><br><span class="line">    customer_total &lt;- customer_total + customer_new</span><br><span class="line">    new_customer_last &lt;- customer_new</span><br><span class="line">    df[t_i, ] &lt;- list(t_i, customer_new, customer_total)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span>(df)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我在这里写了两个函数。</p><ul><li>第一个函数会根据上一期的用户数、人均邀请数、感染率计算当期新用户</li><li>第二个函数会完整返回整个周期的新用户数、总用户数</li></ul><h2 id="病毒系数-1-时"><a href="#病毒系数-1-时" class="headerlink" title="病毒系数 = 1 时"></a>病毒系数 = 1 时</h2><p>我们先用第一组参数测试：</p><ul><li>t = 0 时，新用户有10个人</li><li>人均邀请数 = 10</li><li>感染率 = 10%</li></ul><p>此时病毒系数为 1，经过12个周期后，用户数据长什么样呢？</p><div class="table-container"><table><thead><tr><th style="text-align:center">周期</th><th style="text-align:center">新用户</th><th style="text-align:center">总用户</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">10</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">10</td><td style="text-align:center">30</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">10</td><td style="text-align:center">40</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">10</td><td style="text-align:center">50</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">10</td><td style="text-align:center">60</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">10</td><td style="text-align:center">70</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">10</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">10</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">10</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">10</td><td style="text-align:center">110</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">10</td><td style="text-align:center">120</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">10</td><td style="text-align:center">130</td></tr></tbody></table></div><p>可以看到，每个周期的新用户数只有10个，12个周期后，用户只有130个。</p><p>从数学上来说，病毒系数等于1意味着：</p><ul><li>用户会有自然增长</li><li>用户每期的增长速度平缓，是线性的</li><li>从产品上来所，这不是个令人兴奋的场景</li></ul><h2 id="病毒系数-0-5-时"><a href="#病毒系数-0-5-时" class="headerlink" title="病毒系数 = 0.5 时"></a>病毒系数 = 0.5 时</h2><p>上一个产品的数据太差，我们换了个新产品。但因为产品设计问题，这个产品的用户没有那么强的分享欲望，人均分享减半了。</p><p>参数如下：</p><ul><li>t = 0 时，新用户有10个人</li><li>人均邀请数 = 5</li><li>感染率 = 10%</li></ul><p>结果如下（因为是数学模型，所以不用在乎0.5个人的问题）：</p><div class="table-container"><table><thead><tr><th style="text-align:center">周期</th><th style="text-align:center">新用户</th><th style="text-align:center">总用户</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">5.00</td><td style="text-align:center">15.00</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2.50</td><td style="text-align:center">17.50</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1.25</td><td style="text-align:center">18.75</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">0.62</td><td style="text-align:center">19.38</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">0.31</td><td style="text-align:center">19.69</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">0.16</td><td style="text-align:center">19.84</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">0.08</td><td style="text-align:center">19.92</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">0.04</td><td style="text-align:center">19.96</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">0.02</td><td style="text-align:center">19.98</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">0.01</td><td style="text-align:center">19.99</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">0.00</td><td style="text-align:center">20.00</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">0.00</td><td style="text-align:center">20.00</td></tr></tbody></table></div><p>在病毒系数等于0.5时，产品的用户数很快会停止增长，理论上的最大值是20个人，仅仅是初期用户数的两倍。谁都不希望开发这样的产品。</p><h2 id="病毒系数-2-时"><a href="#病毒系数-2-时" class="headerlink" title="病毒系数 = 2 时"></a>病毒系数 = 2 时</h2><p>上一个产品的数据让老板无法忍受，也是我们开发了一个新产品。我们优化了邀请的截图和文案，让邀请的感染率上升到了15%。</p><p>参数如下：</p><ul><li>t = 0 时，新用户有10个人</li><li>人均邀请数 = 10</li><li>感染率 = 20%</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">周期</th><th style="text-align:center">新用户</th><th style="text-align:center">总用户</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">20</td><td style="text-align:center">30</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">40</td><td style="text-align:center">70</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">80</td><td style="text-align:center">150</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">160</td><td style="text-align:center">310</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">320</td><td style="text-align:center">630</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">640</td><td style="text-align:center">1270</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">1280</td><td style="text-align:center">2550</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">2560</td><td style="text-align:center">5110</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">5120</td><td style="text-align:center">10230</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">10240</td><td style="text-align:center">20470</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">20480</td><td style="text-align:center">40950</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">40960</td><td style="text-align:center">81910</td></tr></tbody></table></div><p>病毒系数等于2时，12个周期后，产品的总用户数会达到8.1万。最神奇的是，用户数在某个周期几乎是翻倍增长。如果你碰到这样的产品，恭喜你，你离财富自由已经不远了。</p><h2 id="用图片病毒系数的差距的影响"><a href="#用图片病毒系数的差距的影响" class="headerlink" title="用图片病毒系数的差距的影响"></a>用图片病毒系数的差距的影响</h2><p>病毒系数不大于1，理论上我们实现不了自然增长和裂变。我们直到病毒系数越大越好，可是当病毒系数的大于1时，每增加0.2，究竟会有多大影响呢？</p><p>我们把这个数据用图片表示出来。</p><img src="/blog/2019/03/05/2019-03-05-userGrow-1/plot_1.png" class="" title="病毒系数的影响"><p>虽然只是0.2的差异，但12个周期之后，不同病毒系数的表现是天壤之别。如果你对指数增长有所了解，应该会发现病毒系数较高时，用户增长是指数形式的。在指数模型下，每1个点的增长，都会是长期来看巨大的增长。</p><h2 id="模型的实践意义"><a href="#模型的实践意义" class="headerlink" title="模型的实践意义"></a>模型的实践意义</h2><p>这个简单的模型告诉我们：</p><ul><li><strong>病毒系数是裂变模型里最重要的因素</strong></li><li>要<strong>统计</strong>产品的人均邀请数和的感染率</li><li>不断<strong>优化</strong>人均邀请数和感染率</li></ul><p>不要小看这个实践意义，很多产品是完全没有统计邀请用户邀请数和邀请成功率的，如果连基本的“测量”都不做，又怎么谈得上基于数据的优化呢？</p><blockquote><p>If you can’t measure it, you can’t improve it.</p></blockquote><h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><p>增长黑客系列文章：</p><ol><li>基础裂变模型</li><li><a href="/blog/2019/05/01/2019-05-01-userGrow-2/" title="升级版裂变模型">升级版裂变模型</a> </li><li><a href="/blog/2019/05/06/2019-05-07-userGrow-3/" title="增长的3架马车">增长的3架马车</a> </li></ol><p>参考：</p><ul><li><a href="https://www.forentrepreneurs.com/lessons-learnt-viral-marketing/" target="_blank" rel="noopener">David Skok: Lessons Learned – Viral Marketing</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2019/03/05/2019-03-05-userGrow-1/plot_0.png&quot; class=&quot;&quot; title=&quot;病毒系数的影响&quot;&gt;
&lt;p&gt;增长黑客是近几年非常火爆的概念，指利用各种技术手段和产品手段帮助产品实现快速增长的人。其实在这个概念出现之前，增长就已经是一个技术和产品的混合领域了。&lt;/p&gt;
&lt;p&gt;按照增长黑客的理念，用户增长的起点不是从市场营销阶段开始，而是从产品的设计阶段就做了规划。比如，当今的所有产品都会考虑用户的自发推广。&lt;/p&gt;
&lt;p&gt;这个系列文章会建立一套增长黑客的数学模型，帮助我们更好地理解增长。&lt;/p&gt;
&lt;p&gt;我们先从最简单的世界开始。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在这个“创世篇”里，所有产品都只能在发布时做一次市场营销，之后的新用户都必须来自老用户的推荐。&lt;/strong&gt; 这个世界的增长故事会长成什么样呢？&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="增长黑客" scheme="http://yoursite.com/categories/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2/"/>
    
    
      <category term="R" scheme="http://yoursite.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript：如何理解“异步”和“同步”</title>
    <link href="http://yoursite.com/2018/07/01/2018-07-01-Async/"/>
    <id>http://yoursite.com/2018/07/01/2018-07-01-Async/</id>
    <published>2018-07-01T10:55:04.000Z</published>
    <updated>2020-01-20T05:56:50.987Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2018/07/01/2018-07-01-Async/syncOrAsync.png" class="" title="asyncOrSync"><p>刚开接触 JavaScript 时，synchronous 和 asynchronous 的概念简直让我头疼。在那之前，我只跟 R 和 python，而且只做数据分析工作，完全不需要考虑“同步”和“异步”的问题（而且，鬼知道它们是什么）。</p><p>开始玩前端框架后，我才意识到，这是个很重要的概念。</p><p>这篇文章简单总结下 JavaScript 里的 sync 和 async。汉语里的“同步”和“异步”其实有些歧义，为了方便思考，我一般直接用 sync 和 async 来表述。</p><a id="more"></a><h2 id="解释和比喻"><a href="#解释和比喻" class="headerlink" title="解释和比喻"></a>解释和比喻</h2><p>解释：</p><ul><li>sync：指代码按照顺序执行，一段代码执行完毕后，再去执行下一段。</li><li>async：一行代码发出调用指令后，不去等待这段代码的执行结果，就直接去执行下一段代码。</li></ul><p>上面的解释可能比较抽象，我们做一个比喻：想象你在星巴克排队买咖啡。</p><ul><li>sync：轮到你点咖啡，你选好了咖啡，告诉咖啡师，咖啡师开始做咖啡，你在柜台前等待，不能做任何别的事情，只能静静地等咖啡师把咖啡做完。拿到咖啡后，你才能去做下一件事情，比如找到座位开始工作。</li><li>async：轮到你带你咖啡，你点了咖啡，告诉咖啡师，然后你找了个座位，打开电脑开始工作，咖啡师做好咖啡后，把咖啡拿给你。</li></ul><p>Sync 的顺序如下图：<br><img src="sync.png" alt="sync 例子"></p><p>在 sync 模式下，拿到咖啡之前，我们什么也干不了，只能干等着。</p><p>Async 的顺序如下图：<br><img src="async.png" alt="async 例子"><br>在 async 模式下，咖啡师在煮咖啡，我们可以先去忙别的事情，当咖啡师做完咖啡后，我们会收到咖啡。显然这种情况是更节约时间的。</p><h2 id="JavaScript-的例子"><a href="#JavaScript-的例子" class="headerlink" title="JavaScript 的例子"></a>JavaScript 的例子</h2><p>我们把上面的例子用 JavaScript 代码来执行：</p><figure class="highlight javascript"><figcaption><span>Sync</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"点咖啡"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"------等待2分钟-----"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"拿到咖啡"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"找座位"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"打开电脑"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"开始工作"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//点咖啡</span></span><br><span class="line"><span class="comment">//------等待2分钟-----</span></span><br><span class="line"><span class="comment">//拿到咖啡</span></span><br><span class="line"><span class="comment">//找座位</span></span><br><span class="line"><span class="comment">//打开电脑</span></span><br><span class="line"><span class="comment">//开始工作</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到，一切都按照顺序进行。</p><p>然后是 Async 的代码<br></p><figure class="highlight javascript"><figcaption><span>Async</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"点咖啡"</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"-----2分钟过去了-----"</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"拿到咖啡"</span>)</span><br><span class="line">}, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"找座位"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"打开电脑"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"开始工作"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//点咖啡</span></span><br><span class="line"><span class="comment">//找座位</span></span><br><span class="line"><span class="comment">//打开电脑</span></span><br><span class="line"><span class="comment">//开始工作</span></span><br><span class="line"><span class="comment">//-----2分钟过去了-----</span></span><br><span class="line"><span class="comment">//拿到咖啡</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>这里有意思的地方是， “——-2分钟过去了——-” 和 “拿到咖啡” 在顺序上是第2和第3位，但因为异步，它们在最后才被执行。换句话说，我们利用空闲的时间先处理了之后的工作。</p><h2 id="什么场合使用-async-和-sync"><a href="#什么场合使用-async-和-sync" class="headerlink" title="什么场合使用 async 和 sync"></a>什么场合使用 async 和 sync</h2><p>在我们上面的例子里，咖啡师做咖啡是一件消耗时间的任务，在产品设计中也有类似的任务，比如从远在天边的数据库获取大量数据，我们不知道要等待多久，这时候就可以使用 async，让我们的计算机在获取到数据前先做一些其他工作。</p><p>使用 async 的典型场景：</p><ul><li>数据库操作（大量的读写）</li><li>网络数据传输（从服务器或API获取数据）</li><li>远端 API 操作（如调调用一个复杂的机器学习 API）</li></ul><p>使用 sync 的典型场景：程序操作之间有明显的顺序关系。如用户输入账号密码、校验、登陆，这是一个明显有顺序的流程。</p><p>另一个思考方式是：当你不知道该用 async 还是 sync 时，就先默认用 sync 吧。</p><p>如果想JS实现 async 的机制，可以参考：</p><ul><li><a href="https://medium.com/better-programming/is-javascript-synchronous-or-asynchronous-what-the-hell-is-a-promise-7aa9dd8f3bfb" target="_blank" rel="noopener">Is JavaScript Synchronous or Asynchronous? What the Hell is a Promise?</a></li><li><a href="https://medium.com/@siddharthac6/javascript-execution-of-synchronous-and-asynchronous-codes-40f3a199e687" target="_blank" rel="noopener">JavaScript: Execution of Synchronous and Asynchronous codes</a></li><li><a href="https://fastapi.tiangolo.com/async/#concurrency-and-burgers" target="_blank" rel="noopener">FASTapi - Concurrency and async / await</a></li><li><a href="https://css-tricks.com/understanding-async-await/" target="_blank" rel="noopener">Understanding Async Await</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2018/07/01/2018-07-01-Async/syncOrAsync.png&quot; class=&quot;&quot; title=&quot;asyncOrSync&quot;&gt;
&lt;p&gt;刚开接触 JavaScript 时，synchronous 和 asynchronous 的概念简直让我头疼。在那之前，我只跟 R 和 python，而且只做数据分析工作，完全不需要考虑“同步”和“异步”的问题（而且，鬼知道它们是什么）。&lt;/p&gt;
&lt;p&gt;开始玩前端框架后，我才意识到，这是个很重要的概念。&lt;/p&gt;
&lt;p&gt;这篇文章简单总结下 JavaScript 里的 sync 和 async。汉语里的“同步”和“异步”其实有些歧义，为了方便思考，我一般直接用 sync 和 async 来表述。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="http://yoursite.com/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数据团队的三个角色：数据科学家、数据分析师、数据工程师</title>
    <link href="http://yoursite.com/2018/05/06/2018-05-07-%E6%95%B0%E6%8D%AE%E5%9B%A2%E9%98%9F/"/>
    <id>http://yoursite.com/2018/05/06/2018-05-07-%E6%95%B0%E6%8D%AE%E5%9B%A2%E9%98%9F/</id>
    <published>2018-05-06T18:39:41.000Z</published>
    <updated>2020-01-20T05:56:50.987Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2018/05/06/2018-05-07-%E6%95%B0%E6%8D%AE%E5%9B%A2%E9%98%9F/data.png" class="" title="三者的区别"><p>一般来说，一个完整的数据团队应该由3个角色构成：</p><ul><li>数据分析师 data analyst</li><li>数据工程师 data engineer</li><li>数据科学家 data scientist</li></ul><p>这篇文章总结三个角色的区别，并说明何种情况下团队里应该有这些角色。</p><a id="more"></a><h2 id="三个角色"><a href="#三个角色" class="headerlink" title="三个角色"></a>三个角色</h2><p>三个角色的工作有时会有一定程度的交集，这里只讨论三个角色的最重要差异。</p><ul><li>数据分析师： 需要了解业务，使用<strong>常规的数据分析方法</strong>为日常商业决策提供依据</li><li>数据工程师：创造和维护数据基础设施</li><li>数据科学家：掌握机器学习算法，擅长数学、统计学和编程，可以处理大数据分析需求</li></ul><h3 id="数据分析师"><a href="#数据分析师" class="headerlink" title="数据分析师"></a>数据分析师</h3><p>数据分析师是最常见的角色，已经存在了很多年。早期的数据分析师只需要掌握 Excel 的使用，生成日常数据报表，做一定的数据可视化。一般情况下，数据分析师还需要懂业务，并通过数据对商业决策提供建议。</p><p>稍微进阶的数据分析师，还会懂一些 inferential statistics，使用线性回归等方法做归因和预测。</p><p>随着大家的学习能力越来越强，数据分析已经变成了一个基本技能。在这个环境下，数据分析师的核心价值是什么呢？我认为是“懂业务”。</p><p>数据分析师需要非常了解自己业务的情况，拿游戏来举例，数据分析师应该了解自己所分析的游戏、了解游戏行业的数据特点。SLG 游戏和 ARPG 游戏就是两个完全不同的游戏类型，如果某个核心指标相同（比如7日ROI），数据分析师需要针对两种游戏做不同的判断。同时，数据分析师应该深度体验自己的游戏，并能结合游戏体验提出值得研究的问题。</p><p>因为“懂业务”同时也“懂数据”，数据分析师应该是最能影响项目决策的人。</p><p>数据分析师的常见学科背景：商科、经济学、统计学。</p><h3 id="数据工程师"><a href="#数据工程师" class="headerlink" title="数据工程师"></a>数据工程师</h3><p>数据工程师其实是“需要做数据相关开发工作”的程序员，比如数据存储、数据计算、数据后台的搭建等等。</p><p>在小一些的公司，数据工程师一般由后端开发人员兼任。大型的公司，会需要专门的数据工程师。</p><p>数据工程师的常见学科背景：计算机。</p><h3 id="数据科学家"><a href="#数据科学家" class="headerlink" title="数据科学家"></a>数据科学家</h3><p>数据科学家是最近几年又硅谷带动起来的新兴岗位。数据科学家最核心的特点是：能用<strong>科学的</strong>方法解决企业的数据分析问题。</p><p>为什么这里提到“科学的”方法呢？有两个原因。</p><p>第1，很多数据分析师的分析工作其实充满了主观判断，毫无科学性可言。举个例子，我在某上市游戏公司的数据部门上班时，发现他们的数据分析报告<strong>从来不会</strong>使用假设检验，重要决策只通过画图寻找相关性后“主观判断”。数据分析其实是个有着严格科学基础的工作，专业的数据科学家会让团队的数据决策更加准确。</p><p>第2，大数据的兴起，让数据分析工作从传统的 excel 就能解决变成必须依赖高强度的编程能力和数学能力。</p><p>数据科学家有如下特点：</p><ul><li>高学历</li><li>强大的数学和统计学能力</li><li>了解机器学习、NLP 等新兴数据分析领域的情况</li><li>强大的（数学）编程水平</li></ul><p>相比于数据分析师，数据科学家可能不是那么懂业务。<br>相比于数据工程师，数据科学家又不是那么懂数据库、API。</p><p></p><h2 id="三个角色的需求"><a href="#三个角色的需求" class="headerlink" title="三个角色的需求"></a>三个角色的需求</h2><p>数据分析师：大中小型团队都需要的角色<br>数据工程师：大型团队需要<br>数据科学家：大型团队需要</p><p>我了解的美国某著名游戏公司的情况：</p><ul><li>每一个项目里都有数据分析师，专门负责这个项目的分析工作和决策支持</li><li>数据工程师和数据科学家，不跟随项目走，在项目需要的时候提供工程支持和理论支持</li></ul><p>工作场景举例：</p><ul><li>数据分析师：日常分析需求、数据分析报告</li><li>数据工程师：分析师想要增加10个埋点，工程师满足这个需求</li><li>数据科学家：审查数据分析师的分析报告是否符合科学规范</li></ul><p>对最顶级的公司，竞争的核心点其实是数据科学家。一个强大的数据科学家团队，可以让数据决策的精准度得到巨大提高。因为，数据科学家可以把结论用概率的形式科学的表示出来。（也许某些数据分析师也可以，但我不敢信他们啊）。</p><p>如果没有数据科学家，很有可能出现两种情况：</p><ul><li>数据分析师给出质量无法保证的数据分析结果</li><li>团队依靠“数据可视化”的图像做出“猜测”</li></ul><p>什么叫“团队依靠图像做出猜测”呢？举个让我印象深刻的例子吧。在游戏公司上班时，项目负责人拉数据之后画两个折线图，发现两者都有向上的趋势，于是推测出两者正相关，进而得出了一个行动依据。在懂数据分析的人看来，这大概跟“夜观天象”的靠谱程度差不多吧。一个数据科学家会在这个问题上给出严谨的数学公式、编程计算和结果报告，这就是数据科学家的价值。</p><p>但是，只有在尊重科学的公司，数据科学家的声音才会被重视。这可能也是硅谷才有这么多数据科学家岗位的原因吧啊。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2018/05/06/2018-05-07-%E6%95%B0%E6%8D%AE%E5%9B%A2%E9%98%9F/data.png&quot; class=&quot;&quot; title=&quot;三者的区别&quot;&gt;
&lt;p&gt;一般来说，一个完整的数据团队应该由3个角色构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据分析师 data analyst&lt;/li&gt;
&lt;li&gt;数据工程师 data engineer&lt;/li&gt;
&lt;li&gt;数据科学家 data scientist&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章总结三个角色的区别，并说明何种情况下团队里应该有这些角色。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据科学" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
  </entry>
  
</feed>
