<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>写作即思考</title>
  
  <subtitle>Yu 的博客</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://yupototo.github.io/blog/"/>
  <updated>2020-02-05T00:34:51.176Z</updated>
  <id>https://yupototo.github.io/blog/</id>
  
  <author>
    <name>Yu Qin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小心均值</title>
    <link href="https://yupototo.github.io/blog/2020/01/20/ds-5-beware-of-mean/"/>
    <id>https://yupototo.github.io/blog/2020/01/20/ds-5-beware-of-mean/</id>
    <published>2020-01-20T12:56:00.000Z</published>
    <updated>2020-02-05T00:34:51.176Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2020/01/20/ds-5-beware-of-mean/power-law.png" class="" title="power law distribution"><p>在 Hacker News 看到一篇文章 <a href="https://stephen.sh/posts/beware-the-mean" target="_blank" rel="noopener">Beware the mean</a>。这篇文章的主题是：均值不是完美的指标，甚至极端一点地说，在分布符合 power-law 的情况下，均值是糟糕的指标。</p><p>我在游戏公司做数据分析时就对这个问题有强烈的感触，但当时没能想到更好的指标。<a href="https://stephen.sh/posts/beware-the-mean" target="_blank" rel="noopener">Beware the mean</a> 提出了一些值得探讨的思路。</p><a id="more"></a><h2 id="为什么均值不够好"><a href="#为什么均值不够好" class="headerlink" title="为什么均值不够好"></a>为什么均值不够好</h2><p>判断一个游戏的好坏时，经常使用 LTV 作为指标。</p><p>LTV 的英文是 life time value，含义是“用户生命周期”收入。严格地说，它应该是一个分布。</p><p>如果有1000个用户，经过30天后，我们可以计算这1000个用户的付费，得到1000个30天LTV。然后我们可以画一个直方图，查看LTV的分布情况。但我当年所在的3个游戏公司都不会这样做。</p><p>最粗暴的算法是：1000个用户在30天的总收入/1000。对数学足够敏感的人会很快意识到，这个数字是上面描述的分布的均值，这个均值，一般被称为<strong>30日LTV</strong>。</p><p>游戏公司用这个指标判断游戏的营收能力。这是完全不够的。</p><p>这1000个人可以当作一个随机抽样，少数离群值会严重影响计算出的均值大小。</p><p>比如，1000个人如果刚好有个土豪，均值显然会很高，而如果没有土豪进入（考虑到土豪的数量至少，这是大概率事件），游戏的营收能力会被低估。</p><p>换句话说，如果只使用均值，大概率会错判游戏的营收能力，进而让人做出错误的商业决策。</p><p>我对这个问题有亲身体会。我曾经在一家中型游戏公司工作，这家公司同时运营很多款游戏，每个游戏都有1到2个运营在调节运营活动。他们调整运营活动的决策依据大部分是 ARPPU（每付费用户的收入），这也是一个均值。</p><p>理论上说，因为土豪的概率很低，所以应该能看到每个游戏服之间存在巨大的 ARPPU 波动。运营人员经常修改游戏活动，一旦修改游戏活动后 ARPPU 增加，他们就会认为活动是有用的，否则，他们就会认为活动没用。当然，活动没用的情况是最多的，毕竟 power-law 分布下土豪的概率低嘛。</p><p>因为上面这个基于均值的思路，运营人员观察到了大量的数据波动，并把这些波动理解为是自己行为的后果，于是总结规律，希望能复制成功方案。结果因为数据受到随机因素影响，下次出现不了同样的成功，运营人员又得去思考新的方案，于是循环往复，浪费大量时间精力。</p><h2 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h2><p><a href="https://stephen.sh/posts/beware-the-mean" target="_blank" rel="noopener">Beware the mean</a> 提到的替代方案是：选择分位数上的指标作为衡量标准。</p><p>比如，可以根据业务情况定指标如下：</p><ul><li>80% 分位数上的用户的付费需要超过用户获取成本</li><li>90% 分位数上的用户付费需要超过 x 元</li><li>99% 分位数上的用户付费要超过 y 元</li><li>最大值要超过 z 元</li></ul><p>按照这个标准去设定 KPI，有两个好处：</p><ol><li>可以帮助我们从分布角度去理解并“设计”用户收入的构成</li><li>避免极端异常值的影响</li></ol><p>它不一定能完全替代传统的“均值”指标，毕竟，均值是最简单易懂的，在组织层面使用均值作为指标能最小化沟通成本。</p><p>但对于员工知识水平比较高的团队，这是一个值得尝试的思路。这个方法一旦验证有效，会是一个很难被模仿的竞争优势。为什么很难被模仿呢？因为想让游戏公司的同事理解分位数并不容易，更别说应用在日常工作中了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2020/01/20/ds-5-beware-of-mean/power-law.png&quot; class=&quot;&quot; title=&quot;power law distribution&quot;&gt;
&lt;p&gt;在 Hacker News 看到一篇文章 &lt;a href=&quot;https://stephen.sh/posts/beware-the-mean&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Beware the mean&lt;/a&gt;。这篇文章的主题是：均值不是完美的指标，甚至极端一点地说，在分布符合 power-law 的情况下，均值是糟糕的指标。&lt;/p&gt;
&lt;p&gt;我在游戏公司做数据分析时就对这个问题有强烈的感触，但当时没能想到更好的指标。&lt;a href=&quot;https://stephen.sh/posts/beware-the-mean&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Beware the mean&lt;/a&gt; 提出了一些值得探讨的思路。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据科学" scheme="https://yupototo.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>KNN 算法</title>
    <link href="https://yupototo.github.io/blog/2019/09/02/ds-7-knn/"/>
    <id>https://yupototo.github.io/blog/2019/09/02/ds-7-knn/</id>
    <published>2019-09-02T20:24:16.000Z</published>
    <updated>2020-02-05T00:34:51.176Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2019/09/02/ds-7-knn/knn.png" class="" title="knn"><p>K Nearest Neighbor, KNN 算法，应该是最简单的机器学习算法之一。</p><p>这里用一个手算的例子说明 KNN 算法的步骤。</p><p><a id="more"></a></p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>该算法的步骤如下：</p><ol><li>决定参数 K，即判断分类时考虑几个“邻居”</li><li>计算新的样本与训练数据集里各个观测值的<strong>距离</strong></li><li>将距离由小到大排序，保留前 K 个观测值</li><li>获取这 K 个观测值的 category</li><li>以这 K 个观测值里占多数的 category 作为新样本的 category</li></ol><h2 id="手算例子"><a href="#手算例子" class="headerlink" title="手算例子"></a>手算例子</h2><p>training data set 如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">自变量1</th><th style="text-align:center">自变量2</th><th style="text-align:center">分类</th></tr></thead><tbody><tr><td style="text-align:center">7</td><td style="text-align:center">7</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">4</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">0</td></tr></tbody></table></div><p>只有2个变量，4个观测值。</p><p>假设新的样本是 <strong>(3, 7)</strong>。</p><h3 id="第1步：选定-K"><a href="#第1步：选定-K" class="headerlink" title="第1步：选定 K"></a>第1步：选定 K</h3><p>第1步，要决定一个参数 K。</p><p>我们选定参数 k = 3。</p><h3 id="第2步：计算距离"><a href="#第2步：计算距离" class="headerlink" title="第2步：计算距离"></a>第2步：计算距离</h3><p>计算新的样本与训练数据集里各个观测值的<strong>距离</strong>。距离公式采用 euclidean distance。</p><img src="/blog/2019/09/02/ds-7-knn/euc_d.png" class="" title="euc_d"><p>按照这个公式计算(3, 7)跟各个点的距离：</p><div class="table-container"><table><thead><tr><th style="text-align:center">自变量1</th><th style="text-align:center">自变量2</th><th style="text-align:center">距离</th></tr></thead><tbody><tr><td style="text-align:center">7</td><td style="text-align:center">7</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">4</td><td style="text-align:center">25</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">13</td></tr></tbody></table></div><h3 id="第3步：排序"><a href="#第3步：排序" class="headerlink" title="第3步：排序"></a>第3步：排序</h3><p>按照距离，由小到大排序，保留前 k 个：</p><div class="table-container"><table><thead><tr><th style="text-align:center">自变量1</th><th style="text-align:center">自变量2</th><th style="text-align:center">距离</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">13</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">7</td><td style="text-align:center">16</td></tr></tbody></table></div><h3 id="第4步：获取-category"><a href="#第4步：获取-category" class="headerlink" title="第4步：获取 category"></a>第4步：获取 category</h3><p>获取这几个值的 category</p><div class="table-container"><table><thead><tr><th style="text-align:center">自变量1</th><th style="text-align:center">自变量2</th><th style="text-align:center">距离</th><th style="text-align:center">分类</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">9</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">13</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">7</td><td style="text-align:center">16</td><td style="text-align:center">1</td></tr></tbody></table></div><h3 id="第5步：确定-category"><a href="#第5步：确定-category" class="headerlink" title="第5步：确定 category"></a>第5步：确定 category</h3><p>以这 K 个观测值里占多数的 category 作为新样本的 category。</p><p>占多数的分类是 0，所以 (3,7) 被判断为是 0。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>KNN 算法的简单之处在于：</p><ul><li>没有新的概念，懂高中数学的人都能理解这个算法</li><li>是<em>无参数</em>方法，不用考虑统计学公式</li><li>算法步骤比较简单</li></ul><p>这个算法的实现可以当作一个 python 练习来做。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2019/09/02/ds-7-knn/knn.png&quot; class=&quot;&quot; title=&quot;knn&quot;&gt;
&lt;p&gt;K Nearest Neighbor, KNN 算法，应该是最简单的机器学习算法之一。&lt;/p&gt;
&lt;p&gt;这里用一个手算的例子说明 KNN 算法的步骤。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据科学" scheme="https://yupototo.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="机器学习" scheme="https://yupototo.github.io/blog/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Association Rules：定义和指标</title>
    <link href="https://yupototo.github.io/blog/2019/08/31/ds-6-association/"/>
    <id>https://yupototo.github.io/blog/2019/08/31/ds-6-association/</id>
    <published>2019-08-31T05:34:37.000Z</published>
    <updated>2020-02-05T00:34:51.176Z</updated>
    
    <content type="html"><![CDATA[<p>Association Rules 解决的问题是：哪些商品经常被一起购买。</p><p>典型例子如下图，这是 Udemy 某课程页面里的搭售信息：</p><img src="/blog/2019/08/31/ds-6-association/udemy.png" class="" title="udemy"><p>Udemy 的推荐系统基于 association rule 判断出这两个商品经常被一起购买，所以打包推荐了这两个商品。</p><p>这篇文章主要说明 association rule 里的几个定义和指标</p><p><a id="more"></a></p><h2 id="Itemset"><a href="#Itemset" class="headerlink" title="Itemset"></a>Itemset</h2><h3 id="Antecedent-和-Consequent"><a href="#Antecedent-和-Consequent" class="headerlink" title="Antecedent 和 Consequent"></a>Antecedent 和 Consequent</h3><p>关联规则的表达形式是：<em>如果 A，那么 B</em>。表示 A 和 B 两组商品会大概率一起出现。</p><p>在上面的规则里，A 被称为 antecedent，是一组商品；B 被称为 consequent，是另一组商品。</p><p>每一个 antecedent 和 consequent 的组合，被称为一个 <strong>itemset</strong>。</p><p>例子：购买了<em>面包</em>和<em>鸡蛋</em>的用户，也会购买<em>牛奶</em>。用 antecedent、consequent 和 itemset 表示规则如下：</p><ul><li>antecedent：{面包, 鸡蛋}</li><li>consequent: {牛奶}</li><li>itemset: {面包, 鸡蛋, 牛奶}</li></ul><p>在文献里用 {} 表示 itemset，在 python 里，{} 刚好也是 set。</p><h3 id="根据订单计算-itemsets"><a href="#根据订单计算-itemsets" class="headerlink" title="根据订单计算 itemsets"></a>根据订单计算 itemsets</h3><p>一个包含“面包，鸡蛋，牛奶”的订单，有几个 itemset 呢？</p><p>所有 itemset 如下：</p><ul><li>面包</li><li>鸡蛋</li><li>牛奶</li><li>面包，鸡蛋</li><li>面包，牛奶</li><li>鸡蛋，牛奶</li><li>面包，鸡蛋，牛奶</li></ul><p>共7个itemset。</p><p>1个商品，也算一个 itemset。</p><p>根据交易历史，可以得到一个商店的 itemsets。以下面的交易记录为例（1表示购买，0表示未购买）：</p><div class="table-container"><table><thead><tr><th style="text-align:center">订单编号</th><th style="text-align:center">鸡蛋</th><th style="text-align:center">牛奶</th><th style="text-align:center">咖啡</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></div><ul><li>{鸡蛋} x 2</li><li>{牛奶} x 3</li><li>{咖啡} x 2</li><li>{鸡蛋，牛奶} x 2</li><li>{鸡蛋，咖啡} x 1</li><li>{牛奶，咖啡} x 2</li><li>{鸡蛋，咖啡，牛奶} x 1</li></ul><p>上面的交易记录里医用有 13 个itemsets。</p><h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><p>Associaition rule 的核心问题是：如何判断哪些 rule 是有价值的。</p><p>几个比较重要的指标是：</p><ul><li>support</li><li>confidence</li><li>lift</li></ul><h3 id="Support"><a href="#Support" class="headerlink" title="Support"></a>Support</h3><p>support 的定义是：itemset 的占比。</p><p>以上面的3个订单为例子，各个 itemset 的 suport 依次是：</p><ul><li>{鸡蛋} = 2/13 = 15.4%</li><li>{牛奶} = 3/13 = 23%</li><li>{咖啡} = 2/13 = 15.4%</li><li>{鸡蛋，牛奶} = 2/13 = 15.4%</li><li>{鸡蛋，咖啡} = 1/13 = 7.7%</li><li>{牛奶，咖啡} = 2/13 = 15.4%</li><li>{鸡蛋，咖啡，牛奶}  = 1/13 = 7.7%</li></ul><p>Support 可以用数学公式描述为：Support = P(antecedent AND consequent)</p><h3 id="Confidence"><a href="#Confidence" class="headerlink" title="Confidence"></a>Confidence</h3><p>confidence 的定义是：给定 antecedent，consequent 发生的概率有多大？</p><p>confidence 的数学公式是：Confidence = P(antecedent AND consequent) / P(antecedent) = P(consequent | antecedent)</p><p>还是用刚才的例子：</p><p>“if 牛奶，then 鸡蛋”的 confidence 是：P(牛奶 and 鸡蛋) / P(牛奶) = 15.4% / 23% = 67%</p><p>“if 咖啡，then 牛奶+鸡蛋” 的 confidence 是：P(咖啡 and 牛奶 and 鸡蛋) / P(咖啡) = 7.7% / 15.4% = 50%</p><p>这个指标有一定的欺骗性。如果 antecedent 和 consequent 都有很高的 support，那么相应的 confidence 必然很高，即使两者相互独立。</p><p>所以我们需要第三个指标：Lift Ratio。</p><h3 id="Lift-Ratio"><a href="#Lift-Ratio" class="headerlink" title="Lift Ratio"></a>Lift Ratio</h3><p>假定 antecedent 和 consequent 相互独立，我们可以计算出一个理论的 confidence 值。这个 confidence 被命名为 benchmark confidence 值。</p><p>假定两者相互独立，可以有：</p><p>P(antecedent AND consequent) = P(antecedent) * P(consequent)</p><p>然后可以计算 benchmark confidence：</p><p>Benchmark Confidence = P(antecedent) * P(consequent) / P(antecedent) = P(consequent)</p><p>然后可以计算 <strong>lift ratio</strong>：</p><p>lift ratio = confidence / benchmark confidence</p><p>以下面几个规则为例</p><p>“if 牛奶，then 鸡蛋”：</p><ul><li>benchmark confidence = P(consequent) = P(鸡蛋) = 23%</li><li>confidence = 67%</li><li>lift = 67% / 23% = 2.7</li></ul><p>if 咖啡，then 牛奶+鸡蛋”:</p><ul><li>benchmark confidence = P(牛奶 AND 鸡蛋) = 15.4%</li><li>confidence = 50%</li><li>lift = 50% / 15.4% = 3.25</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Association rules 的算法都基于上面几个概念和指标。理解了这些指标后，如果有必要，可以去看算法，如果对算法细节不在意，基本就可以直接去跑数据了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Association Rules 解决的问题是：哪些商品经常被一起购买。&lt;/p&gt;
&lt;p&gt;典型例子如下图，这是 Udemy 某课程页面里的搭售信息：&lt;/p&gt;
&lt;img src=&quot;/blog/2019/08/31/ds-6-association/udemy.png&quot; class=&quot;&quot; title=&quot;udemy&quot;&gt;
&lt;p&gt;Udemy 的推荐系统基于 association rule 判断出这两个商品经常被一起购买，所以打包推荐了这两个商品。&lt;/p&gt;
&lt;p&gt;这篇文章主要说明 association rule 里的几个定义和指标&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据科学" scheme="https://yupototo.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="机器学习" scheme="https://yupototo.github.io/blog/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>AB测试的例子：访问时长</title>
    <link href="https://yupototo.github.io/blog/2019/06/16/growth_5_ab_test_mean/"/>
    <id>https://yupototo.github.io/blog/2019/06/16/growth_5_ab_test_mean/</id>
    <published>2019-06-16T03:46:52.000Z</published>
    <updated>2020-02-05T00:34:51.184Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇关于AB测试的文章里，我们模拟了一个常见的 ab 测试场景：转化率。这个场景适用于计算百分比数据的场景。</p><p>还有一种场景，数据不是百分比，而是连续数值。例如：</p><ul><li>访问时长</li><li>人均消费</li><li>人均阅读数量</li><li>…</li></ul><p>这个问题场景下，不适合使用 r 的 <code>prop.test</code> 函数。我们可以使用 z-test。</p><p><a id="more"></a></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>我们是一个内容 app，产品部门开发了一个新版本，我们想要测试新版本下的用户访问时长是否会提高。</p><p>我们的原假设和备择假设是：</p><ul><li>H0：新方案的访问时长 &lt;= 老方案的访问时长</li><li>Ha：新方案的访问时长 &gt; 老方案的访问时长</li></ul><p>我们选择单侧检验有2个原因：</p><ul><li>从产品迭代流程考虑，如果没有证据正面新方案比老方案好，我们就不会全面部署新方案，所以我们寻找证据“证伪”老方案</li><li>从统计功效考虑，使用单侧检验能在相同样本下保证更高的统计功效，也就是节约成本了</li></ul><p>因为比较的是两个总体的分布是否有差距，我们使用 two sample t-test。</p><h2 id="参数设定和样本数量估计"><a href="#参数设定和样本数量估计" class="headerlink" title="参数设定和样本数量估计"></a>参数设定和样本数量估计</h2><p>跟之前一样，我们设定 80% 的 power 和 0.05 的 significance level。</p><p>t-test 的样本量估算需要先给定一个 cohen’d。</p><p>d = (m1 - m2 ) /  delta，其中：</p><ul><li>m1 和 m2 分别是两组的均值</li><li>delta 是 common standard deviation</li></ul><p>在开始测试之前，我们只知道 m2 的时长，假设 m2 = 60。理论上我们不可能知道 delta，但我们可以用老方案的样本去估算。一个“便利公式”是 delta = （最大值 - 最小值）/4。假定 delta = 25。</p><p>现在，我们要判断：我们预期新方案的均值有多大的提升呢？假设我们期望新方案会比老方案提高5，也就是从60提高到65。这时我们可以计算 cohen’d = （65 - 60） / 25 = 0.2</p><p>这时我们可以用 R 的 pwr package 估算需要的样本量：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwr.t.test(d = <span class="number">0.2</span>, sig.level = <span class="number">0.05</span>, power = <span class="number">0.8</span>, type = <span class="string">'two.sample'</span>, alternative=<span class="string">'greater'</span>)</span><br></pre></td></tr></tbody></table></figure><p>这个计算告诉我们，每个组需要310个样本。我们着手安排测试。</p><h2 id="检查数据"><a href="#检查数据" class="headerlink" title="检查数据"></a>检查数据</h2><p>一天之后，我们搜集够了650个样本，每组325个样本，我们开始检查数据。</p><p>我们发现两个组的数据如下：</p><ul><li>新方案：平均时长64秒，标准差43秒</li><li>原方案：平均时长60秒，标准差40秒</li></ul><p>看上去新方案更好，但我们能得出新方案更好的结论吗？</p><p>我们可以用 <code>t.test</code> 做检验：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- rnorm(<span class="number">315</span>, <span class="number">64</span>, <span class="number">43</span>)</span><br><span class="line">y &lt;- rnorm(<span class="number">315</span>, <span class="number">60</span> ,<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">t.test(x, y , alternative = <span class="string">'greater'</span>)</span><br></pre></td></tr></tbody></table></figure><p>我在这里模拟了数据，实际上我们可以直接带入两个 list 进 t.test，或者用现成的能输入均值和标准差的函数。</p><p>结果：p值 = 0.21，我们无法拒绝原假设。</p><p>结论：新方案未必比老方案好，我们需要做进一步测试（增加样本量），或保留老方案。</p><p>另一个平行宇宙里，新方案的平均时长还是64秒，标准差是40秒，我们的结论又会变成怎样呢？</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x &lt;- rnorm(<span class="number">315</span>, <span class="number">64</span>, <span class="number">40</span>)</span><br><span class="line">y &lt;- rnorm(<span class="number">315</span>, <span class="number">60</span> ,<span class="number">40</span>)</span><br><span class="line"></span><br><span class="line">t.test(x, y , alternative = <span class="string">'greater'</span>)</span><br></pre></td></tr></tbody></table></figure><p>p值 = 0.04956，小于 0.05。<br>结论：我们拒绝原假设，认为新方案更好。</p><h2 id="AB-测试不只关注均值，还关注分布"><a href="#AB-测试不只关注均值，还关注分布" class="headerlink" title="AB 测试不只关注均值，还关注分布"></a>AB 测试不只关注均值，还关注分布</h2><p>我经常看到不了解统计学的同事用两个均值作为方案优劣的比较依据。上面的例子可以说明：均值差异是不够的。很多时候，我们观察到的均值差异只是随机现象的结果。</p><p>科学的方法还会考虑分布，怎么考虑分布呢？选择一个合适的 test 计算统计显著性。</p><p>不是每个人都懂统计学，但有的人会懂得尊重科学。</p><p>当我们从公司层面追求科学的数据方法论，公司从上到下的决策水平都会提高。</p><h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><ol><li><a href="/blog/2019/06/15/growth_4_ab_test_ctr/" title="AB测试之CTR">AB测试之CTR</a> </li><li><a href="/blog/2019/06/16/growth_5_ab_test_mean/" title="AB测试之均值">AB测试之均值</a> （本文）</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇关于AB测试的文章里，我们模拟了一个常见的 ab 测试场景：转化率。这个场景适用于计算百分比数据的场景。&lt;/p&gt;
&lt;p&gt;还有一种场景，数据不是百分比，而是连续数值。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;访问时长&lt;/li&gt;
&lt;li&gt;人均消费&lt;/li&gt;
&lt;li&gt;人均阅读数量&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个问题场景下，不适合使用 r 的 &lt;code&gt;prop.test&lt;/code&gt; 函数。我们可以使用 z-test。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="增长黑客" scheme="https://yupototo.github.io/blog/categories/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2/"/>
    
    
      <category term="R" scheme="https://yupototo.github.io/blog/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>AB测试的例子：转化率</title>
    <link href="https://yupototo.github.io/blog/2019/06/15/growth_4_ab_test_ctr/"/>
    <id>https://yupototo.github.io/blog/2019/06/15/growth_4_ab_test_ctr/</id>
    <published>2019-06-15T14:26:03.000Z</published>
    <updated>2020-02-05T00:34:51.184Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2019/06/15/growth_4_ab_test_ctr/abtest.jpeg" class="" title="题图"><p>AB 测试是互联网产品优化的科学方法，甚至可能是唯一科学的方法。在这篇文章里，我用 R 语言模拟 AB 测试的流程。</p><p><a id="more"></a></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>假设我们有一个购物 APP，我们重新设计了商品页面，现在我们要回答的问题是：新设计方案对用户的购买率有提高吗？令原方案为 A，新方案为 B。</p><p>我们的原假设和备择假设是：</p><ul><li>原假设：新方案的转化率 &lt;= 老方案的转化率</li><li>备择假设：新方案的转化率 &gt; 老方案的转化率</li></ul><p>因为我们只关心 B 方案是否会比 A 方案好，所以我们使用 one-sided test。原假设是我们想要通过数据去“证伪”的假设，所以原假设是“新方案是没有用处的”，即新方案的转化率低于或等于老方案。</p><p>因为需要判断的是转化率，我们可以使用 <a href="https://www.statisticshowto.datasciencecentral.com/z-test/" target="_blank" rel="noopener">Z-test</a>。</p><h2 id="参数设定和样本数量估计"><a href="#参数设定和样本数量估计" class="headerlink" title="参数设定和样本数量估计"></a>参数设定和样本数量估计</h2><p>在开始搜集数据前，我们需要设定几个参数。</p><ul><li>显著性水平 significance level：我们愿意接受的犯第1类错误的概率是多少？</li><li>统计功效 power：我们希望的统计功效是多少？</li><li>给定当前的转化率（10%），我们希望 B 方案的转化率提高到多少？</li></ul><p>我们依次设定参数如下：</p><ul><li>显著性水平 5%</li><li>统计功效 80%</li><li>转化率提高到 12%</li></ul><p>我们假设样本会平均分配到两个方案中。</p><p>我们使用 <code>pwr</code> packag 来计算需要的样本量</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwr.2p.test(h=ES.h(p1 = <span class="number">0.10</span>, p2 = <span class="number">0.12</span>), </span><br><span class="line">            sig.level = <span class="number">0.05</span>, </span><br><span class="line">            power=<span class="number">0.8</span>, </span><br><span class="line">            alternative = <span class="string">'less'</span>)</span><br></pre></td></tr></tbody></table></figure><p>这个计算告诉我们，每组大概需要 3021 个样本，一共需要大约6100个样本。</p><p>根据 app 流量，我们预计1天的时间可以搜集完所有的数据。于是我们使用现成的工具（或者让工程师开发），并开始测试。</p><h2 id="检查数据"><a href="#检查数据" class="headerlink" title="检查数据"></a>检查数据</h2><p>一天之后，我们搜集够了6100个样本，我们开始检查数据。</p><p>我们发现两个组的数据如下：</p><ul><li>原始方案：3500个样本中，有360个用户发生了转化</li><li>新方案：3500个样本中，有400个用户发生了转化</li></ul><p>看上去是新方案“获胜”了，可是，这个差异在统计学上显著吗？</p><p>我们做一个使用 r 的 <code>prop.test</code> 函数：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prop.test(x = c(<span class="number">360</span>, <span class="number">400</span>), n = c(<span class="number">3500</span>, <span class="number">3500</span>), alternative = <span class="string">'less'</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果：p 值 = 0.067，比预先设定的显著性水平高，我们不能拒绝原假设。</p><p>结论：我们没有理由认为新方案更好。</p><p>想象再另一个平行宇宙，新方案有410个用户发生了转化，我们的 p 值会是多少呢？</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prop.test(x = c(<span class="number">360</span>, <span class="number">410</span>), n = c(<span class="number">3500</span>, <span class="number">3500</span>), alternative = <span class="string">'less'</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果：p 值 = 0.031，我们可以拒绝原假设了。</p><p>结论：新方案的转化率更高。</p><h2 id="为什么是-80-和-5-？"><a href="#为什么是-80-和-5-？" class="headerlink" title="为什么是 80% 和 5%？"></a>为什么是 80% 和 5%？</h2><p>在上面的例子中，我们选择了 80% 的 power 和 5% 的 significane level。为什么呢？Stackoverflow 的数据科学家给了<a href="https://stackoverflow.blog/2017/10/17/power-calculations-p-values-ab-testing-stack-overflow/" target="_blank" rel="noopener">一个非常好的解释</a>。</p><p>如果选择95%的 power 和1%的 significance level，我们的结论准确度会有极大提高，但测试会消耗更多的时间，导致影响商业决策的效率。</p><p>如果我们在刚才的例子追求这样的准确度，我们需要的样本量会翻倍，也就是说，时间成本翻倍。</p><p>如果只看单个测试，翻倍似乎是可以接受的，但一个成熟的互联网产品可能在同时进行几十个优化测试，如果每个测试都追求极端准确性，产品的迭代速度会减少50%。对于“天下武功，唯快不破”的互联网产品，这样的效率损失是绝对不可接受的。</p><h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><ol><li><a href="/blog/2019/06/15/growth_4_ab_test_ctr/" title="AB测试之CTR">AB测试之CTR</a> （本文）</li><li><a href="/blog/2019/06/16/growth_5_ab_test_mean/" title="AB测试之均值">AB测试之均值</a> </li></ol><p>参考：</p><ul><li><a href="https://www.invespcro.com/blog/one-tailed-vs-two-tailed-a-b-testing-everything-you-possibly-need-to-know/" target="_blank" rel="noopener">为什么使用单侧检验</a></li><li><a href="https://cran.r-project.org/web/packages/pwr/vignettes/pwr-vignette.html" target="_blank" rel="noopener">pwr package</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2019/06/15/growth_4_ab_test_ctr/abtest.jpeg&quot; class=&quot;&quot; title=&quot;题图&quot;&gt;
&lt;p&gt;AB 测试是互联网产品优化的科学方法，甚至可能是唯一科学的方法。在这篇文章里，我用 R 语言模拟 AB 测试的流程。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="增长黑客" scheme="https://yupototo.github.io/blog/categories/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2/"/>
    
    
      <category term="R" scheme="https://yupototo.github.io/blog/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>为什么数据团队应该采用 reproducible research</title>
    <link href="https://yupototo.github.io/blog/2019/05/19/ds-4-reproducible-research/"/>
    <id>https://yupototo.github.io/blog/2019/05/19/ds-4-reproducible-research/</id>
    <published>2019-05-19T10:07:01.000Z</published>
    <updated>2020-02-05T00:34:51.176Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2019/05/19/ds-4-reproducible-research/plot.jpg" class="" title="plot"><p>Reproducible research （可重复研究）是学术界的一个潮流。它的意思是，所有研究都应该是可以“复制”的。如果你给我一个研究报告，你不能只给我看结果，你还要给我看到<strong>整个分析过程</strong>，而且我能够在自己的电脑上<strong>复制</strong>出同样的结果。</p><p>经历过几个公司的数据相关业务后，我深深地感觉到：这个规范不只应该用在科学研究里，它也应该用在商业公司的数据团队里。</p><p><a id="more"></a></p><h2 id="传统的分析报告"><a href="#传统的分析报告" class="headerlink" title="传统的分析报告"></a>传统的分析报告</h2><p>为了简化讨论，我们假设数据已经自动搜集并存储在数据仓库中。我们先不讨论研究团队需要自己搜集数据的情况。</p><p>产品经理想了解一个问题：“我们为提升用户留存设计了一个新功能，这个新功能已经上线了1个月，它是否有效果呢？”</p><p>某分析师做了如下操作：</p><ol><li>从数据库提取数据，或从数据后台“下载”数据</li><li>把数据导入 excel 中，开始清洗数据</li><li>做某些假设检验、或模型分析</li><li>把分析结果展示在 excel 中，或另外写一份 word 报告</li></ol><p>在某些公司里，上面的做法已经“足够”了。但是，经历过学术训练的人会有如下问题：</p><ul><li>怎么判断报告作者使用了“正确”的数据源？例子：提取数据的时候日期搞错了。</li><li>怎么判断作者正确清洗了数据？例子：float 变 int。</li><li>怎么判断作者做了需要做的检验？例子：使用 lm 模型却没检查假设是否能被满足。</li><li>怎么判断作者没有为了推销自己的结论而“调整”数据？例子：选择性展示数据。</li><li>……</li></ul><p>上面这些问题可以总结为：<strong>怎么知道分析师没有犯错，无论是有意的错误还是无意的错误</strong>。</p><p>按照传统的方法，“找分析报告的 bug”是个成本很高的活儿，我们几乎只能被动接受分析师给的结果。</p><p>这意味着，我们没有办法系统性地保证数据分析的质量。一个小公司也许可以容忍这样的错误可能，但对严重依赖数据做出决策、并且需要做出大量决策的公司，这不是最优解。</p><h2 id="一个可复制的分析报告"><a href="#一个可复制的分析报告" class="headerlink" title="一个可复制的分析报告"></a>一个可复制的分析报告</h2><p>用可复制的分析报告，之前的研究问题会用下面的方法做。</p><h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><p>要求：数据的获取必须调用 API 或者写 SQL 语句。</p><p>作用：</p><ul><li>当我拿到你的分析，我能复制这段代码，然后调出完全一样的数据</li><li>如果我怀疑数据提取过程有问题，我可以检查代码，判断是不是取数据的代码写错了</li></ul><p>禁止行为：在后台“下载”数据。没人知道你在下载前做了哪些操作。</p><h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>要求：</p><ul><li>清洗数据必须使用代码完成。</li><li>整个数据清洗流程，都用注释清晰的标注。</li></ul><p>作用：其他人能检查整个分析流程，判断是否有某些地方出错。</p><p>禁止行为：在 excel 或其他工具上用<strong>鼠标点选</strong>完成数据清洗。鼠标点选也是不可复制的，不只别人复制不了，分析师自己都很难复制（也许第一次分析时点错了某个地方却不自知）。</p><h3 id="数据分析过程"><a href="#数据分析过程" class="headerlink" title="数据分析过程"></a>数据分析过程</h3><p>要求：</p><ul><li>需要给出使用某个分析模型的原因</li><li>需要说明参数选择的过程</li><li>需要用代码展示完整的分析流程</li></ul><p>作用：</p><ul><li>数据分析包含一定的理论知识，也包含很多相对主观的判断，记录这些判断过程，有助于其他人理解</li><li>方便检查代码正确情况</li></ul><p>禁止行为：不能把数据分析的过程当成“黑箱子”，过程和结果同样重要。</p><h3 id="报告形式"><a href="#报告形式" class="headerlink" title="报告形式"></a>报告形式</h3><p>要求：</p><ul><li>核心分析内容和分析结论在报告主干部分</li><li>从数据获取到分析部分的代码，都在备注部分，或者放在另一个文件里</li></ul><p>作用：</p><ul><li>报告使用者只需要阅读主要部分</li><li>报告<strong>审阅者</strong>可以在备注部分查找可复制研究的过程</li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>目前似乎只有2个选择：</p><ul><li>R：使用 Rmarkdown </li><li>Python：使用 Notebook</li></ul><p>其他工具满足不了“可复制”的需求。</p><h2 id="“可复制研究”的意义"><a href="#“可复制研究”的意义" class="headerlink" title="“可复制研究”的意义"></a>“可复制研究”的意义</h2><p>本质上，“可复制研究” 把数据分析从黑箱子变成了可以审阅的文本，发现分析错误变得相对便宜。</p><p>它让每个人的工作都变得 accountable。每一行代码、每一个分析决策，都被暴露在光天化日之下，东郭先生就无处藏身了。想象一下，写了你名字的报告上竟然有低级的数据清洗错误，这是件多么丢人的事情。</p><p>整体上，“可复制研究”会提高整个数据团队的分析质量。</p><p>我还没有机会在这样的团队工作，但过去的经历让我知道“普通”的数据分析团队可以糟糕到什么程度。看到某些分析师的报告，会让你怀疑他们是否上过统计学入门课，我一直为使用这些报告的决策者捏把汗。</p><p>可复制研究也对团队成员的能力有巨大的要求：</p><ul><li>必须会 R 或 Python，会还不够，还必须能写出 readable code</li><li>表达能力要足够强</li><li>有一定的统计基础，能够做到引用文献</li></ul><p>所谓“可复制研究”，除了是一种理念，还是一套工作流 workflow。就像 readable code 能整体上提高团队的开发质量，reproducible report 能整体上提高团队的数据分析质量。</p><p>使用可复制研究还有一个好处，“知识”变得可以沉淀，不再只是某些分析师脑子里的经验。后来者可以通过前人的报告学习分析思路、复用代码。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2019/05/19/ds-4-reproducible-research/plot.jpg&quot; class=&quot;&quot; title=&quot;plot&quot;&gt;
&lt;p&gt;Reproducible research （可重复研究）是学术界的一个潮流。它的意思是，所有研究都应该是可以“复制”的。如果你给我一个研究报告，你不能只给我看结果，你还要给我看到&lt;strong&gt;整个分析过程&lt;/strong&gt;，而且我能够在自己的电脑上&lt;strong&gt;复制&lt;/strong&gt;出同样的结果。&lt;/p&gt;
&lt;p&gt;经历过几个公司的数据相关业务后，我深深地感觉到：这个规范不只应该用在科学研究里，它也应该用在商业公司的数据团队里。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据科学" scheme="https://yupototo.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>增长黑客系列之3：增长的三驾马车</title>
    <link href="https://yupototo.github.io/blog/2019/05/06/growth_3_three_horses/"/>
    <id>https://yupototo.github.io/blog/2019/05/06/growth_3_three_horses/</id>
    <published>2019-05-06T17:15:47.000Z</published>
    <updated>2020-02-05T00:34:51.184Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2019/05/06/growth_3_three_horses/plot_0.png" class="" title="growth"><p>我在本系列的前两篇文章里讨论了“裂变模型”，在裂变模型里，目标是“总用户数”。其实真正的增长目标，应该是日活跃用户数，也叫 DAU（Daily Active User）。</p><p>驱动产品的 DAU 的要素可以分为3个：</p><ul><li>新增</li><li>留存/流失</li><li>裂变</li></ul><p>成熟的增长团队，应该从上面3个维度着手来实现增长目标。</p><p><a id="more"></a></p><h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><p>这里的新增一般指<strong>团队消耗精力或金钱获取到用户</strong>，也叫 UA （User Acquisition）。</p><p>最典型的 UA 行为是通过广告网络购买用户，这类广告因为可以衡量投入产出比，所以叫“<strong>效果广告</strong>”。比如我们在浏览朋友圈时看到的游戏广告，就是一个效果广告。</p><p>除此之外，品牌广告也是大公司常用的方法，比如抖音冠名赞助某个综艺节目。</p><p>增长黑客能够发挥作用的地方一般是在效果广告部分。</p><p>最典型的问题场景：公司每个月会花掉1000万的效果广告，如何最大化这1000万的效果呢？</p><p>这个时候我们可以这样考虑问题：</p><ul><li>是不是有投放效果比较差的渠道？如果有的话，我们应该在这些渠道减少投入。反之，有没有好的渠道可以增加投入。</li><li>广告的用户画像是否是当前最优解？有没有更便宜但效果更好的广告定位方案？</li><li>广告的素材有没有可能优化？对应的指标是广告点击率。</li><li>广告的落地页有没有可能优化？对应的指标是落地页的转化率。</li><li>…</li></ul><p>上面的每一个问题，有两种优化思路：</p><ol><li>内部对比。比如对比 A 渠道和 B 渠道，对比 A 定位和 B 定位，然后相应修改投入方案。</li><li>外部 benchmark，即对比市面上产品的数据，这需要可靠的信息源。</li></ol><h2 id="留存-流失"><a href="#留存-流失" class="headerlink" title="留存/流失"></a>留存/流失</h2><p>我们在提到留存时，经常指的是“次日留存”、“3人留存“等指标，这些指标描述了用户在第2天和第3天继续使用产品的比例。这只是一个方便衡量产品的指标，对优化产品的帮助并不十分大。</p><p>真正重要的概念，是流失 churn。</p><p>我们关心这些问题：</p><ul><li>有多少比例的用户在1分钟内流失了？</li><li>有多少比例的用户在进入产品的核心体验环节前就流失了？</li><li>更抽象地，用户在各个产品环节的流失率情况怎样？</li><li>流失的用户有哪些共同特征？</li><li>多少用户在第2天没再回来（通过这个数据也可以算出次日留存率）</li><li>……</li></ul><p>一个好产品，最直观的表现是，用户会留下来。所以，较高的留存率、或较低的流失率，是优秀产品的共同特征。</p><p>产品的团队的最核心工作，就是解决留存问题，换个表述就是，解决“产品问题”。我甚至有一个观点：产品问题其实就是留存问题。</p><p>增长黑客可以在这个环节做什么呢？</p><ul><li>研究每个用户转化环节的流失情况，识别最严重的流失环节</li><li>设计 A/B 测试，对转化环节做优化</li><li>研究流失用户或留存用户的共性，用以知道产品优化</li><li>……</li></ul><h2 id="裂变"><a href="#裂变" class="headerlink" title="裂变"></a>裂变</h2><p>裂变，或病毒传播，是增长黑客的第3个工作重心。</p><p>裂变的价值我们在前两篇文章里已经介绍过，一个病毒因子足够高的产品，会给产品带来指数级别的增长。</p><p>增长黑客要做的事情，就是优化三个裂变相关的指标：</p><ul><li>人均邀请数量：越高越好</li><li>感染率：越高越好</li><li>病毒传播的周期：越低越好</li></ul><p>裂变有至少3种实现方式：</p><ul><li>产品本身有天然的裂变属性：比如微信、Facebook、slack 这样有社交属性的产品</li><li>产品有某个裂变功能：如拼多多的“帮我砍价”，或知识付费产品的“分销”</li><li>通过运营活动实现裂变：比如瑞幸咖啡的“邀请用户，各得一杯”</li></ul><p>根据不同的裂变实现方式，增长黑客会跟产品、运营等不同职能的同事合作。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2019/05/06/growth_3_three_horses/plot_0.png&quot; class=&quot;&quot; title=&quot;growth&quot;&gt;
&lt;p&gt;我在本系列的前两篇文章里讨论了“裂变模型”，在裂变模型里，目标是“总用户数”。其实真正的增长目标，应该是日活跃用户数，也叫 DAU（Daily Active User）。&lt;/p&gt;
&lt;p&gt;驱动产品的 DAU 的要素可以分为3个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新增&lt;/li&gt;
&lt;li&gt;留存/流失&lt;/li&gt;
&lt;li&gt;裂变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;成熟的增长团队，应该从上面3个维度着手来实现增长目标。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="增长黑客" scheme="https://yupototo.github.io/blog/categories/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>Shallow Copy 和 Deep Copy</title>
    <link href="https://yupototo.github.io/blog/2019/03/31/coding-13-deepcopy/"/>
    <id>https://yupototo.github.io/blog/2019/03/31/coding-13-deepcopy/</id>
    <published>2019-03-31T20:57:40.000Z</published>
    <updated>2020-02-05T00:34:51.176Z</updated>
    
    <content type="html"><![CDATA[<p>在玩 JavaScript 时碰到了 deep copy 的问题，想起学 python 时也碰到过，遂有此文，互相印证。</p><p>本文依次讨论：</p><ul><li>variable assignment</li><li>shallow copy</li><li>deep copy</li></ul><a id="more"></a><h2 id="Variable-Assignment"><a href="#Variable-Assignment" class="headerlink" title="Variable Assignment"></a>Variable Assignment</h2><p>在理解 shallow copy 和 deep copy 之前，需要先理解：assignment 不是复制，只是映射。</p><p>但对 primitive data type，assignment 会实际上造成“复制”的效果。</p><h3 id="Primitive-Data-Type"><a href="#Primitive-Data-Type" class="headerlink" title="Primitive Data Type"></a>Primitive Data Type</h3><p>Python 有如下基础数据结构：</p><ul><li>integers</li><li>floats</li><li>strings</li><li>booleans</li></ul><p>下面这段代码的打印结果是新手都能猜到的：</p><figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = a</span><br><span class="line">a = <span class="number">3</span> </span><br><span class="line">print(b) <span class="comment"># 1</span></span><br></pre></td></tr></tbody></table></figure><p>把 <code>a</code> 的值赋给 <code>b</code> 之后，再改变 <code>a</code> 的值，并不会改变 <code>b</code> 的值。</p><p>JavaScript 也有 primitive data type：</p><ul><li>Number</li><li>String</li><li>Boolean</li></ul><p>所以下面的代码也会打印出 1。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><p>R 语言也是这样（下面这段代码跟 python 的例子一摸一样 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8">😏</span>)：</p><figure class="highlight r"><figcaption><span>R</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = a</span><br><span class="line">a = <span class="number">3</span> </span><br><span class="line">print(b) <span class="comment"># 1</span></span><br></pre></td></tr></tbody></table></figure><p>初学者经常会有种错误：上面的“模式”在任何情境下都会成立。对 R 是这样，但对 python 和 JS 不是。</p><h3 id="Python-non-primitive-data-type"><a href="#Python-non-primitive-data-type" class="headerlink" title="Python: non-primitive data type"></a>Python: non-primitive data type</h3><p>Python 的 non-primitive data type 包括但不限于 list, dictionary, class 等等。可以认为不是 primitive 的就是 non-primitive。</p><p>以 list 为例，python 会怎么处理 <code>b = a</code> 的变量赋值问题？</p><figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">print(b)</span><br><span class="line"><span class="comment"># [100, 2, 3]</span></span><br></pre></td></tr></tbody></table></figure><p>依次解读代码如下：</p><ul><li>第1行：创建了一个 list 对象<code>[1, 2, 3]</code>，并创建了一个 variable <code>a</code>，然后把 <code>a</code> 映射到 list 对象</li><li>第2行：创建了一个新的 varialbe <code>b</code>，把 <code>b</code> 映射到 <code>a</code> 所映射的对象<code>[1, 2, 3]</code></li><li>第3行：修改了<code>[1, 2, 3]</code>对象的第一个元素为100</li><li>第4行：打印变量<code>b</code>，结果： [100, 2, 3]</li></ul><p><code>b = a</code> 这行代码并没有真的<em>复制</em>一个对象，只是复制了<em>映射</em>。</p><p>下面我们证明 <code>a</code> 和 <code>b</code> 映射到了一个地址：</p><figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = a </span><br><span class="line">print(a <span class="keyword">is</span> b) <span class="comment"># True</span></span><br></pre></td></tr></tbody></table></figure><p><code>is</code> operator 可以检查两个 variable 是否映射到同一个位置。<br>另一个证明方法是用<code>id()</code>返回变量所在的位置。</p><h3 id="JavaScript-non-primitive-data-type"><a href="#JavaScript-non-primitive-data-type" class="headerlink" title="JavaScript: non-primitive data type"></a>JavaScript: non-primitive data type</h3><p>JavaScript 的 non-primitve data 嘛，理解为 Object 就差不多了。毕竟，function、array 等等都是 Object。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"><span class="comment">// [100, 2, 3]</span></span><br></pre></td></tr></tbody></table></figure><p>逻辑几乎跟 python 一样。</p><p>但我没能在 JavaScript 里找到类似 Python 里的 <code>is</code> 和 <code>id()</code>。</p><h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><p>R 不一样。</p><p>不管是 primitive data 还是 non-primitive data，R 都会当作 primitive data 一样复制：</p><figure class="highlight r"><figcaption><span>R</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- c(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">b &lt;- a </span><br><span class="line">a[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line">print(b)</span><br><span class="line"><span class="comment"># 1 2 3</span></span><br></pre></td></tr></tbody></table></figure><p>Python 和 Javascript 的 <code>b</code> 会随着 <code>a</code> 一起变化，R 却不会。是不是可以推测说 <code>b &lt;- a</code> 这行代码会创建新的 object 呢？</p><p>并不是，我们可以查看两个变量指向的位置：</p><figure class="highlight r"><figcaption><span>R</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a &lt;- c(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">b &lt;- a </span><br><span class="line">print(lobstr::obj_addr(a)) <span class="comment">#"0x7fbd42342078"</span></span><br><span class="line">print(lobstr::obj_addr(b)) <span class="comment">#"0x7fbd42342078"</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>] &lt;- <span class="number">100</span></span><br><span class="line">print(lobstr::obj_addr(a)) <span class="comment">#"0x7fbd42342058"</span></span><br><span class="line">print(lobstr::obj_addr(b)) <span class="comment">#"0x7fbd42342078"</span></span><br></pre></td></tr></tbody></table></figure><p>第3行和第4行说明两个<code>a</code>和<code>b</code>映射到了同一个地址。<br>但第8行里，a 映射的地址变了。<code>a[1] = 100</code> 创造出了一个新的对象。</p><p>虽然<code>b &lt;- a</code> 是把 <code>b</code> 映射到了 <code>c(1,2,3)</code>，但如果修改<code>a</code>或<code>b</code>的其中任何一个，都会再创建一个新的对象。</p><p>所以在 R 里我们可以写 <code>df2 &lt;- df1</code> 这样的语句，然后不担心修改 <code>df2</code> 会影响 <code>df1</code>。</p><p><strong>这个例子可以用来说明为什么 R 语言更适合当作统计学初学者的学习工具</strong>，因为它不存在其他语言为了优化性能而设计的种种“反直觉设定”。</p><h2 id="Shallow-Copy"><a href="#Shallow-Copy" class="headerlink" title="Shallow Copy"></a>Shallow Copy</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>刚才已经证明了<code>a = b</code>不能实现 copy，只是复制了一个映射。</p><p>下面研究如何复制。</p><p>如果想复制 <code>list</code>，<code>dictionary</code>或<code>set</code>，可以直接用<code>list()</code>,<code>dict()</code>或<code>set()</code>。</p><figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = list(a)</span><br><span class="line"></span><br><span class="line">print(b <span class="keyword">is</span> a) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">print(b) <span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></tbody></table></figure><p>另外一个方法，是用 <code>copy</code> library 里的 <code>copy()</code> 函数。</p><figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = copy.copy(a)</span><br><span class="line">print(a <span class="keyword">is</span> b) <span class="comment"># False</span></span><br></pre></td></tr></tbody></table></figure><p>如果是其他 object，比如 class，没有类似<code>list()</code>这样的函数，就可以直接用<code>copy()</code>实现复制。</p><figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.gender = gender</span><br><span class="line">    </span><br><span class="line">tom = Person(<span class="string">'Tom'</span>, <span class="string">'Female'</span>)</span><br><span class="line"></span><br><span class="line">tom_2 = tom</span><br><span class="line marked">print(tom <span class="keyword">is</span> tom_2) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">tom_3 = copy.copy(tom)</span><br><span class="line marked">print(tom <span class="keyword">is</span> tom_3) <span class="comment"># False</span></span><br></pre></td></tr></tbody></table></figure><p>第12行：class 的 instance 在使用<code>a = b</code>时也只会复制映射，不会复制一个新的 instance。<br>第15行：用 <code>copy()</code> 可以复制一个新的 instance。</p><p><strong>但这还没完</strong>，真正的坑点在这里：上面的 copy 方法都是 shallow copy，shallow copy 只会<strong>复制对象的一层</strong>，对象内嵌套的对象都只会复制映射。</p><p>看下面的代码：</p><figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line">b = copy.copy(a)  <span class="comment"># 等价于 b = list(a) </span></span><br><span class="line">print(a <span class="keyword">is</span> b)   <span class="comment"># False</span></span><br><span class="line">print(a[<span class="number">0</span>] <span class="keyword">is</span> b[<span class="number">0</span>])   <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">print(b)  <span class="comment"># [[100, 2, 3], [4, 5, 6], [7, 8, 9]]</span></span><br></pre></td></tr></tbody></table></figure><p>这段代码里有趣的地方：</p><ul><li>先创建了一个元素为 list 的 list，映射到<code>a</code></li><li>然后复制出 <code>b</code></li><li>第5行：证明 <code>a</code> 和 <code>b</code> 没有映射到同一个位置</li><li>第6行：证明 <code>a</code> 和 <code>b</code> 的元素映射到了同一个位置</li><li>第8和第9行：更直观地证明上面的观点</li></ul><p>那么问题来了，如何让 <code>b</code> 从外到内地复制 <code>a</code>，而不只是复制“表面一层”呢？这就是 deep copy 的工作。</p><p>在介绍怎么用 python 做 deep copy 前，先看看 JavaScript 的 shallow copy。</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>JavaScript 提供了两种 shallow copy 的方式：</p><ul><li><code>Object.assign()</code></li><li>Spread Operator: <code>...</code></li></ul><p>先看 <code>Object.assign()</code></p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line marked"><span class="keyword">var</span> b = <span class="built_in">Object</span>.assign([], a)</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></tbody></table></figure><p>再看 Spread Operator：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line marked"><span class="keyword">var</span> b = [...a]</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></tbody></table></figure><p>对于 shallow copy，JS 也有跟 Python 一样的设定：只会复制第1层，如果 Object 内包含 Object，就只会复制映射。</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.assign([], a)</span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [ [ 100, 2, 3 ], [ 4, 5, 6 ] ]</span></span><br></pre></td></tr></tbody></table></figure><p>下面进入 Deep Copy 部分。</p><h2 id="Deep-Copy"><a href="#Deep-Copy" class="headerlink" title="Deep Copy"></a>Deep Copy</h2><p>Deep copy 能够“完整复制”一个对象。</p><h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h3><p>Python 可以使用 copy 包里的 <code>deepcopy()</code> 函数：</p><figure class="highlight python"><figcaption><span>Python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line marked">b = copy.deepcopy(a)  </span><br><span class="line">print(a <span class="keyword">is</span> b)   <span class="comment"># False</span></span><br><span class="line">print(a[<span class="number">0</span>] <span class="keyword">is</span> b[<span class="number">0</span>])   <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">print(b)  <span class="comment"># [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span></span><br></pre></td></tr></tbody></table></figure><p>上面的代码实现了 deep copy。</p><h3 id="JavaScript-1"><a href="#JavaScript-1" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>JavaScript 没有 built-in module 里有类似 python 的 <code>deepcopy</code> 这样的函数，但主流第三方 module 里都提供了这个函数，我们不需要重复造轮子。</p><p>如果 Object 的 value 只有 primitive data，我们可以用一个简单的方法：<code>JSON.parse(JSON.stringify(object))</code>:</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line marked"><span class="keyword">var</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// [ [ 1, 2, 3 ], [ 4, 5, 6 ] ]</span></span><br></pre></td></tr></tbody></table></figure><p>注意：如果 value 值是日期、regex 等等非 primitive data 的对象，这个方法不能使用。</p><p>参考下面的例子：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = {</span><br><span class="line marked">  name: <span class="string">'YuYu'</span>, </span><br><span class="line">  func: <span class="keyword">new</span> <span class="built_in">Function</span>()</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> personCopy = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(person))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// { name: 'YuYu', func: [Function: anonymous] }</span></span><br><span class="line"><span class="built_in">console</span>.log(personCopy) <span class="comment">// { name: 'YuYu' }</span></span><br></pre></td></tr></tbody></table></figure><p>复制之后，<code>func</code> 这个 key-value 丢失了。</p><p>最保险的方法还是使用第三方工具，比如 lodash：</p><figure class="highlight js"><figcaption><span>JavaScript</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cloneDeep = <span class="built_in">require</span>(<span class="string">'lodash/cloneDeep'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = {</span><br><span class="line">  name: <span class="string">'YuYu'</span>, </span><br><span class="line">  book: {</span><br><span class="line">    title: <span class="string">'JS is cool'</span>,</span><br><span class="line">    pages: <span class="number">300</span>,</span><br><span class="line">  },</span><br><span class="line">  func: <span class="keyword">new</span> <span class="built_in">Function</span>()</span><br><span class="line">}</span><br><span class="line marked"><span class="keyword">var</span> personCopy = cloneDeep(person)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person) </span><br><span class="line"><span class="built_in">console</span>.log(personCopy) </span><br></pre></td></tr></tbody></table></figure><p>上面这个例子里，嵌套的 object 以及 non-primitive 值也能保留。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://realpython.com/copying-python-objects/" target="_blank" rel="noopener">Shallow vs Deep Copying of Python Objects</a></li><li><a href="https://flaviocopes.com/how-to-clone-javascript-object/" target="_blank" rel="noopener">How to deep clone a JavaScript object</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在玩 JavaScript 时碰到了 deep copy 的问题，想起学 python 时也碰到过，遂有此文，互相印证。&lt;/p&gt;
&lt;p&gt;本文依次讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;variable assignment&lt;/li&gt;
&lt;li&gt;shallow copy&lt;/li&gt;
&lt;li&gt;deep copy&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://yupototo.github.io/blog/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="https://yupototo.github.io/blog/tags/JavaScript/"/>
    
      <category term="Python" scheme="https://yupototo.github.io/blog/tags/Python/"/>
    
      <category term="R" scheme="https://yupototo.github.io/blog/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>IIFE</title>
    <link href="https://yupototo.github.io/blog/2019/03/15/coding-12-iife/"/>
    <id>https://yupototo.github.io/blog/2019/03/15/coding-12-iife/</id>
    <published>2019-03-15T10:58:56.000Z</published>
    <updated>2020-02-05T00:34:51.176Z</updated>
    
    <content type="html"><![CDATA[<p>IIFE (Immediate Invoked Function) 是 JavaScript 里一种快捷使用函数的方式。</p><p>这里做一个介绍。</p><p><a id="more"></a></p><h2 id="创建函数的几种方法"><a href="#创建函数的几种方法" class="headerlink" title="创建函数的几种方法"></a>创建函数的几种方法</h2><p>JavaScript 提供了两种创建函数的方法：</p><ul><li>function declaration</li><li>function expression</li></ul><h3 id="function-declaration"><a href="#function-declaration" class="headerlink" title="function declaration"></a>function declaration</h3><p>function declaration 创建函数的方法有点像 python 的 <code>def</code>，比较容易理解。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">one</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">one()</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><p>Python 可以用类似的方式创建函数：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">one()</span><br><span class="line">// <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h3 id="function-expression"><a href="#function-expression" class="headerlink" title="function expression"></a>function expression</h3><p>另一种创建函数的方式是 function expression：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">one()</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><p>也可以用 arrow function：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">one()</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><p>这种方法更像 R 语言：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">one &lt;- <span class="keyword">function</span>() {</span><br><span class="line">  print(<span class="number">1</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">one()</span><br><span class="line">// <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p>function declaration 和 function expression 还有另一个区别： hoisting。</p><p>如果 function 用 declaration 的方式创建，我们可以在 function 创建前就调用：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hoist()  <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoist</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但 function expression 不允许这样用：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hoist() <span class="comment">// ReferenceError: Cannot access 'hoist' before initialization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hoist = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h2><p>创建函数是为了能够重复利用，但有的时候，我们不需要重复利用，有时一个函数只需要使用一次。</p><p>这个时候我们可以使用 IIFE， Immediate Invoked Function：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">})()</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><p>这时会直接打印出 1。</p><p>第一个 () 里其实是函数的定义，这里也可以使用箭头函数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">)()</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><p>效果是一样的。</p><p>IIFE 是个有意思的概念，我自己还没碰到需要用 IIFE 的时候（或者是碰到了而我没想到），但在看别人代码的时候会碰到，所以在这里记录一下。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IIFE (Immediate Invoked Function) 是 JavaScript 里一种快捷使用函数的方式。&lt;/p&gt;
&lt;p&gt;这里做一个介绍。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://yupototo.github.io/blog/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="https://yupototo.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>增长黑客系列之2：升级版裂变模型</title>
    <link href="https://yupototo.github.io/blog/2019/03/05/growth_2_model_2/"/>
    <id>https://yupototo.github.io/blog/2019/03/05/growth_2_model_2/</id>
    <published>2019-03-05T09:39:14.000Z</published>
    <updated>2020-02-05T00:34:51.184Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2019/03/05/growth_2_model_2/zombie.jpg" class="" title="僵尸"> 介绍了一个纯裂变模型。我们在本篇加入一个新的变量：裂变周期的时长。直觉告诉我们，裂变周期越短，裂变强度越大。但是，这个强度究竟有多大呢？我让这个问题再精确一些，假设有2个产品，A 产品裂变周期只有1天，B 产品裂变周期是2天，30天后，A 产品的用户数会是 B 产品的几倍？<a id="more"></a><h2 id="丧尸的世界为什么那么刺激"><a href="#丧尸的世界为什么那么刺激" class="headerlink" title="丧尸的世界为什么那么刺激"></a>丧尸的世界为什么那么刺激</h2><p>在去看枯燥的公式和代码之前，我先谈谈有趣的丧尸。丧尸题材在现代社会的风靡是个有意思的现象，我把这个想象叫做“双重逃避”。</p><p>第一重逃避是现代人对充满压力的生活的逃避：通过丧尸电影和丧尸游戏，人们沉浸到了一个紧张刺激的世界，让我们忘掉日常生活的种种压力。第二重逃避：我们在丧尸游戏和电影里逃避着无处不在的丧尸。所以，为了逃避现实，我们选择在虚拟的世界里逃避丧尸。</p><p>为什么逃避丧尸是个那么刺激的事情呢？一种解答是：丧尸很致命。但这个答案不够完美，因为致命的东西很多，比如哥斯拉和异形就比丧尸致命得多。如果致命程度是某个题材火爆的原因，我们应该看到哥斯拉和异形更流行。</p><p>我觉得真正的原因是：丧尸有非常强的病毒传播能力。从第1只丧尸诞生到丧尸围城，用不了几天时间（额外提问：这现实吗？）。</p><p>我们在上一篇系列文章里提到了两个核心变量：</p><ul><li>邀请数量</li><li>感染率</li></ul><p>在丧尸的世界里， 丧尸是非常热情的“种子用户”，它见到人就会发出“邀请”，而且感染率100%。所以丧尸有非常高的<strong>病毒因子</strong>。</p><p>但这个指标还不足以描述丧尸的可怕（或魅力）。丧尸电影里最刺激的情节是，男主角的朋友/爱人被咬了之后，1分钟内就会变成丧尸，然后会立刻开始进攻其他人类。换句话说，僵尸把人变成僵尸的周期非常快。在增长模型里，这个参数叫做“<strong>周期时长</strong>”。僵尸有非常短的周期时长。</p><p>如果被僵尸咬了之后需要48个小时才会变异，僵尸电影就没那么有意思了。</p><h2 id="新的模型"><a href="#新的模型" class="headerlink" title="新的模型"></a>新的模型</h2><p>在新的模型里，我们开始考虑一个周期的时间长度，这个变量叫做简称为 ct。</p><p>所有变量如下：</p><ul><li>初始用户：custs(0)</li><li>周期时长：ct</li><li>人均邀请数 i</li><li>感染率 Conv%</li></ul><p>我们想要计算的指标是：第 t 天时，总的用户数是多少，这个变量是 custs(t)。</p><p>我们仍然维持上一篇文章的核心假设：只有新用户会发出邀请。</p><p>我从风险投资人 David Skok 的博客里找到了计算第 t 天总用户量的公式：</p><p><img src="formula.png" alt="公式"></p><p>公式里的 K = conv% * i</p><p>根据上面的公式，我们的 R 代码如下：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get_cust_t &lt;- <span class="keyword">function</span>(cust_0, i, conv, ct, t) {</span><br><span class="line">  k_coef &lt;- i * conv</span><br><span class="line">  cust_t &lt;- cust_0 * ( k_coef ^ (t/ct + <span class="number">1</span>) - <span class="number">1</span>) / ( k_coef - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span>(cust_t)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="数据例子"><a href="#数据例子" class="headerlink" title="数据例子"></a>数据例子</h2><p>当 ct = 1 时，一天就能完成一次裂变。我们想研究的问题是，当裂变时长分别等于 1、2、3、4 时，30天后的总用户数会有什么样的差距。</p><p>结果如下图：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:center">第0天</th><th style="text-align:center">第1天</th><th style="text-align:center">第10天</th><th style="text-align:center">第20天</th><th style="text-align:center">第30天</th></tr></thead><tbody><tr><td style="text-align:left">ct = 1</td><td style="text-align:center">10</td><td style="text-align:center">25</td><td style="text-align:center">1710</td><td style="text-align:center">99738</td><td style="text-align:center">5752512</td></tr><tr><td style="text-align:left">ct = 2</td><td style="text-align:center">10</td><td style="text-align:center">17</td><td style="text-align:center">208</td><td style="text-align:center">1710</td><td style="text-align:center">13117</td></tr><tr><td style="text-align:left">ct = 3</td><td style="text-align:center">10</td><td style="text-align:center">14</td><td style="text-align:center">96</td><td style="text-align:center">428</td><td style="text-align:center">1710</td></tr><tr><td style="text-align:left">ct = 4</td><td style="text-align:center">10</td><td style="text-align:center">13</td><td style="text-align:center">63</td><td style="text-align:center">208</td><td style="text-align:center">608</td></tr></tbody></table></div><p>天壤之别。</p><p>如果数字还不够直观的话，我们就看看图片。</p><p>我先画出了 ct = 2、3、4 时的图片：</p><p><img src="plot_0.png" alt="第1张折线图"></p><p>看上去 ct = 2 时的效果是远远强于 ct = 3 和 ct = 4 的。</p><p>如果对比 ct = 1 和 ct = 2 呢？</p><p><img src="plot_1.png" alt="第2张折线图"></p><p>真正意义上的天壤之别。在 ct = 1 的产品面前，排名老二的产品跟不存在一样。</p><p>我们在最开始提了一个问题：假设有2个产品，A 产品裂变周期只有1天，B 产品裂变周期是2天，30天后，A 产品的用户数会是 B 产品的几倍？答案：<strong>438倍</strong>！</p><p>这张图给了我两个想法：</p><ol><li>天下武功，唯快不破。在有病毒裂变能力的领域尤其如此。</li><li>有的时候你以为自己比后面的对手要厉害一截，但在第一名看来，你们都是一样渺小。</li></ol><h2 id="这个模型的实践意义"><a href="#这个模型的实践意义" class="headerlink" title="这个模型的实践意义"></a>这个模型的实践意义</h2><p>上一个模型告诉我们要提高<strong>用户邀请数</strong>， 要提高<strong>邀请成功率</strong>。</p><p>这个模型告诉我们：要缩短<strong>病毒传播的周期时长</strong>。这个话题会在接下来的系列中讨论。</p><p>结束这篇文章前，我们再想想下丧尸题材的常见现象：从第1只僵尸诞生到丧尸围城，只需要几天时间。现在你还会怀疑这个设定是否现实吗？</p><h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><ol><li><a href="/blog/2019/02/05/growth_1_base_model/" title="基础裂变模型">基础裂变模型</a> </li><li><a href="/blog/2019/03/05/growth_2_model_2/" title="升级版裂变模型">升级版裂变模型</a> （本文）</li></ol><p>参考：</p><ul><li><a href="https://www.forentrepreneurs.com/lessons-learnt-viral-marketing/" target="_blank" rel="noopener">David Skok: Lessons Learned – Viral Marketing</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2019/03/05/growth_2_model_2/zombie.jpg&quot; class=&quot;&quot; title=&quot;僵尸&quot;&gt;
 介绍了一个纯裂变模型。

我们在本篇加入一个新的变量：裂变周期的时长。直觉告诉我们，裂变周期越短，裂变强度越大。但是，这个强度究竟有多大呢？

我让这个问题再精确一些，假设有2个产品，A 产品裂变周期只有1天，B 产品裂变周期是2天，30天后，A 产品的用户数会是 B 产品的几倍？


    
    </summary>
    
    
      <category term="增长黑客" scheme="https://yupototo.github.io/blog/categories/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>Promise 系列之4：async/await</title>
    <link href="https://yupototo.github.io/blog/2019/02/15/coding-11-promise-4-async/"/>
    <id>https://yupototo.github.io/blog/2019/02/15/coding-11-promise-4-async/</id>
    <published>2019-02-15T10:58:56.000Z</published>
    <updated>2020-02-05T00:34:51.176Z</updated>
    
    <content type="html"><![CDATA[<p>async/await 是 EMCA2017 的新功能，是 Promise 的语法糖，让我们写 async/await 代码更方便。</p><a id="more"></a><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>普通函数是这样的：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> normalFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'normal function'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(normalFunc())</span><br><span class="line"><span class="comment">// normal function</span></span><br></pre></td></tr></tbody></table></figure><p>Async 函数是这样的：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncFunc = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async function'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>async</code> 会把一个函数返回的结果变成 promise。</p><p>继续刚才的代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(asyncFunc())</span><br><span class="line"><span class="comment">// Promise { 'async function' }</span></span><br><span class="line"></span><br><span class="line">asyncFunc()</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="comment">// async function</span></span><br></pre></td></tr></tbody></table></figure><p>直接打印 asyncFunc() 的返回结果，会提示这是个 Promise。</p><p>我们可以用 <code>.then()</code> 获取 promise 的 resolve 值，得到函数返回的内容<code>async function</code>。</p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><h3 id="await-用法"><a href="#await-用法" class="headerlink" title="await 用法"></a>await 用法</h3><p>刚才的 async 代码用处不大，async 的真正价值是：我们可以在 async 函数里使用 <code>await</code> keyword。</p><p><code>await</code> 可以用在 promise 函数之前，实现如下效果：</p><ul><li>暂停代码，直到 promise 从 pending 变成 settled</li><li>返回 promise 返回的值</li></ul><p>先看一个不是用 async/await 的函数：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> normalFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="string">'this is value'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br><span class="line">}</span><br><span class="line">normalFunc()</span><br><span class="line"><span class="comment">// this is value</span></span><br></pre></td></tr></tbody></table></figure><p>上面的函数可以用 async/await 改写如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncFunc = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> value = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'this is value'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">}</span><br><span class="line">asyncFunc()</span><br><span class="line"><span class="comment">// this is value</span></span><br></pre></td></tr></tbody></table></figure><p>后者的可读性显然更强。</p><h3 id="await-暂停代码？"><a href="#await-暂停代码？" class="headerlink" title="await 暂停代码？"></a>await 暂停代码？</h3><p>怎么理解 await 能够暂停代码呢？</p><p>先看一个使用 promise 的代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> normalFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="string">'this is resolve value'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this line is after promise'</span>)</span><br><span class="line">}</span><br><span class="line">normalFunc()</span><br><span class="line"></span><br><span class="line"><span class="comment">//this line is after promise</span></span><br><span class="line"><span class="comment">//this is resolve value</span></span><br></pre></td></tr></tbody></table></figure><p>上面的<code>normalFunc()</code>会先执行第4行代码，然后再打印 promise 的值。这是异步运行的结果，有的时候这是我们希望看到的，尤其是后面的代码不需要依赖 promise 返回的值的时候。</p><p>但另外一些时候，后面的代码会依赖 promise 的结果，这时上面的代码可以改成：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> normalFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="string">'this is resolve value'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> {</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'this line is after promise'</span>)</span><br><span class="line">    })</span><br><span class="line">  </span><br><span class="line">}</span><br><span class="line">normalFunc()</span><br><span class="line"></span><br><span class="line"><span class="comment">//this is resolve value</span></span><br><span class="line"><span class="comment">//this line is after promise</span></span><br></pre></td></tr></tbody></table></figure><p>有了 async/await 后，上面的代码可以变得更有可读性：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncFunc = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">const</span> value = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'this is resolve value'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this line is after promise'</span>)</span><br><span class="line">}</span><br><span class="line">asyncFunc()</span><br><span class="line"></span><br><span class="line"><span class="comment">//this is resolve value</span></span><br><span class="line"><span class="comment">//this line is after promise</span></span><br></pre></td></tr></tbody></table></figure><h3 id="await-如何改变-promise-的链式操作"><a href="#await-如何改变-promise-的链式操作" class="headerlink" title="await 如何改变 promise 的链式操作"></a>await 如何改变 promise 的链式操作</h3><p>Promise 可以利用 then 实现链式操作：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addNum = <span class="function"><span class="params">num</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  resolve(num + <span class="number">1</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">a</span> =&gt;</span> addNum(a))</span><br><span class="line">  .then(<span class="function"><span class="params">b</span> =&gt;</span> addNum(b))</span><br><span class="line">  .then(<span class="function"><span class="params">c</span> =&gt;</span> addNum(c))</span><br><span class="line">  .then(<span class="function"><span class="params">d</span> =&gt;</span> <span class="built_in">console</span>.log(d))</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></tbody></table></figure><p>第1个 promise 返回了1，然后依次在之后的 promise 加上1，最后得到4。</p><p>下面是 async/await 的写法：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addNum = <span class="function"><span class="params">num</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  resolve(num + <span class="number">1</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asyncFunc = <span class="keyword">async</span> () =&gt; {</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">await</span> addNum(a)</span><br><span class="line">  <span class="keyword">const</span> c = <span class="keyword">await</span> addNum(b)</span><br><span class="line">  <span class="keyword">const</span> d = <span class="keyword">await</span> addNum(c)</span><br><span class="line">  <span class="built_in">console</span>.log(d)</span><br><span class="line">}</span><br><span class="line">asyncFunc()</span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></tbody></table></figure><p>同样是依赖于前一个 promise 返回值的操作，后一个写法要清晰得多。</p><h2 id="如何-catch-reject"><a href="#如何-catch-reject" class="headerlink" title="如何 catch reject"></a>如何 catch reject</h2><p>Promise 可以用链上 catch 来抓取 reject 信息，如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'reject reason'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err)</span><br><span class="line"><span class="comment">// Error: reject reason</span></span><br></pre></td></tr></tbody></table></figure><p>await 可以怎么 catch reject 的原因呢？也是用 catch，但更像正常 JavaScript 的 catch error。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; {</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'reject reason'</span>)</span><br><span class="line">  } <span class="keyword">catch</span>(err) {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Err: '</span> + err)</span><br><span class="line">  }</span><br><span class="line">})()</span><br><span class="line"><span class="comment">// Err: reject reason</span></span><br></pre></td></tr></tbody></table></figure><p>上面这段代码更像正常的 JavaScript 的 try catch。</p><h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><p>Promise 系列：</p><ol><li><a href="/blog/2019/01/15/coding-8-js-promise-1-why/" title="为什么需要 promise">为什么需要 promise</a> </li><li><a href="/blog/2019/01/20/coding-9-promise-2-what/" title="什么是 promise">什么是 promise</a> </li><li><a href="/blog/2019/01/30/coding-10-promise-3-more/" title="promise 进阶">promise 进阶</a> </li><li><a href="/blog/2019/02/15/coding-11-promise-4-async/" title="async/await">async/await</a> (本篇)</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;async/await 是 EMCA2017 的新功能，是 Promise 的语法糖，让我们写 async/await 代码更方便。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://yupototo.github.io/blog/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="https://yupototo.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ggplot系列之10：boxplot</title>
    <link href="https://yupototo.github.io/blog/2019/02/15/ggplot_10_boxplot/"/>
    <id>https://yupototo.github.io/blog/2019/02/15/ggplot_10_boxplot/</id>
    <published>2019-02-15T01:07:33.000Z</published>
    <updated>2020-02-05T00:34:51.176Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2019/02/15/ggplot_10_boxplot/plot_2.png" class="" title="各大俱乐部的工资结构"><p>数据可视化的常见场景之一是：展示一个 categorical variable 和一个 numeric variable 的关系。</p><p>这时我们可以使用 boxplot。</p><p>这里使用了 <a href="https://www.kaggle.com/karangadiya/fifa19/data" target="_blank" rel="noopener">FIFA 的球员数据集</a>。</p><a id="more"></a><h2 id="大球队的工资状况如何？"><a href="#大球队的工资状况如何？" class="headerlink" title="大球队的工资状况如何？"></a>大球队的工资状况如何？</h2><p>我们想展示几个大球队的工资状况，涉及两个变量：</p><ul><li>球队：categorical variable</li><li>每个球员的工资：numerical variable</li></ul><p>我们先提取几个大俱乐部的数据，并把周薪修改为万欧：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要的俱乐部</span></span><br><span class="line">clubs &lt;- c(<span class="string">'Real Madrid'</span>, <span class="string">'FC Barcelona'</span>, </span><br><span class="line">           <span class="string">'Manchester United'</span>, <span class="string">'Manchester City'</span>, <span class="string">'Liverpool'</span>, <span class="string">'Chelsea'</span>, <span class="string">'Arsenal'</span>,</span><br><span class="line">           <span class="string">'Borussia Dortmund'</span>, <span class="string">'FC Bayern München'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wage_to_number &lt;- <span class="keyword">function</span>(wage) {</span><br><span class="line">  <span class="comment"># 把周薪转换成万欧</span></span><br><span class="line">  number_in_string &lt;- str_extract(wage, <span class="string">'\\d+'</span>)</span><br><span class="line">  number_in_1000 &lt;- as.numeric(number_in_string)</span><br><span class="line">  number_in_1000 * <span class="number">1000</span> / <span class="number">10000</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">sub_dat &lt;- dat %&gt;%</span><br><span class="line">  filter(Club %<span class="keyword">in</span>% clubs) %&gt;%</span><br><span class="line">  mutate(Wage = wage_to_number(Wage))</span><br></pre></td></tr></tbody></table></figure><p>下面制作 boxplot：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ggplot(sub_dat) +</span><br><span class="line">  geom_boxplot(aes(x = Club, y = Wage)) +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>,</span><br><span class="line">       y = <span class="string">'工资（周薪：万欧）'</span>,</span><br><span class="line">       title = <span class="string">'各大俱乐部的工资结构'</span>) +</span><br><span class="line">  coord_flip() </span><br></pre></td></tr></tbody></table></figure><p>结果如图：</p><img src="/blog/2019/02/15/ggplot_10_boxplot/plot_0.png" class="" title="各大俱乐部的工资结构"><p>从这个图可以看到：</p><ul><li>西超双雄、曼城和尤文图斯的工资中位数最高</li><li>多特蒙德的工资水平最低，确实是这几个队里经济实力最低的</li><li>利物浦、切尔西、阿森纳、拜仁在维持相对均衡的收入的同时，还允许超级巨星有高收入</li><li>巴塞罗那有一个收入最高的家伙，不用想，当然是梅西啦</li></ul><h2 id="我们想标注出几个离群值"><a href="#我们想标注出几个离群值" class="headerlink" title="我们想标注出几个离群值"></a>我们想标注出几个离群值</h2><p>有几个球队有收入远远高于队友的球员，我们想看看他们究竟是谁（虽然猜也能猜到了 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8">😊</span>)，并把他们的名字标注在图片上。</p><p>先清理数据：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">outliner_club &lt;- c(<span class="string">'FC Barcelona'</span>, <span class="string">'Liverpool'</span>, <span class="string">'Chelsea'</span>, <span class="string">'Arsenal'</span>, <span class="string">'FC Bayern München'</span>)</span><br><span class="line">outliner_player &lt;- sub_dat %&gt;% </span><br><span class="line">  filter(Club %<span class="keyword">in</span>% outliner_club) %&gt;%</span><br><span class="line">  group_by(Club) %&gt;%</span><br><span class="line">  filter(Wage == max(Wage))</span><br></pre></td></tr></tbody></table></figure><p>我们提取出了几个有离群值的俱乐部收入最高的球员。</p><p>然后，我们在图片上添加 label：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ggplot(sub_dat, aes(x = Club, y = Wage)) +</span><br><span class="line">  geom_boxplot() +</span><br><span class="line">  geom_label(data = outliner_player,</span><br><span class="line">             aes(label = Name),</span><br><span class="line">             nudge_x = <span class="number">0.25</span>,</span><br><span class="line">             nudge_y = <span class="number">0.25</span>, </span><br><span class="line">             label.size = <span class="number">0.1</span>) +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>,</span><br><span class="line">       y = <span class="string">'工资（周薪：万欧）'</span>,</span><br><span class="line">       title = <span class="string">'各大俱乐部的工资结构'</span>) +</span><br><span class="line">  coord_flip() </span><br></pre></td></tr></tbody></table></figure><p>结果如下：<br><img src="/blog/2019/02/15/ggplot_10_boxplot/plot_1.png" class="" title="各大俱乐部的工资结构+离群值"></p><p>各个全队的异常高收入球员如下：</p><ul><li>巴萨：梅西</li><li>切尔西：C罗</li><li>拜仁：J罗</li><li>利物浦：萨拉赫</li><li>切尔西：阿扎尔</li><li>阿森纳：奥巴梅杨</li></ul><p>有意思的是，利物浦的最高薪球员萨拉赫，薪资水平在皇马也只属于前1/4，在巴萨甚至不到梅西的一半。可见西超双雄的购买力了。</p><h2 id="给曼联上色"><a href="#给曼联上色" class="headerlink" title="给曼联上色"></a>给曼联上色</h2><p>作为一个曼联球迷，我想给曼联的 box 涂上曼联红色，然后给死敌利物浦涂上他们死敌埃弗顿的蓝色 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png?v8">😃</span>，我该怎么办呢？</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sub_dat &lt;- sub_dat %&gt;%</span><br><span class="line">  mutate(isManU = case_when(</span><br><span class="line">    Club == <span class="string">'Manchester United'</span> ~ <span class="string">'ManU'</span>,</span><br><span class="line">    Club == <span class="string">'Liverpool'</span> ~ <span class="string">'Liv'</span>,</span><br><span class="line">    <span class="literal">TRUE</span> ~ <span class="string">'rest'</span></span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">ggplot(sub_dat) +</span><br><span class="line">  geom_boxplot(aes(x = Club, y = Wage, fill=isManU)) +</span><br><span class="line">  scale_fill_manual(breaks = c(<span class="string">"Liv"</span>, <span class="string">"ManU"</span>, <span class="string">"rest"</span>), </span><br><span class="line">                    values=c(<span class="string">"#003399"</span>, <span class="string">"#DA291C"</span>, <span class="string">"white"</span>)) +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>,</span><br><span class="line">       y = <span class="string">'工资（周薪：万欧）'</span>,</span><br><span class="line">       title = <span class="string">'各大俱乐部的工资结构'</span>) +</span><br><span class="line">  coord_flip()  +</span><br><span class="line">  theme(legend.position = <span class="string">"none"</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果如下图：<br><img src="/blog/2019/02/15/ggplot_10_boxplot/plot_2.png" class="" title="各大俱乐部的工资结构"></p><p>希望利物浦球迷看到了不要打我 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f4a3.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a3.png?v8">💣</span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2019/02/15/ggplot_10_boxplot/plot_2.png&quot; class=&quot;&quot; title=&quot;各大俱乐部的工资结构&quot;&gt;
&lt;p&gt;数据可视化的常见场景之一是：展示一个 categorical variable 和一个 numeric variable 的关系。&lt;/p&gt;
&lt;p&gt;这时我们可以使用 boxplot。&lt;/p&gt;
&lt;p&gt;这里使用了 &lt;a href=&quot;https://www.kaggle.com/karangadiya/fifa19/data&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FIFA 的球员数据集&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="https://yupototo.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://yupototo.github.io/blog/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>增长黑客系列之1：基础裂变模型</title>
    <link href="https://yupototo.github.io/blog/2019/02/05/growth_1_base_model/"/>
    <id>https://yupototo.github.io/blog/2019/02/05/growth_1_base_model/</id>
    <published>2019-02-05T13:15:49.000Z</published>
    <updated>2020-02-05T00:34:51.184Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2019/02/05/growth_1_base_model/plot_0.png" class="" title="病毒系数的影响"><p>增长黑客是近几年非常火爆的概念，指利用各种技术手段和产品手段帮助产品实现快速增长的人。其实在这个概念出现之前，增长就已经是一个技术和产品的混合领域了。</p><p>按照增长黑客的理念，用户增长的起点不是从市场营销阶段开始，而是从产品的设计阶段就做了规划。比如，当今的所有产品都会考虑用户的自发推广。</p><p>这个系列文章会建立一套增长黑客的数学模型，帮助我们更好地理解增长。</p><p>我们先从最简单的世界开始。</p><p><strong>在这个“创世篇”里，所有产品都只能在发布时做一次市场营销，之后的新用户都必须来自老用户的推荐。</strong> 这个世界的增长故事会长成什么样呢？</p><p><a id="more"></a></p><h2 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h2><p>我们的模型有几个变量：</p><ul><li>第0期的用户数 C_0：最开始的用户数</li><li>人均邀请数 i：每个<strong>新</strong>用户发出去的邀请人数</li><li>感染率 Conv%：一个百分数，指每次邀请的成功率</li></ul><p>这里有个重要假设：每个周期只有新用户会发出邀请。相比于所有用户会在每个周期都发出邀请，这是个更合理的假设。</p><p>场景：每一个周期，每个新用户会邀请 i 个用户，这些用户有 Conv% 的概率会成功变成我们的用户。问题：到了第 t 期，我们的总用户会有多少个呢？</p><p>进一步计算前，我们就需要提到一个著名的概念<strong>病毒因子</strong>，病毒因子的公式是：<strong>人均邀请数 * 感染率%</strong>。</p><p>比如，如果人均邀请数是 10，感染率是 20%，那么第 t 期的每个新用户在第 t + 1 期会给我们带来 2 个新用户，这时病毒因子是 2。</p><p>理解了这个定义后，我们就能定义一个数学模型了。</p><ul><li>第 t 期的新用户数 = 第 t - 1 期的新用户数 * 病毒系数</li><li>第 t 期的总用户数 = 第 t - 1 期的总用户数 + 第 t 期的新用户数</li></ul><h2 id="R-代码"><a href="#R-代码" class="headerlink" title="R 代码"></a>R 代码</h2><p>我们可以用 R 写一套函数，根据不同参数计算总的裂变结果：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">get_new_customer &lt;- <span class="keyword">function</span>(new_customer_last, i, conv) {</span><br><span class="line">  viral_coef &lt;- i * conv</span><br><span class="line">  <span class="keyword">return</span>(new_customer_last * viral_coef)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">get_cycle_data &lt;- <span class="keyword">function</span>(customer_0, i, conv, t) {</span><br><span class="line">  df &lt;- data.frame(matrix(ncol = <span class="number">3</span>, nrow = t))</span><br><span class="line">  colnames(df) &lt;- c(<span class="string">'cycle'</span>, <span class="string">'new_user'</span>, <span class="string">'total_user'</span>)</span><br><span class="line">  </span><br><span class="line">  customer_total &lt;- customer_0</span><br><span class="line">  new_customer_last &lt;- customer_0</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> ( t_i <span class="keyword">in</span> <span class="number">1</span>:t) {</span><br><span class="line">    customer_new &lt;- get_new_customer(new_customer_last, i, conv)</span><br><span class="line">    customer_total &lt;- customer_total + customer_new</span><br><span class="line">    new_customer_last &lt;- customer_new</span><br><span class="line">    df[t_i, ] &lt;- list(t_i, customer_new, customer_total)</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span>(df)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我在这里写了两个函数。</p><ul><li>第一个函数会根据上一期的用户数、人均邀请数、感染率计算当期新用户</li><li>第二个函数会完整返回整个周期的新用户数、总用户数</li></ul><h2 id="病毒系数-1-时"><a href="#病毒系数-1-时" class="headerlink" title="病毒系数 = 1 时"></a>病毒系数 = 1 时</h2><p>我们先用第一组参数测试：</p><ul><li>t = 0 时，新用户有10个人</li><li>人均邀请数 = 10</li><li>感染率 = 10%</li></ul><p>此时病毒系数为 1，经过12个周期后，用户数据长什么样呢？</p><div class="table-container"><table><thead><tr><th style="text-align:center">周期</th><th style="text-align:center">新用户</th><th style="text-align:center">总用户</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">10</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">10</td><td style="text-align:center">30</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">10</td><td style="text-align:center">40</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">10</td><td style="text-align:center">50</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">10</td><td style="text-align:center">60</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">10</td><td style="text-align:center">70</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">10</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">10</td><td style="text-align:center">90</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">10</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">10</td><td style="text-align:center">110</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">10</td><td style="text-align:center">120</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">10</td><td style="text-align:center">130</td></tr></tbody></table></div><p>可以看到，每个周期的新用户数只有10个，12个周期后，用户只有130个。</p><p>从数学上来说，病毒系数等于1意味着：</p><ul><li>用户会有自然增长</li><li>用户每期的增长速度平缓，是线性的</li><li>从产品上来所，这不是个令人兴奋的场景</li></ul><h2 id="病毒系数-0-5-时"><a href="#病毒系数-0-5-时" class="headerlink" title="病毒系数 = 0.5 时"></a>病毒系数 = 0.5 时</h2><p>上一个产品的数据太差，我们换了个新产品。但因为产品设计问题，这个产品的用户没有那么强的分享欲望，人均分享减半了。</p><p>参数如下：</p><ul><li>t = 0 时，新用户有10个人</li><li>人均邀请数 = 5</li><li>感染率 = 10%</li></ul><p>结果如下（因为是数学模型，所以不用在乎0.5个人的问题）：</p><div class="table-container"><table><thead><tr><th style="text-align:center">周期</th><th style="text-align:center">新用户</th><th style="text-align:center">总用户</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">5.00</td><td style="text-align:center">15.00</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2.50</td><td style="text-align:center">17.50</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1.25</td><td style="text-align:center">18.75</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">0.62</td><td style="text-align:center">19.38</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">0.31</td><td style="text-align:center">19.69</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">0.16</td><td style="text-align:center">19.84</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">0.08</td><td style="text-align:center">19.92</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">0.04</td><td style="text-align:center">19.96</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">0.02</td><td style="text-align:center">19.98</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">0.01</td><td style="text-align:center">19.99</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">0.00</td><td style="text-align:center">20.00</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">0.00</td><td style="text-align:center">20.00</td></tr></tbody></table></div><p>在病毒系数等于0.5时，产品的用户数很快会停止增长，理论上的最大值是20个人，仅仅是初期用户数的两倍。谁都不希望开发这样的产品。</p><h2 id="病毒系数-2-时"><a href="#病毒系数-2-时" class="headerlink" title="病毒系数 = 2 时"></a>病毒系数 = 2 时</h2><p>上一个产品的数据让老板无法忍受，也是我们开发了一个新产品。我们优化了邀请的截图和文案，让邀请的感染率上升到了15%。</p><p>参数如下：</p><ul><li>t = 0 时，新用户有10个人</li><li>人均邀请数 = 10</li><li>感染率 = 20%</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">周期</th><th style="text-align:center">新用户</th><th style="text-align:center">总用户</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">20</td><td style="text-align:center">30</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">40</td><td style="text-align:center">70</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">80</td><td style="text-align:center">150</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">160</td><td style="text-align:center">310</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">320</td><td style="text-align:center">630</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">640</td><td style="text-align:center">1270</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">1280</td><td style="text-align:center">2550</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">2560</td><td style="text-align:center">5110</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">5120</td><td style="text-align:center">10230</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">10240</td><td style="text-align:center">20470</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">20480</td><td style="text-align:center">40950</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">40960</td><td style="text-align:center">81910</td></tr></tbody></table></div><p>病毒系数等于2时，12个周期后，产品的总用户数会达到8.1万。最神奇的是，用户数在某个周期几乎是翻倍增长。如果你碰到这样的产品，恭喜你，你离财富自由已经不远了。</p><h2 id="用图片病毒系数的差距的影响"><a href="#用图片病毒系数的差距的影响" class="headerlink" title="用图片病毒系数的差距的影响"></a>用图片病毒系数的差距的影响</h2><p>病毒系数不大于1，理论上我们实现不了自然增长和裂变。我们直到病毒系数越大越好，可是当病毒系数的大于1时，每增加0.2，究竟会有多大影响呢？</p><p>我们把这个数据用图片表示出来。</p><img src="/blog/2019/02/05/growth_1_base_model/plot_1.png" class="" title="病毒系数的影响"><p>虽然只是0.2的差异，但12个周期之后，不同病毒系数的表现是天壤之别。如果你对指数增长有所了解，应该会发现病毒系数较高时，用户增长是指数形式的。在指数模型下，每1个点的增长，都会是长期来看巨大的增长。</p><h2 id="模型的实践意义"><a href="#模型的实践意义" class="headerlink" title="模型的实践意义"></a>模型的实践意义</h2><p>这个简单的模型告诉我们：</p><ul><li><strong>病毒系数是裂变模型里最重要的因素</strong></li><li>要<strong>统计</strong>产品的人均邀请数和的感染率</li><li>不断<strong>优化</strong>人均邀请数和感染率</li></ul><p>不要小看这个实践意义，很多产品是完全没有统计邀请用户邀请数和邀请成功率的，如果连基本的“测量”都不做，又怎么谈得上基于数据的优化呢？</p><blockquote><p>If you can’t measure it, you can’t improve it.</p></blockquote><h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><ol><li><a href="/blog/2019/02/05/growth_1_base_model/" title="基础裂变模型">基础裂变模型</a> （本文）</li><li><a href="/blog/2019/03/05/growth_2_model_2/" title="升级版裂变模型">升级版裂变模型</a> </li></ol><p>参考：</p><ul><li><a href="https://www.forentrepreneurs.com/lessons-learnt-viral-marketing/" target="_blank" rel="noopener">David Skok: Lessons Learned – Viral Marketing</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2019/02/05/growth_1_base_model/plot_0.png&quot; class=&quot;&quot; title=&quot;病毒系数的影响&quot;&gt;
&lt;p&gt;增长黑客是近几年非常火爆的概念，指利用各种技术手段和产品手段帮助产品实现快速增长的人。其实在这个概念出现之前，增长就已经是一个技术和产品的混合领域了。&lt;/p&gt;
&lt;p&gt;按照增长黑客的理念，用户增长的起点不是从市场营销阶段开始，而是从产品的设计阶段就做了规划。比如，当今的所有产品都会考虑用户的自发推广。&lt;/p&gt;
&lt;p&gt;这个系列文章会建立一套增长黑客的数学模型，帮助我们更好地理解增长。&lt;/p&gt;
&lt;p&gt;我们先从最简单的世界开始。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在这个“创世篇”里，所有产品都只能在发布时做一次市场营销，之后的新用户都必须来自老用户的推荐。&lt;/strong&gt; 这个世界的增长故事会长成什么样呢？&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="增长黑客" scheme="https://yupototo.github.io/blog/categories/%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2/"/>
    
    
      <category term="R" scheme="https://yupototo.github.io/blog/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>Promise 系列之3：进阶</title>
    <link href="https://yupototo.github.io/blog/2019/01/30/coding-10-promise-3-more/"/>
    <id>https://yupototo.github.io/blog/2019/01/30/coding-10-promise-3-more/</id>
    <published>2019-01-30T10:58:56.000Z</published>
    <updated>2020-02-05T00:34:51.176Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇简单介绍了 promise 和 then 方法。</p><p>这一篇介绍几个进阶话题：</p><ul><li>Promise 的原理</li><li>Promise 的 constructor methods</li><li>Promise 的 prototype methods</li></ul><a id="more"></a><h2 id="Promise-的原理"><a href="#Promise-的原理" class="headerlink" title="Promise 的原理"></a>Promise 的原理</h2><p>Promise 有三种状态：</p><ol><li>pending：最初状态</li><li>fulfilled：resolve 对应的状态，会返回一个值</li><li>rejected：reject 对应的状态，会返回错误原因</li></ol><p>当 Promise 进入 fulfilled 或 rejected 状态，又被称为 settled。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  resolve()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(promise)</span><br><span class="line"><span class="comment">// Promise { undefined }</span></span><br></pre></td></tr></tbody></table></figure><p>上面显示 promise 处于 undefined 状态。</p><p>JavaScript 不支持返回 Promise 的状态，我们要把 Promise 当作一个黑箱子，用 then 方法 Promise 处理 fufilled 或 rejected 之后的事情。</p><h2 id="Promise-的-constructor-methods"><a href="#Promise-的-constructor-methods" class="headerlink" title="Promise 的 constructor methods"></a>Promise 的 constructor methods</h2><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p><code>Promise.resolve(value)</code> 是一个快捷方法，会得到一个 resolve 值为 value 的 promise。</p><p>原始方法：用<code>new</code>创建一个 promise：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>{</span><br><span class="line">  resolve(<span class="string">'resolve value'</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></tbody></table></figure><p>改进版，跟上面一个效果：用<code>Promise.resolve(value)</code></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve(<span class="string">'resolve value'</span>)</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></tbody></table></figure><p>还可以更精简一些：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'resolve value'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></tbody></table></figure><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p><code>Promise.reject(value)</code> 也是快捷方法，是<code>Promise.resovle(value)</code>的 reject 版。</p><p>原始方法：用<code>new</code>创建一个 promise：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'reject value'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Error: <span class="subst">${err}</span>`</span>))</span><br><span class="line"><span class="comment">// Error: reject value.</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p><code>Promise.all()</code> 需要一个 iterable 作为参数，iterable 内包含一组 promise。</p><p><code>Promise.all()</code> 返回一个新的 promise，如果它参数内的 promise 全部 resolve，它就返回所有的 resolve 值。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="built_in">Promise</span>.resolve(<span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([promise1, promise2, promise3])</span><br><span class="line">  .then(</span><br><span class="line">    res =&gt; <span class="built_in">console</span>.log(res)</span><br><span class="line">  )</span><br><span class="line"><span class="comment">// [1, 2, 'b']</span></span><br></pre></td></tr></tbody></table></figure><p>如果参数内的 promise 出现 reject，<code>Promise.all()</code> 也会 reject，并以参数内 promise 的 reject 的值作为自己的 reject 值。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="built_in">Promise</span>.reject(<span class="string">'reject info One'</span>)</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="built_in">Promise</span>.reject(<span class="string">'reject info Two'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([promise1, promise2, promise3])</span><br><span class="line">  .then(</span><br><span class="line">    res =&gt; <span class="built_in">console</span>.log(res)</span><br><span class="line">  )</span><br><span class="line">  .catch(</span><br><span class="line">    err =&gt; <span class="built_in">console</span>.log(err)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject info One</span></span><br></pre></td></tr></tbody></table></figure><p>上面有两个会 reject 的 promise，<code>Promise.all()</code> 会以第1个 reject 的值作为返回值。</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p><code>Promise.race()</code> 也接受一个 iterable 作为参数，它会 resolve 或 reject 最快进入 settled 状态的值。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  setTimeout(resolve, <span class="number">500</span>, <span class="string">'one'</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  setTimeout(resolve, <span class="number">100</span>, <span class="string">'two'</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([promise1, promise2])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 'two'</span></span><br></pre></td></tr></tbody></table></figure><p>因为第2个 promise 比第1个 promise 更快 settle，所以<code>Promise.race()</code>以第2个 promise 的 resolve 值作为自己的 resolve 值。</p><h2 id="Promise-的-prototype-methods"><a href="#Promise-的-prototype-methods" class="headerlink" title="Promise 的 prototype methods"></a>Promise 的 prototype methods</h2><p>Promise 有3个 prototype methods：</p><ul><li>then</li><li>catch</li><li>finally</li></ul><p>上一篇已经详细介绍了 <code>then()</code> 。</p><h3 id="catch"><a href="#catch" class="headerlink" title="catch()"></a>catch()</h3><p><code>catch()</code> 会在 promise 被 reject 时运行，除此之外，<code>catch()</code>也会返回一个 promise。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'reject value'</span>)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="string">`catch <span class="subst">${err}</span>`</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'resolve value is :'</span> + res))</span><br><span class="line"><span class="comment">// resolve value is :catch reject value</span></span><br></pre></td></tr></tbody></table></figure><p>第2行的 <code>catch()</code>会返回一个新的promise，对应的 resolve 值是回调函数的返回值。</p><h3 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h3><p>还有一个 prototype 方法：<code>finnaly()</code>，其中的回调函数无论 promise 结果是什么都会运行。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> rand = <span class="built_in">Math</span>.random()</span><br><span class="line">  <span class="keyword">if</span> (rand &gt; <span class="number">0.5</span>) {</span><br><span class="line">    resolve()</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    reject()</span><br><span class="line">  }</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'resolve'</span>))</span><br><span class="line">  .catch(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'reject'</span>))</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finally done'</span>))</span><br></pre></td></tr></tbody></table></figure><p>上面这段代码里，无论 promise 是 reject 还是 resolve，finally 都会打印出<code>finally done</code>。</p><h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><p>Promise 系列：</p><ol><li><a href="/blog/2019/01/15/coding-8-js-promise-1-why/" title="为什么需要 promise">为什么需要 promise</a> </li><li><a href="/blog/2019/01/20/coding-9-promise-2-what/" title="什么是 promise">什么是 promise</a> </li><li><a href="/blog/2019/01/30/coding-10-promise-3-more/" title="promise 进阶">promise 进阶</a> (本篇)</li><li><a href="/blog/2019/02/15/coding-11-promise-4-async/" title="async/await">async/await</a> </li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇简单介绍了 promise 和 then 方法。&lt;/p&gt;
&lt;p&gt;这一篇介绍几个进阶话题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Promise 的原理&lt;/li&gt;
&lt;li&gt;Promise 的 constructor methods&lt;/li&gt;
&lt;li&gt;Promise 的 prototype methods&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://yupototo.github.io/blog/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="https://yupototo.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ggplot系列之9：ggTimeSeries</title>
    <link href="https://yupototo.github.io/blog/2019/01/29/ggplot_9_ggTimeSeries/"/>
    <id>https://yupototo.github.io/blog/2019/01/29/ggplot_9_ggTimeSeries/</id>
    <published>2019-01-29T22:33:41.000Z</published>
    <updated>2020-02-05T00:34:51.184Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2019/01/29/ggplot_9_ggTimeSeries/daily_heatmap.png" class="" title="heatmap"><p>今天看到一个有趣的 R pakcage：<a href="https://github.com/AtherEnergy/ggTimeSeries" target="_blank" rel="noopener">ggTimeSeries</a> 能够对时间序列数据做出有趣的图片。</p><p><a id="more"></a></p><h2 id="日期热点图"><a href="#日期热点图" class="headerlink" title="日期热点图"></a>日期热点图</h2><p>我最喜欢的是下面这个日期热点图，它能够展示连续变量在一年里每天的数据情况，月份在 x 轴，工作日在 y 轴，数据大小用填充色表示。</p><p>我随便找了个每日温度数据，做出了最上面那个图，做图代码如下：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本图</span></span><br><span class="line">p0 &lt;- df %&gt;%</span><br><span class="line">  ggplot_calendar_heatmap(<span class="string">'date'</span>,<span class="string">'meantemp'</span>, dayBorderColour = <span class="string">'#cccccc'</span>, monthBorderColour = <span class="string">'#777777'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加工</span></span><br><span class="line">p0 +</span><br><span class="line">  scale_fill_continuous(low = <span class="string">'green'</span>, high = <span class="string">'red'</span>) + </span><br><span class="line">  facet_wrap(~Year, ncol = <span class="number">1</span>) +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>,</span><br><span class="line">       y = <span class="literal">NULL</span>,</span><br><span class="line">       fill = <span class="literal">NULL</span>,</span><br><span class="line">       title = <span class="string">'每日平均气温'</span>) +</span><br><span class="line">  theme_minimal() +</span><br><span class="line">  theme(text=element_text(family=<span class="string">"Songti TC Regular"</span>)) </span><br></pre></td></tr></tbody></table></figure><p>这个展示方式很适合用来展示有工作日趋势和季度趋势的时间序列数据，比如每日销售、网站访问量。</p><p>寒假和暑假经常是游戏流量的高峰，这个信息就能在这个图片上一目了然。</p><p>工作日的游戏流量低于周末，也很适合在这个图表上展示。</p><h2 id="waterfall-图"><a href="#waterfall-图" class="headerlink" title="waterfall 图"></a>waterfall 图</h2><p>这个 package 里还有一个我喜欢的图，waterfall 图：</p><img src="/blog/2019/01/29/ggplot_9_ggTimeSeries/gg_waterfall.png" class="" title="heatmap"><p>Waterfall 图用箭头标注了数据的每日变化，展示每天都有波动的数据很合适，比如股票价格等。</p><p>上图的做图代码：</p><figure class="highlight r"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本图</span></span><br><span class="line">df %&gt;%</span><br><span class="line">  ggplot_waterfall(<span class="string">'date'</span>,<span class="string">'meantemp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加工</span></span><br><span class="line">p0 +</span><br><span class="line">  labs(x = <span class="literal">NULL</span>,</span><br><span class="line">       y = <span class="literal">NULL</span>,</span><br><span class="line">       color = <span class="string">'变化'</span>,</span><br><span class="line">       title = <span class="string">'每日平均气温'</span>) +</span><br><span class="line">  theme_classic(<span class="number">16</span>) +</span><br><span class="line">  theme(text=element_text(family=<span class="string">"Songti TC Regular"</span>),</span><br><span class="line">        plot.title = element_text(hjust = <span class="number">0.5</span>)) </span><br><span class="line"></span><br><span class="line">  theme(text=element_text(family=<span class="string">"Songti TC Regular"</span>)) </span><br></pre></td></tr></tbody></table></figure><p>这个 package 里还有其他几个可视化方法，个人觉得不太实用，有兴趣的同学可以去看看。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2019/01/29/ggplot_9_ggTimeSeries/daily_heatmap.png&quot; class=&quot;&quot; title=&quot;heatmap&quot;&gt;
&lt;p&gt;今天看到一个有趣的 R pakcage：&lt;a href=&quot;https://github.com/AtherEnergy/ggTimeSeries&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ggTimeSeries&lt;/a&gt; 能够对时间序列数据做出有趣的图片。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="https://yupototo.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
      <category term="R" scheme="https://yupototo.github.io/blog/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>Promise 系列之2：是什么</title>
    <link href="https://yupototo.github.io/blog/2019/01/20/coding-9-promise-2-what/"/>
    <id>https://yupototo.github.io/blog/2019/01/20/coding-9-promise-2-what/</id>
    <published>2019-01-20T10:58:56.000Z</published>
    <updated>2020-02-05T00:34:51.176Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇说明了为什么需要 promise，这一篇介绍 promise 是什么。</p><p>可以用下面几句话来描述 promise：</p><ul><li>Promise 是一个 object</li><li>它承诺会在未来某个时间点返回一个值</li><li>它最后要么返回这个承诺的值，要么告诉我们为什么它不能履行承诺</li></ul><p>可以拿生活中的例子进一步举例：</p><ul><li>我在月初向老婆承诺，月底发奖金了就给她换一部手机</li><li>我开始干各种其他事情，就像忘掉了这个承诺</li><li>月底到了，我拿到了奖金，我想起了这个承诺，于是给老婆换了新手机</li><li>或者：月底到了，我没拿到奖金，我只能跟老婆说明原因然后道歉</li></ul><p>下面具体描述 promise 的机制。</p><a id="more"></a><h2 id="初识-Promise"><a href="#初识-Promise" class="headerlink" title="初识 Promise"></a>初识 Promise</h2><h3 id="construtor"><a href="#construtor" class="headerlink" title="construtor"></a>construtor</h3><p>promise 可以用 Promise contructor 创建：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="comment">//函数 )</span></span><br></pre></td></tr></tbody></table></figure><p><code>Promsie()</code>括号内还需要传入一个函数。</p><h3 id="constructor-里的函数"><a href="#constructor-里的函数" class="headerlink" title="constructor 里的函数"></a>constructor 里的函数</h3><p>需要传入的函数形式如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> innerFunc = <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">const</span> num = <span class="number">0.6</span></span><br><span class="line">  <span class="keyword">if</span> (num &gt; <span class="number">0.5</span>) {</span><br><span class="line">    resolve()</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    reject()</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>函数有两个参数：resolve 和 reject。我们可以设置满足哪些条件时 resolve，否则 reject。</p><p>在上面的函数，如果 num 大于 0.5，我们返回 resolve，否则 reject。</p><h3 id="完整的-promise"><a href="#完整的-promise" class="headerlink" title="完整的 promise"></a>完整的 promise</h3><p>把1.2的函数传入 Promise constructor，就获得了一个 promise。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(innerFunc)</span><br></pre></td></tr></tbody></table></figure><p>上面成功创建了一个 promise。</p><h3 id="resolve-之后"><a href="#resolve-之后" class="headerlink" title="resolve 之后"></a>resolve 之后</h3><p>接下来我们可以在后面的代码里使用 promise，并约定在 resolve 时运行某一段代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'resolved'</span>))</span><br></pre></td></tr></tbody></table></figure><p>我们可以用<code>.then()</code> 连接 promsie，表示”resolve 之后运行 then 里的代码”，then 里的代码需要是个回调函数。我们在上面打印了’resolved’。</p><p>一般把 <code>.then()</code> 放在第2行：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'resolved'</span>))</span><br></pre></td></tr></tbody></table></figure><h3 id="如果-reject"><a href="#如果-reject" class="headerlink" title="如果 reject"></a>如果 reject</h3><p>我们可能想在 reject 之后运行一段代码，这个时候可以用<code>.catch()</code>。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'resolved'</span>))</span><br><span class="line">  .catch(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'reject'</span>))</span><br></pre></td></tr></tbody></table></figure><h2 id="then"><a href="#then" class="headerlink" title="then"></a>then</h2><p>Promise 能够自带了一个<code>then()</code>方法。</p><p>在上面的例子里，我在<code>then</code>里使用了一个回调函数，表示<code>resolve</code>之后会运行这个函数。这是一般的用法。</p><p>实际上，<code>then</code> 可以接受两个回调函数：</p><ul><li>onFulfilled: resolve 之后运行的回调函数</li><li>onRejected: reject 之后运行的回调函数</li></ul><p>第2个回调函数都是 optional。</p><h3 id="then-使用2个回调函数"><a href="#then-使用2个回调函数" class="headerlink" title="then 使用2个回调函数"></a>then 使用2个回调函数</h3><p>下面在 then 里使用两个回调函数，第1个函数是 resolve 之后运行的函数，第2个是 reject 之后运行的函数。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then(</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'resolve'</span>),</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">'reject'</span>)</span><br><span class="line">  )</span><br></pre></td></tr></tbody></table></figure><h3 id="then-返回一个-promise"><a href="#then-返回一个-promise" class="headerlink" title="then 返回一个 promise"></a>then 返回一个 promise</h3><p>个人认为最让人困扰的设定是：then 会返回一个 promise。</p><p>证明如下：<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  resolve()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = promise</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// Promise { &lt;pending&gt; }</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>那么，这个 promise 的 resolve 和 reject 分别是什么呢？我们可以验证。既然它是个 promise，那么它也可以用接着用 then。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  resolve()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = promise</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">a.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></figure><p>屏幕打印出<code>1</code>，说明前一个 then 返回的 promise 的 resolve 值是 1，也就是前一个 then 里回调函数的返回值。</p><h3 id="then-可以链式连接"><a href="#then-可以链式连接" class="headerlink" title="then 可以链式连接"></a>then 可以链式连接</h3><p>既然 then 返回的也是 promise，那就可以直接在 then 之后用 then：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  resolve()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">1</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></tbody></table></figure><p>上面的代码里，第1个 then 返回了一个 <code>resolve(1)</code> 的 promise，第2个 then 打印这个 1。</p><h3 id="如果-then-的回调函数里不返回值"><a href="#如果-then-的回调函数里不返回值" class="headerlink" title="如果 then 的回调函数里不返回值"></a>如果 then 的回调函数里不返回值</h3><p>上一个例子里，then 里的函数返回了值，这个值就变成了新 promise 的 resolve 值。如果 then 里的函数不返回值呢？</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  resolve()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>))</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></tbody></table></figure><p>第6行的 then 里的回调函数没有返回值，我们在第7行打印新 promise 的resolve 值。结果：undefined。</p><h3 id="如果-then-的回调函数报错"><a href="#如果-then-的回调函数报错" class="headerlink" title="如果 then 的回调函数报错"></a>如果 then 的回调函数报错</h3><p>如果在 then 的回调函数里 throw error，</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  resolve()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Sorry, this is error'</span>)</span><br><span class="line">  })</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br><span class="line"><span class="comment">// Error: Sorry, this is error</span></span><br></pre></td></tr></tbody></table></figure><p>第7行里 throw 了 error，这个 then 返回的 promise 会 reject。Reject 的值是错误信息。</p><h3 id="如果-then-的回调函数返回-promise"><a href="#如果-then-的回调函数返回-promise" class="headerlink" title="如果 then 的回调函数返回 promise"></a>如果 then 的回调函数返回 promise</h3><p>这个是相对复杂的。</p><p>先看代码：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  resolve()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  resolve(<span class="string">'promise resolve'</span>)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise3 = promise1.then(<span class="function"><span class="params">()</span> =&gt;</span> promise2)</span><br><span class="line"></span><br><span class="line">promise3</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></tbody></table></figure><p>第1个 promise1 会 resolve。</p><p>第2个 promise2 会 resolve 得到 ‘promise resolve’，它在 <code>promise1.then()</code> 里的回调函数返回。</p><p>第3个 promise3 是<code>promise1.then()</code>得到的回调函数。</p><p>问题来了，promise3 的 resolve 和 reject 分别是什么呢？</p><p>答案：是 promise2 的 resolve 和 reject。</p><p>上面的代码会打印出<code>promise resolve</code>。</p><p>如果把 promise2 的代码修改成：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  reject(<span class="string">'promise reject'</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>前一段代码就会打印<code>promise reject</code>。</p><h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><p>Promise 系列：</p><ol><li><a href="/blog/2019/01/15/coding-8-js-promise-1-why/" title="为什么需要 promise">为什么需要 promise</a> </li><li><a href="/blog/2019/01/20/coding-9-promise-2-what/" title="什么是 promise">什么是 promise</a> (本篇)</li><li><a href="/blog/2019/01/30/coding-10-promise-3-more/" title="promise 进阶">promise 进阶</a></li><li><a href="/blog/2019/02/15/coding-11-promise-4-async/" title="async/await">async/await</a> </li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇说明了为什么需要 promise，这一篇介绍 promise 是什么。&lt;/p&gt;
&lt;p&gt;可以用下面几句话来描述 promise：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Promise 是一个 object&lt;/li&gt;
&lt;li&gt;它承诺会在未来某个时间点返回一个值&lt;/li&gt;
&lt;li&gt;它最后要么返回这个承诺的值，要么告诉我们为什么它不能履行承诺&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以拿生活中的例子进一步举例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我在月初向老婆承诺，月底发奖金了就给她换一部手机&lt;/li&gt;
&lt;li&gt;我开始干各种其他事情，就像忘掉了这个承诺&lt;/li&gt;
&lt;li&gt;月底到了，我拿到了奖金，我想起了这个承诺，于是给老婆换了新手机&lt;/li&gt;
&lt;li&gt;或者：月底到了，我没拿到奖金，我只能跟老婆说明原因然后道歉&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面具体描述 promise 的机制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://yupototo.github.io/blog/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="https://yupototo.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>决策树模型里的 Entropy</title>
    <link href="https://yupototo.github.io/blog/2019/01/17/stat_12_entropy/"/>
    <id>https://yupototo.github.io/blog/2019/01/17/stat_12_entropy/</id>
    <published>2019-01-17T07:06:33.000Z</published>
    <updated>2020-02-05T00:34:51.188Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2019/01/17/stat_12_entropy/decision-tree.png" class="" title="决策树"><p>决策树模型是机器学习的重要模型。决策树里有个概念，叫 entropy，模型的最优化函数基于 entropy 做出。</p><p>用一个诗意的说法，entropy 描述了世界的混乱程度。Split 能帮助降低混乱程度。</p><p>这篇文章用具体例子说明，split 如何降低 entropy。</p><p><a id="more"></a></p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>给定数据集中有 C 个分组，entropy 的公式如下：</p><img src="/blog/2019/01/17/stat_12_entropy/entropy.png" class="" title="entropy公式"><p>公式中的 pi 是第 c 类元素的出现概率。</p><h2 id="不可知与可知"><a href="#不可知与可知" class="headerlink" title="不可知与可知"></a>不可知与可知</h2><p>想象一个世界上只有“好人”，那么好人的概率是1。因为 log_2(1) = 0，此时的 entropy = 0。</p><p>想象另一个世界，只有坏人，那么好人的概率是0，这时 entropy = -1 * 0 * log_2(1) = 0。</p><p>上面两种情况，如果以 entropy 来描述，都是“可知”的，不存在任何混乱，这是个稳定的世界。</p><p>想象第3个世界：好人和坏人各占一半，那么 entropy = (0.5 * log_2(0.5)) + (0.5 * log_2(0.5)) = 1。</p><p>这是个极端“混乱”的世界，路上随便碰到一个人，你完全不知道他是好人还是坏人。在这里，不确定性达到最大值。</p><h2 id="引入解释变量"><a href="#引入解释变量" class="headerlink" title="引入解释变量"></a>引入解释变量</h2><p>我们还在第3个世界里，作为数据工作者，我们无法忍受这种混乱，于是我们决定建立一个模型，找到识别坏人和好人的方法。</p><p>我们去警察局获取了100个人的档案，其中有50个好人、50个坏人。档案里还有另一个数据：是否染发。</p><p>根据上面的档案数据，我们绘制表格如下：</p><img src="/blog/2019/01/17/stat_12_entropy/table.png" class="" title="好人坏人以及染发"><p>我们似乎可以用染发与否判断一个人是好人还是坏人。</p><p>如果使用上面的判断方式，我们的 entropy 会减少多少呢？</p><p>E(染发) =  10/45 * log_2(10/45) + 35/45 * log_2(35/45) = 0.76<br>E(不染发) =  40/55 * log_2(40/55) + 15/55 * log_2(15/55) = 0.85</p><p>然后按照频率加权平均，得到以染发预测好人的 entropy：<br>E(是否好人｜是否染发) = 45/100 * 0.76  + 55/100 * 0.85 = 0.81</p><p>现在我们看到一个染发者，就判断他是坏人，然后躲得远远的。我们会有一定的错判率（大概29%），但这已经比之前无法判断的情况有了进步，这个世界没有那么混乱了。怎么衡量混乱程度的减少呢？我们用原先的 entropy 减去基于某个因素做判断的 entropy，得到这个因素的 <strong>information gain</strong>：</p><p>IG= = E(是否好人) - E(是否好人|是否染发) = 1 - 0.81 = 0.19</p><p>引入染发这个 split，我们获得了 0.19 的进步。</p><p>如果我们有更多变量，我们就可以依次计算每个变量的 IG，并选择 IG 效果最好的变量作为解释变量。当我们依次选择出了若干个解释变量，所谓的决策树<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f332.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f332.png?v8">🌲</span>就出现了。</p><h2 id="一个引申"><a href="#一个引申" class="headerlink" title="一个引申"></a>一个引申</h2><p>如果公司对 A 方案有5成把握，在 entropy 函数里，混乱程度是最严重的。另外一个方案 B，公司只有2成把握，这时的 entropy 值比较低。</p><p>这是一个有意思的发现：我们希望 entropy 越低越好。站在公司角度，B 方案是个可以快速拒绝的方案：我们清楚地知道它大概率失败（假设两个方案的预期回报相等）。真正造成混乱后果，往往是 A 方案这样模棱两可的方案。</p><p>再看一个（半搞笑的）场景，假设有两个同事：</p><ul><li>A 员工的判断准确度是50%</li><li>B 员工的判断准确度是20%</li></ul><p>我会更希望自己的手下是哪个呢？按照 entropy 公式，B 员工的 entropy 值更低。此时我们选择 B 员工：我们只要做出跟 B 员工的判断相反的选择，就大概率正确了。而 A 员工呢，价值还不如一枚硬币，毕竟通过抛硬币做选择也能达到50%的准确度。</p><p>现实生活里有没有类似 B 员工的人呢？可能没有这样的人，但在某一类问题上，有人开能会习惯性犯错。</p><p>我曾经有个同事喜欢追求完美，总是没有办法按期完成任务，ta 经常会说“我觉得这个版本还不够好/我还没准备好，要不再等一等”。如果选择延期，结果往往更糟糕。在按期交付问题上，ta 的判断力就像只有20%的准确度 <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span>。当我意识到这点后，每次 ta 提出“可以延期“时，我总会立刻做出判断：不能延期了，必须交付。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2019/01/17/stat_12_entropy/decision-tree.png&quot; class=&quot;&quot; title=&quot;决策树&quot;&gt;
&lt;p&gt;决策树模型是机器学习的重要模型。决策树里有个概念，叫 entropy，模型的最优化函数基于 entropy 做出。&lt;/p&gt;
&lt;p&gt;用一个诗意的说法，entropy 描述了世界的混乱程度。Split 能帮助降低混乱程度。&lt;/p&gt;
&lt;p&gt;这篇文章用具体例子说明，split 如何降低 entropy。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="统计学" scheme="https://yupototo.github.io/blog/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>Promise 系列之1：为什么</title>
    <link href="https://yupototo.github.io/blog/2019/01/15/coding-8-js-promise-1-why/"/>
    <id>https://yupototo.github.io/blog/2019/01/15/coding-8-js-promise-1-why/</id>
    <published>2019-01-15T10:58:56.000Z</published>
    <updated>2020-02-05T00:34:51.176Z</updated>
    
    <content type="html"><![CDATA[<p>Promise 是 JavaScript ES6 的新特性，是一个异步操作的解决方案。对于我这个没有什么开发经验的小白，promise 实在有点难理解。这个系列笔记会总结 promise 的背景和应用。</p><p>第1个问题：为什么需要 promise。</p><a id="more"></a><h2 id="Callback-Sucks"><a href="#Callback-Sucks" class="headerlink" title="Callback Sucks"></a>Callback Sucks</h2><p>最重要的原因：回调函数不好用。</p><p>创建回调函数很容易，但回调函数用起来并不容易。</p><p>典型场景：</p><ul><li>需要先获取数据 a </li><li>然后利用数据 a 获取数据 b</li><li>然后利用数据 b 获取数据 c</li><li>然后利用数据 c 获取数据 d</li><li>然后利用数据 d 获取数据 e</li><li>展示数据 e</li></ul><p>其实这么恶心的业务逻辑我还没碰到过，不过看到上面这段需求我就已经感觉到反胃了。</p><p>上面的需求如果用 callback 风格，<strong>伪代码</strong>如下：</p><figure class="highlight js"><figcaption><span>Callback Hell</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第1段代码</span></span><br><span class="line">getData(url, a =&gt; {</span><br><span class="line">  getMoreData(a, b =&gt; {</span><br><span class="line">    getMoreData(b, c =&gt; {</span><br><span class="line">      getMoreData(c, d =&gt; {</span><br><span class="line">        getMoreData(d, e =&gt; {</span><br><span class="line">          <span class="built_in">console</span>.log(e)</span><br><span class="line">        })</span><br><span class="line">      })</span><br><span class="line">    })</span><br><span class="line">  })</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><ul><li>第1行：通过 GET url 获取到了 a，然后调用 callback，参数为 a</li><li>第2行：用a获取到了b，然后调用 callback，参数为 b</li><li>…</li></ul><p>上面这段逻辑，又被成为“回调地狱”，需要维护的人估计都想哭。</p><h2 id="Into-promise"><a href="#Into-promise" class="headerlink" title="Into promise"></a>Into promise</h2><p>先不讨论 promise 的定义。这里只需要直到，promise 能够很好地解决上面的问题。</p><p>Promise 提供了一个 then 方法，这个方法支持“链式调用”。</p><p>使用链式调用后，上面的“回调地狱”可以被写成：</p><figure class="highlight js"><figcaption><span>Promise</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getData()</span><br><span class="line">  .then(<span class="function"><span class="params">a</span> =&gt;</span> getMoreData(a))</span><br><span class="line">  .then(<span class="function"><span class="params">b</span> =&gt;</span> getMoreData(b))</span><br><span class="line">  .then(<span class="function"><span class="params">c</span> =&gt;</span> getMoreData(c))</span><br><span class="line">  .then(<span class="function"><span class="params">d</span> =&gt;</span> getMoreData(d))</span><br><span class="line">  .then(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br></pre></td></tr></tbody></table></figure><p>即使我们完全不同 promise，也能感觉到后一段代码的可读性更强。</p><p>在写了一段时间 promise 后，大家发现 promise 也有一些痛点，比如业务逻辑需要在 <code>then()</code> 中执行，如果业务逻辑复杂，代码的可读性也会变差。于是人们想到了新的方案：async/await。</p><h2 id="Even-better：async-await"><a href="#Even-better：async-await" class="headerlink" title="Even better：async/await"></a>Even better：async/await</h2><p>async/await 只是 promise 的语法糖，并没有引入新的东西。</p><p>使用 async 和 await 后，代码又可以修改成：</p><figure class="highlight js"><figcaption><span>async/await</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; {</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">await</span> getData()</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">await</span> getMoreData(a)</span><br><span class="line">  <span class="keyword">const</span> c = <span class="keyword">await</span> getMoreData(b)</span><br><span class="line">  <span class="keyword">const</span> e = <span class="keyword">await</span> getMoreData(c)</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">})()</span><br></pre></td></tr></tbody></table></figure><p>这段代码的大括号部分，看上去非常像平时写的同步代码了。业务逻辑按顺序描述，且“使用数据 a 获取数据 b” 的概念也能得到更清晰的展示。</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>从 callback 到 promise，再从 promise 到 async/await，让我想到了增长经济学里的“技术进步”：即使时间和资本投入不改变，通过更加先进的技术，经济也能得到发展。</p><p>传统的 callback 代码，程序员可能需要10个小时去创造并维护；进化到 promise 后，也许只需要8个小时；再进化到 async/await，也许只需要6个小时。对全世界所有的技术项目，这都是40%的成本压缩，人们所付出的，只是熟悉新功能需要的十几个小时。</p><p>这种技术进步，也可能是程序员并不会随着年龄变得更吃香的原因：年轻人一旦掌握了 async/await，写 callback 的老年程序员就变成了又贵又落后的原始产能。</p><h2 id="更多阅读"><a href="#更多阅读" class="headerlink" title="更多阅读"></a>更多阅读</h2><p>Promise 系列：</p><ol><li><a href="/blog/2019/01/15/coding-8-js-promise-1-why/" title="为什么需要 promise">为什么需要 promise</a> (本篇)</li><li><a href="/blog/2019/01/20/coding-9-promise-2-what/" title="什么是 promise">什么是 promise</a></li><li><a href="/blog/2019/01/30/coding-10-promise-3-more/" title="promise 进阶">promise 进阶</a></li><li><a href="/blog/2019/02/15/coding-11-promise-4-async/" title="async/await">async/await</a> </li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Promise 是 JavaScript ES6 的新特性，是一个异步操作的解决方案。对于我这个没有什么开发经验的小白，promise 实在有点难理解。这个系列笔记会总结 promise 的背景和应用。&lt;/p&gt;
&lt;p&gt;第1个问题：为什么需要 promise。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://yupototo.github.io/blog/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="https://yupototo.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 里的 callback</title>
    <link href="https://yupototo.github.io/blog/2019/01/11/coding-7-js-callback/"/>
    <id>https://yupototo.github.io/blog/2019/01/11/coding-7-js-callback/</id>
    <published>2019-01-11T09:40:13.000Z</published>
    <updated>2020-02-05T00:34:51.176Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 里，函数是 object，所以 function 的参数可以是 function。如果一个 function 被作为参数传入，它就被称为 callback function。</p><p>这篇文章是 callback 的学习笔记。</p><a id="more"></a><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><h3 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h3><p>按照 callback 的定义，我创建并执行一个需要 callback 的 function：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someFunc</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is some func'</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line marked"><span class="function"><span class="keyword">function</span> <span class="title">funcWithCallback</span>(<span class="params">callback</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is function funcWithCallback'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'before callback'</span>)</span><br><span class="line marked">  callback()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'after callback'</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">funcWithCallback(someFunc)</span><br><span class="line"></span><br><span class="line"><span class="comment">//this is function funcWithCallback</span></span><br><span class="line"><span class="comment">//becore callback</span></span><br><span class="line"><span class="comment">//this is some func</span></span><br><span class="line"><span class="comment">//after callback</span></span><br></pre></td></tr></tbody></table></figure><p>上面这段代码里：</p><ul><li><code>someFunc</code> 是个定义在 global scope 的函数，会打印一串文字</li><li><code>funcWithCallback</code> 是个需要传入 callback 的函数，注意在 argument 里有一个 <code>callback</code> 参数</li><li>在第9行，用 <code>callback()</code> 运行这个函数</li><li>最后我们给 <code>funcWithCallback</code> 传入 <code>someFunc</code> ，打印运行结果。</li></ul><p>注意，上面的参数名 <code>callback</code> 只是约定俗成，改成别的单词如 <code>abcdef</code> 也是可以的，只要第9行同样改成 <code>abcdef</code>。因为，运行一个函数的方式，就是在函数名后加<code>()</code>。</p><h3 id="在运行函数时直接定义-callback"><a href="#在运行函数时直接定义-callback" class="headerlink" title="在运行函数时直接定义 callback"></a>在运行函数时直接定义 callback</h3><p>刚才我们首先定义了 <code>someFunc</code>，然后再在 <code>funcWithCallback</code> 里使用它。另外一个常见的做法是，在需要 callback 的地方直接定义一个函数。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcWithCallback</span>(<span class="params">callback</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is function funcWithCallback'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'before callback'</span>)</span><br><span class="line">  callback()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'after callback'</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line marked">funcWithCallback(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line marked">  <span class="built_in">console</span>.log(<span class="string">'this is callback'</span>)</span><br><span class="line marked">})</span><br><span class="line"></span><br><span class="line"><span class="comment">//this is function funcWithCallback</span></span><br><span class="line"><span class="comment">//before callback</span></span><br><span class="line"><span class="comment">//this is callback</span></span><br><span class="line"><span class="comment">//after callback</span></span><br></pre></td></tr></tbody></table></figure><p>上面这段代码里，我在运行 <code>funcWithCallback</code> 时直接定义了一个函数作为 callback。</p><p>这个做法可以用箭头函数轻易改写：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">funcWithCallback(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'this is callback'</span>))</span><br></pre></td></tr></tbody></table></figure><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>JavaScript 里最经典的使用 callback 的函数是 <code>setTimeout(func, delay, ...args)</code>，用于推迟若干时间后执行 callback 函数。各个参数的含义是：</p><ul><li>func: callback 函数</li><li>delay: 推迟执行的时间</li><li>…args: func 的参数<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">name</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hello, <span class="subst">${name}</span>`</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">setTimeout(sayHi, <span class="number">1000</span>, <span class="string">'Pototo'</span>)</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="为什么要使用-callback"><a href="#为什么要使用-callback" class="headerlink" title="为什么要使用 callback"></a>为什么要使用 callback</h2><p>callback 主要用于异步场景。比如从某个 API 获取数据，在获取到数据之前，我们无法进行下一步；获取到数据后，我们就能调用 callback 执行下一步操作。</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>先看<strong>伪代码</strong>如下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dealWithData</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="comment">// some operation</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url, callback</span>) </span>{</span><br><span class="line">  <span class="comment">// get data from url</span></span><br><span class="line">  <span class="comment">// callback()</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">getData(<span class="string">'some-url'</span>, dealWithData)</span><br></pre></td></tr></tbody></table></figure><p>不习惯异步编程的同学可能会问，为什么不写成下面的形式呢？（还是伪代码）：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dealWithData</span>(<span class="params">data</span>) </span>{</span><br><span class="line">  <span class="comment">// some operation</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url</span>) </span>{</span><br><span class="line">  <span class="comment">// get data from url, return data</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = getData(<span class="string">'some-url'</span>)</span><br><span class="line">dealWithData(data)</span><br></pre></td></tr></tbody></table></figure><p>因为 <code>getData</code> 这个函数会一旦执行，会发出一个 GET request，这个 request 发出去后，我们无法确定需要多长时间执行（甚至不确定能不能正确取回数据）。用第2种写法，计算机就会等待结果的返回。假定我们在<code>getData</code>设定了最长等待时间是10秒，那么这10秒内，计算机什么也做不了。这是对计算资源的浪费，用户体验也很差。</p><p>如果使用 callback 做法，GET request 发出后，计算机就能去先做其他事情，直到获取 GET 的结果后，再继续执行 callback。</p><h3 id="模拟-http-request"><a href="#模拟-http-request" class="headerlink" title="模拟 http request"></a>模拟 http request</h3><p>可以用下面的代码模拟 http request 需要等待的特征：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url, callback</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'get data from url: '</span> + url)</span><br><span class="line">  setTimeout(callback, <span class="number">1000</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">getData(<span class="string">'www.twitter.com/data'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'working with data'</span>))</span><br><span class="line"></span><br><span class="line marked"><span class="built_in">console</span>.log(<span class="string">'do this first while waiting for data return'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//get data from url: www.twitter.com/data</span></span><br><span class="line marked"><span class="comment">//do this first while waiting for data return</span></span><br><span class="line"><span class="comment">//working with data</span></span><br></pre></td></tr></tbody></table></figure><p>我在这里用1秒钟的延迟模拟获取数据的耗时。</p><p>上面这段代码的执行顺序是：</p><ul><li>去“获取数据”（假装获取数据）</li><li>先运行第8行的代码</li><li>1秒后，运行 callback</li></ul><p>第8行代码在异步结果返回前就得到了运行，这就是 callback 的价值。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 JavaScript 里，函数是 object，所以 function 的参数可以是 function。如果一个 function 被作为参数传入，它就被称为 callback function。&lt;/p&gt;
&lt;p&gt;这篇文章是 callback 的学习笔记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Coding" scheme="https://yupototo.github.io/blog/categories/Coding/"/>
    
    
      <category term="JavaScript" scheme="https://yupototo.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数据团队的三个角色：数据科学家、数据分析师、数据工程师</title>
    <link href="https://yupototo.github.io/blog/2019/01/06/ds-3-data-team/"/>
    <id>https://yupototo.github.io/blog/2019/01/06/ds-3-data-team/</id>
    <published>2019-01-06T18:39:41.000Z</published>
    <updated>2020-02-05T00:34:51.176Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2019/01/06/ds-3-data-team/data.png" class="" title="三者的区别"><p>一般来说，一个完整的数据团队应该由3个角色构成：</p><ul><li>数据分析师 data analyst</li><li>数据工程师 data engineer</li><li>数据科学家 data scientist</li></ul><p>这篇文章总结三个角色的区别，并说明何种情况下团队里应该有这些角色。</p><a id="more"></a><h2 id="三个角色"><a href="#三个角色" class="headerlink" title="三个角色"></a>三个角色</h2><p>三个角色的工作有时会有一定程度的交集，这里只讨论三个角色的最重要差异。</p><ul><li>数据分析师： 需要了解业务，使用<strong>常规的数据分析方法</strong>为日常商业决策提供依据</li><li>数据工程师：创造和维护数据基础设施</li><li>数据科学家：掌握机器学习算法，擅长数学、统计学和编程，可以处理大数据分析需求</li></ul><h3 id="数据分析师"><a href="#数据分析师" class="headerlink" title="数据分析师"></a>数据分析师</h3><p>数据分析师是最常见的角色，已经存在了很多年。早期的数据分析师只需要掌握 Excel 的使用，生成日常数据报表，做一定的数据可视化。一般情况下，数据分析师还需要懂业务，并通过数据对商业决策提供建议。</p><p>稍微进阶的数据分析师，还会懂一些 inferential statistics，使用线性回归等方法做归因和预测。</p><p>随着大家的学习能力越来越强，数据分析已经变成了一个基本技能。在这个环境下，数据分析师的核心价值是什么呢？我认为是“懂业务”。</p><p>数据分析师需要非常了解自己业务的情况，拿游戏来举例，数据分析师应该了解自己所分析的游戏、了解游戏行业的数据特点。SLG 游戏和 ARPG 游戏就是两个完全不同的游戏类型，如果某个核心指标相同（比如7日ROI），数据分析师需要针对两种游戏做不同的判断。同时，数据分析师应该深度体验自己的游戏，并能结合游戏体验提出值得研究的问题。</p><p>因为“懂业务”同时也“懂数据”，数据分析师应该是最能影响项目决策的人。</p><p>数据分析师的常见学科背景：商科、经济学、统计学。</p><h3 id="数据工程师"><a href="#数据工程师" class="headerlink" title="数据工程师"></a>数据工程师</h3><p>数据工程师其实是“需要做数据相关开发工作”的程序员，比如数据存储、数据计算、数据后台的搭建等等。</p><p>在小一些的公司，数据工程师一般由后端开发人员兼任。大型的公司，会需要专门的数据工程师。</p><p>数据工程师的常见学科背景：计算机。</p><h3 id="数据科学家"><a href="#数据科学家" class="headerlink" title="数据科学家"></a>数据科学家</h3><p>数据科学家是最近几年又硅谷带动起来的新兴岗位。数据科学家最核心的特点是：能用<strong>科学的</strong>方法解决企业的数据分析问题。</p><p>为什么这里提到“科学的”方法呢？有两个原因。</p><p>第1，很多数据分析师的分析工作其实充满了主观判断，毫无科学性可言。举个例子，我在某上市游戏公司的数据部门上班时，发现他们的数据分析报告<strong>从来不会</strong>使用假设检验，重要决策只通过画图寻找相关性后“主观判断”。数据分析其实是个有着严格科学基础的工作，专业的数据科学家会让团队的数据决策更加准确。</p><p>第2，大数据的兴起，让数据分析工作从传统的 excel 就能解决变成必须依赖高强度的编程能力和数学能力。</p><p>数据科学家有如下特点：</p><ul><li>高学历</li><li>强大的数学和统计学能力</li><li>了解机器学习、NLP 等新兴数据分析领域的情况</li><li>强大的（数学）编程水平</li></ul><p>相比于数据分析师，数据科学家可能不是那么懂业务。<br>相比于数据工程师，数据科学家又不是那么懂数据库、API。</p><p></p><h2 id="三个角色的需求"><a href="#三个角色的需求" class="headerlink" title="三个角色的需求"></a>三个角色的需求</h2><p>数据分析师：大中小型团队都需要的角色<br>数据工程师：大型团队需要<br>数据科学家：大型团队需要</p><p>我了解的美国某著名游戏公司的情况：</p><ul><li>每一个项目里都有数据分析师，专门负责这个项目的分析工作和决策支持</li><li>数据工程师和数据科学家，不跟随项目走，在项目需要的时候提供工程支持和理论支持</li></ul><p>工作场景举例：</p><ul><li>数据分析师：日常分析需求、数据分析报告</li><li>数据工程师：分析师想要增加10个埋点，工程师满足这个需求</li><li>数据科学家：审查数据分析师的分析报告是否符合科学规范</li></ul><p>对最顶级的公司，竞争的核心点其实是数据科学家。一个强大的数据科学家团队，可以让数据决策的精准度得到巨大提高。因为，数据科学家可以把结论用概率的形式科学的表示出来。（也许某些数据分析师也可以，但我不敢信他们啊）。</p><p>如果没有数据科学家，很有可能出现两种情况：</p><ul><li>数据分析师给出质量无法保证的数据分析结果</li><li>团队依靠“数据可视化”的图像做出“猜测”</li></ul><p>什么叫“团队依靠图像做出猜测”呢？举个让我印象深刻的例子吧。在游戏公司上班时，项目负责人拉数据之后画两个折线图，发现两者都有向上的趋势，于是推测出两者正相关，进而得出了一个行动依据。在懂数据分析的人看来，这大概跟“夜观天象”的靠谱程度差不多吧。一个数据科学家会在这个问题上给出严谨的数学公式、编程计算和结果报告，这就是数据科学家的价值。</p><p>但是，只有在尊重科学的公司，数据科学家的声音才会被重视。这可能也是硅谷才有这么多数据科学家岗位的原因吧啊。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2019/01/06/ds-3-data-team/data.png&quot; class=&quot;&quot; title=&quot;三者的区别&quot;&gt;
&lt;p&gt;一般来说，一个完整的数据团队应该由3个角色构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据分析师 data analyst&lt;/li&gt;
&lt;li&gt;数据工程师 data engineer&lt;/li&gt;
&lt;li&gt;数据科学家 data scientist&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章总结三个角色的区别，并说明何种情况下团队里应该有这些角色。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据科学" scheme="https://yupototo.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
    
  </entry>
  
</feed>
