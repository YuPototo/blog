<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>商业与数据</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-10T19:40:23.499Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yu Qin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据团队的三个角色：数据科学家、数据分析师、数据工程师</title>
    <link href="http://yoursite.com/2018/05/06/2018-05-07-%E6%95%B0%E6%8D%AE%E5%9B%A2%E9%98%9F/"/>
    <id>http://yoursite.com/2018/05/06/2018-05-07-%E6%95%B0%E6%8D%AE%E5%9B%A2%E9%98%9F/</id>
    <published>2018-05-06T18:39:41.000Z</published>
    <updated>2020-01-10T19:40:23.499Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2018/05/06/2018-05-07-%E6%95%B0%E6%8D%AE%E5%9B%A2%E9%98%9F/data.png" class="" title="三者的区别"><p>一般来说，一个完整的数据团队应该由3个角色构成：</p><ul><li>数据分析师 data analyst</li><li>数据工程师 data engineer</li><li>数据科学家 data scientist</li></ul><p>这篇文章总结三个角色的区别，并说明何种情况下团队里应该有这些角色。</p><a id="more"></a><h2 id="三个角色"><a href="#三个角色" class="headerlink" title="三个角色"></a>三个角色</h2><p>三个角色的工作有时会有一定程度的交集，这里只讨论三个角色的最重要差异。</p><ul><li>数据分析师： 需要了解业务，使用<strong>常规的数据分析方法</strong>为日常商业决策提供依据</li><li>数据工程师：创造和维护数据基础设施</li><li>数据科学家：掌握机器学习算法，擅长数学、统计学和编程，可以处理大数据分析需求</li></ul><h3 id="数据分析师"><a href="#数据分析师" class="headerlink" title="数据分析师"></a>数据分析师</h3><p>数据分析师是最常见的角色，已经存在了很多年。早期的数据分析师只需要掌握 Excel 的使用，生成日常数据报表，做一定的数据可视化。一般情况下，数据分析师还需要懂业务，并通过数据对商业决策提供建议。</p><p>稍微进阶的数据分析师，还会懂一些 inferential statistics，使用线性回归等方法做归因和预测。</p><p>随着大家的学习能力越来越强，数据分析已经变成了一个基本技能。在这个环境下，数据分析师的核心价值是什么呢？我认为是“懂业务”。</p><p>数据分析师需要非常了解自己业务的情况，拿游戏来举例，数据分析师应该了解自己所分析的游戏、了解游戏行业的数据特点。SLG 游戏和 ARPG 游戏就是两个完全不同的游戏类型，如果某个核心指标相同（比如7日ROI），数据分析师需要针对两种游戏做不同的判断。同时，数据分析师应该深度体验自己的游戏，并能结合游戏体验提出值得研究的问题。</p><p>因为“懂业务”同时也“懂数据”，数据分析师应该是最能影响项目决策的人。</p><p>数据分析师的常见学科背景：商科、经济学、统计学。</p><h3 id="数据工程师"><a href="#数据工程师" class="headerlink" title="数据工程师"></a>数据工程师</h3><p>数据工程师其实是“需要做数据相关开发工作”的程序员，比如数据存储、数据计算、数据后台的搭建等等。</p><p>在小一些的公司，数据工程师一般由后端开发人员兼任。大型的公司，会需要专门的数据工程师。</p><p>数据工程师的常见学科背景：计算机。</p><h3 id="数据科学家"><a href="#数据科学家" class="headerlink" title="数据科学家"></a>数据科学家</h3><p>数据科学家是最近几年又硅谷带动起来的新兴岗位。数据科学家最核心的特点是：能用<strong>科学的</strong>方法解决企业的数据分析问题。</p><p>为什么这里提到“科学的”方法呢？有两个原因。</p><p>第1，很多数据分析师的分析工作其实充满了主观判断，毫无科学性可言。举个例子，我在某上市游戏公司的数据部门上班时，发现他们的数据分析报告<strong>从来不会</strong>使用假设检验，重要决策只通过画图寻找相关性后“主观判断”。数据分析其实是个有着严格科学基础的工作，专业的数据科学家会让团队的数据决策更加准确。</p><p>第2，大数据的兴起，让数据分析工作从传统的 excel 就能解决变成必须依赖高强度的编程能力和数学能力。</p><p>数据科学家有如下特点：</p><ul><li>高学历</li><li>强大的数学和统计学能力</li><li>了解机器学习、NLP 等新兴数据分析领域的情况</li><li>强大的（数学）编程水平</li></ul><p>相比于数据分析师，数据科学家可能不是那么懂业务。<br>相比于数据工程师，数据科学家又不是那么懂数据库、API。</p><p></p><h2 id="三个角色的需求"><a href="#三个角色的需求" class="headerlink" title="三个角色的需求"></a>三个角色的需求</h2><p>数据分析师：大中小型团队都需要的角色<br>数据工程师：大型团队需要<br>数据科学家：大型团队需要</p><p>我了解的美国某著名游戏公司的情况：</p><ul><li>每一个项目里都有数据分析师，专门负责这个项目的分析工作和决策支持</li><li>数据工程师和数据科学家，不跟随项目走，在项目需要的时候提供工程支持和理论支持</li></ul><p>工作场景举例：</p><ul><li>数据分析师：日常分析需求、数据分析报告</li><li>数据工程师：分析师想要增加10个埋点，工程师满足这个需求</li><li>数据科学家：审查数据分析师的分析报告是否符合科学规范</li></ul><p>对最顶级的公司，竞争的核心点其实是数据科学家。一个强大的数据科学家团队，可以让数据决策的精准度得到巨大提高。因为，数据科学家可以把结论用概率的形式科学的表示出来。（也许某些数据分析师也可以，但我不敢信他们啊）。</p><p>如果没有数据科学家，很有可能出现两种情况：</p><ul><li>数据分析师给出质量无法保证的数据分析结果</li><li>团队依靠“数据可视化”的图像做出“猜测”</li></ul><p>什么叫“团队依靠图像做出猜测”呢？举个让我印象深刻的例子吧。在游戏公司上班时，项目负责人拉数据之后画两个折线图，发现两者都有向上的趋势，于是推测出两者正相关，进而得出了一个行动依据。在懂数据分析的人看来，这大概跟“夜观天象”的靠谱程度差不多吧。一个数据科学家会在这个问题上给出严谨的数学公式、编程计算和结果报告，这就是数据科学家的价值。</p><p>但是，只有在尊重科学的公司，数据科学家的声音才会被重视。这可能也是硅谷才有这么多数据科学家岗位的原因吧啊。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2018/05/06/2018-05-07-%E6%95%B0%E6%8D%AE%E5%9B%A2%E9%98%9F/data.png&quot; class=&quot;&quot; title=&quot;三者的区别&quot;&gt;

&lt;p&gt;一般来说，一个完整的数据团队应该由3个角色构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据分析师 data analyst&lt;/li&gt;
&lt;li&gt;数据工程师 data engineer&lt;/li&gt;
&lt;li&gt;数据科学家 data scientist&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章总结三个角色的区别，并说明何种情况下团队里应该有这些角色。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>closure: 以 python 和 JavaScript 为例</title>
    <link href="http://yoursite.com/2017/03/04/2017-03-05-closure/"/>
    <id>http://yoursite.com/2017/03/04/2017-03-05-closure/</id>
    <published>2017-03-04T16:17:33.000Z</published>
    <updated>2020-01-10T19:40:23.499Z</updated>
    
    <content type="html"><![CDATA[<p>计算机语言里有个常用的概念，叫 closure（闭包）。这里用 python 和 JavaScript 作为对照例子，解释一下 closure 的含义。</p><p>先看一个问题，下面一段 python 代码，会在 terminal 上打印什么呢？</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">func = outer()</span><br><span class="line">func()</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面的代码出现了若干次 a，第1个 a 在“最外面”，第2个 a 在 outer 函数里，第3个 a 出现在 inner 函数里，而 inner 函数又在 outer 函数里。</p><p>上面这段话可以用 scope 的概念重新描述：</p><ul><li>第1个 a 在 global scope 中，整段代码都可以使用</li><li>第2个 a 在 outer 函数的 scope 中</li><li>第3个 a 不是个变量，是对变量的使用，那么它会使用第1个a、还是第2个a、还是报错呢？</li></ul><p>答案：terminal 回打印出 1，也就是说，inner 函数使用了 outer 函数里的 a。</p><p>这里有两个值得深究的地方。我们一个个看。</p><h2 id="1-向上查询"><a href="#1-向上查询" class="headerlink" title="1. 向上查询"></a>1. 向上查询</h2><p>先看下面这段代码。</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">  print(a)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure><p>在运行 func 函数时，计算机会现在 func 的 scope 寻找 a 变量，但我们没有定义 a 变量，这时计算机会“向上一层”查询，上一层就是 global scope，我们在上一层定义了 a 并令它为 1，计算机就认为自己找到了 a，于是打印出 a 的内容：1。</p><p>同样一段代码，可以在 JavaScript 中轻松实现：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunc()</span><br></pre></td></tr></table></figure><p>R 中也有类似的设计：</p><figure class="highlight r"><figcaption><span>R</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">my_function &lt;- <span class="keyword">function</span>() &#123;</span><br><span class="line">  print(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">my_function()</span><br></pre></td></tr></table></figure><p>我们运行上面3段代码时，都会得到 1。</p><p>在最开始的代码段里，上一层的 a 在 outer 函数里，是1，此时计算机不再往上寻找 a，所以就打印出了 1。如果我们把 outer 函数里的 <code>a = 1</code> 删掉呢？此时代码如下：</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">func = outer()</span><br><span class="line">func()</span><br></pre></td></tr></table></figure><p>因为找不到计算机在 outer 里找不到 a，它继续往上寻找，在 global scope 里找到了 a，于是打印出了 2。</p><p>这样的设计乍看之下不太友好：如果我们不小心在函数里使用了某个 global scope 的变量，计算机就不会报错，而是会继续运行程序。这岂不是不利于代码的稳定性。</p><p>虽然有这个潜在风险，很多语言还是选择了这个设计，自然是因为这个设计是有价值的。价值在哪儿呢？这就涉及到示例代码中第2个值得深究的地方了。</p><h2 id="2-函数可以返回函数"><a href="#2-函数可以返回函数" class="headerlink" title="2. 函数可以返回函数"></a>2. 函数可以返回函数</h2><p>在 python、R 和 JavaScript 里，函数都可以返回函数。</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">  a = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">func = outer()</span><br><span class="line">func()</span><br></pre></td></tr></table></figure><p>我们的 outer 函数的 return 值是一个 inner 函数。<br>通过 <code>func = outer()</code>，我们让 func 变成了 inner 函数。</p><p>这里值得注意的地方是，我们 return 的明明只是 inner 函数，代码里只有 <code>print(a)</code>这行，为什么这个 inner 函数会记住自己所在的 scope 里有个 a 变量呢？这就是 closure 这个概念了。</p><p>当我们在 outer 函数里返回 inner 函数时，与 inner 函数在同一个 scope 里面的变量也会被“包”进 inner 函数中，变成 inner 函数的 private variable。</p><p>这是一个非常有用的概念。</p><h2 id="closure-的应用"><a href="#closure-的应用" class="headerlink" title="closure 的应用"></a>closure 的应用</h2><p>我最喜欢的 closure 应用场景，是批量生成函数。</p><p>问题场景：我需要生成一组幂函数的值，指数分别为 2、3、4, x 分别是 -10 到 10 之间的整数。</p><p>在我不知道 closure 时，我会想生成一个带有2个参数的函数，然后使用 list comprehension。</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power_func</span><span class="params">(x, power)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> x ** power</span><br><span class="line"></span><br><span class="line">[ power_func(i, <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br><span class="line">[ power_func(i, <span class="number">3</span>) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br><span class="line">[ power_func(i, <span class="number">4</span>) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br></pre></td></tr></table></figure><p>这是一个看上去简单的解答，但并不是一个代码层面更“好”的解答。因为，有可能我们想要在多种场合重复使用某几个幂指数的函数，比如幂指数为2的函数，可能在我们的计算里非常常用，这时最好的做法是生成一个幂指数为2的函数，然后重复使用它。</p><p>这时就需要使用 closure了。如果使用 closure，上面的问题会这样解答：</p><figure class="highlight python"><figcaption><span>python</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power_func</span><span class="params">(power)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner_func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ** power</span><br><span class="line">  <span class="keyword">return</span> inner_func</span><br><span class="line"></span><br><span class="line">power_two = power_func(<span class="number">2</span>)</span><br><span class="line">power_three = power_func(<span class="number">3</span>)</span><br><span class="line">power_four = power_func(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ power_two(i) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br><span class="line">[ power_three(i) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br><span class="line">[ power_four(i) <span class="keyword">for</span> i <span class="keyword">in</span> list(range(<span class="number">-10</span>, <span class="number">10</span>))]</span><br></pre></td></tr></table></figure><p>这段代码看上去更长，但从“思路”上其实方便，代码的可读性也强了非常多。</p><p>类似的思考方式其实是写代码到一定阶段后必然会碰到的：如何抽象地设计出一个生成函数的函数，让我们的代码可读性更高，更加 DRY（ don’t repeat yourself ）。</p><p>同样一段代码，如果使用 JavaScript，可以这样写：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">powerFunc</span>(<span class="params">power</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, power)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> innerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> powerTwo = powerFunc(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> powerThree = powerFunc(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> powerFour = powerFunc(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numRange = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">21</span>), (x,i) =&gt; i - <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numRange.map(<span class="function"><span class="params">el</span> =&gt;</span> powerTwo(el)))</span><br><span class="line"><span class="built_in">console</span>.log(numRange.map(<span class="function"><span class="params">el</span> =&gt;</span> powerThree(el)))</span><br><span class="line"><span class="built_in">console</span>.log(numRange.map(<span class="function"><span class="params">el</span> =&gt;</span> powerFour(el)))</span><br></pre></td></tr></table></figure><h2 id="JavaScript-的连续箭头函数"><a href="#JavaScript-的连续箭头函数" class="headerlink" title="JavaScript 的连续箭头函数"></a>JavaScript 的连续箭头函数</h2><p>理解了 closure 的概念后，下面这段 JavaScript 代码就很好理解了：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeAddFunc = <span class="function"><span class="params">adder</span> =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> x + adder</span><br></pre></td></tr></table></figure><p>这其实就是 closure 的箭头函数写法，这里连续使用了两个箭头函数。完整写法如下：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAddFunc</span>(<span class="params">adder</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFunc</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + adder</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> innerFunc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用上面的 makeAddFunc 生成若干自己需要的函数：</p><figure class="highlight javascript"><figcaption><span>JavaScript</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addTwo = makeAddFunc(<span class="number">2</span>)</span><br><span class="line">addThree = makeAddFunc(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(addTwo(<span class="number">5</span>)) <span class="comment">// print 7</span></span><br><span class="line"><span class="built_in">console</span>.log(addThree(<span class="number">5</span>)) <span class="comment">// print 8</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>个人经验来说，closure 是一个“分水岭”，区分开新手 coder 和中级 coder。</p><p>如果我们对 closure 足够熟悉，我们会发现某些特定的场合简直是为 closure 天然而生。学会在这些场合使用 closure，会让我们的代码质量上一个台阶。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机语言里有个常用的概念，叫 closure（闭包）。这里用 python 和 JavaScript 作为对照例子，解释一下 closure 的含义。&lt;/p&gt;
&lt;p&gt;先看一个问题，下面一段 python 代码，会在 terminal 上打印什么呢？&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;figcaption&gt;&lt;span&gt;python&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; inner&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func = outer()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ggplot系列之一：散点图</title>
    <link href="http://yoursite.com/2017/01/05/2017-01-05-ggplot%E6%95%A3%E7%82%B9%E5%9B%BE/"/>
    <id>http://yoursite.com/2017/01/05/2017-01-05-ggplot%E6%95%A3%E7%82%B9%E5%9B%BE/</id>
    <published>2017-01-05T13:52:50.000Z</published>
    <updated>2020-01-10T19:40:23.499Z</updated>
    
    <content type="html"><![CDATA[<img src="/blog/2017/01/05/2017-01-05-ggplot%E6%95%A3%E7%82%B9%E5%9B%BE/plot_0.png" class="" title="一个散点图"><p>ggplot2 是 R 语言大神 Hardly Wickham 开发的数据可视化工具。Wickham 为数据可视化抽象出了一套“语法”，掌握这套语法后就可以系统性地生成可视化数据。</p><p>这个系列文章会介绍如何使用 ggplot2 做图。</p><p>本篇介绍最常见的散点图。</p><a id="more"></a><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>每次我拿到数据的第一件事情，就是看看不同变量的散点图长啥样，看到散点图之后，就能对变量之间的关系做一定猜测了。</p><p>我们先准备一份用来画图的数据。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">955</span>)</span><br><span class="line">obs_num &lt;- <span class="number">40</span></span><br><span class="line">dat &lt;- data.frame(cond = rep(c(<span class="string">"A"</span>, <span class="string">"B"</span>), each = obs_num / <span class="number">2</span>),</span><br><span class="line">                  x = <span class="number">1</span>:obs_num + rnorm(obs_num, sd = <span class="number">3</span>),</span><br><span class="line">                  y = <span class="number">1</span>:obs_num + rnorm(obs_num, sd = <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>我们的模拟数据有3个变量，x 和 y 是数字，cond 是一个 categorical 变量。</p><h2 id="最简单的散点图"><a href="#最简单的散点图" class="headerlink" title="最简单的散点图"></a>最简单的散点图</h2><p>下面画一个最简单的散点图。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ggplot(dat, aes(x = x, y = y)) + </span><br><span class="line">  geom_point() + </span><br><span class="line">  labs(title = <span class="string">'这是一个最简单的散点图'</span>)</span><br></pre></td></tr></table></figure><p>结果如下图：<br><img src="plot_1.png" alt="最简单的散点图"></p><h2 id="添加拟合曲线"><a href="#添加拟合曲线" class="headerlink" title="添加拟合曲线"></a>添加拟合曲线</h2><p>有时我们想更清晰地看到数据趋势，ggplot 可以帮我们快速添加一条拟合曲线。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ggplot(dat, aes(x = x, y = y)) + </span><br><span class="line">  geom_point() + </span><br><span class="line">  geom_smooth() +</span><br><span class="line">  labs(title = <span class="string">'带拟合曲线的散点图'</span>)</span><br></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="plot_2.png" alt="添加拟合曲线的散点图"></p><h2 id="给不同组的点上色"><a href="#给不同组的点上色" class="headerlink" title="给不同组的点上色"></a>给不同组的点上色</h2><p>如果数据中有不同的分组，我们会想在散点图中看到不同组的情况。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ggplot(dat, aes(x = x, y = y, color = cond)) + </span><br><span class="line">  geom_point() + </span><br><span class="line">  labs(title = <span class="string">'需要用颜色分组的散点图'</span>,</span><br><span class="line">       color = <span class="string">'分组'</span>)</span><br></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="plot_3.png" alt="带颜色的散点图"></p><h2 id="使用-facets"><a href="#使用-facets" class="headerlink" title="使用 facets"></a>使用 facets</h2><p>如果组别太多，上色可能会让人眼花缭乱，这时我们可以使用 facets。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ggplot(dat, aes(x = x, y = y)) + </span><br><span class="line">  geom_point() + </span><br><span class="line">  facet_wrap(~ cond) +</span><br><span class="line">  labs(title = <span class="string">'使用 facets 的散点图'</span>)</span><br></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="plot_4.png" alt="使用facet的散点图"></p><p>当然，我们也可以把颜色和 cond 结合起来，生成本文最开始那张图片。代码如下：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ggplot(dat, aes(x = x, y = y, color = cond)) + </span><br><span class="line">  geom_point() + </span><br><span class="line">  facet_wrap(~ cond)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/2017/01/05/2017-01-05-ggplot%E6%95%A3%E7%82%B9%E5%9B%BE/plot_0.png&quot; class=&quot;&quot; title=&quot;一个散点图&quot;&gt;

&lt;p&gt;ggplot2 是 R 语言大神 Hardly Wickham 开发的数据可视化工具。Wickham 为数据可视化抽象出了一套“语法”，掌握这套语法后就可以系统性地生成可视化数据。&lt;/p&gt;
&lt;p&gt;这个系列文章会介绍如何使用 ggplot2 做图。&lt;/p&gt;
&lt;p&gt;本篇介绍最常见的散点图。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
